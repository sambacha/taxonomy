exports.id = 7375;
exports.ids = [7375];
exports.modules = {

/***/ 91515:
/***/ ((module) => {

"use strict";

function _assertThisInitialized(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 9746:
/***/ ((module) => {

"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _asyncToGenerator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
module.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 13082:
/***/ ((module) => {

"use strict";

function _classApplyDescriptorGet(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
module.exports = _classApplyDescriptorGet, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 46141:
/***/ ((module) => {

"use strict";

function _classApplyDescriptorSet(receiver, descriptor, value) {
    if (descriptor.set) {
        descriptor.set.call(receiver, value);
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
module.exports = _classApplyDescriptorSet, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 97614:
/***/ ((module) => {

"use strict";

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 40419:
/***/ ((module) => {

"use strict";

function _classExtractFieldDescriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
}
module.exports = _classExtractFieldDescriptor, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 18987:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var classApplyDescriptorGet = __webpack_require__(13082);
var classExtractFieldDescriptor = __webpack_require__(40419);
function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "get");
    return classApplyDescriptorGet(receiver, descriptor);
}
module.exports = _classPrivateFieldGet, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 27961:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var classApplyDescriptorSet = __webpack_require__(46141);
var classExtractFieldDescriptor = __webpack_require__(40419);
function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "set");
    classApplyDescriptorSet(receiver, descriptor, value);
    return value;
}
module.exports = _classPrivateFieldSet, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 86462:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var setPrototypeOf = __webpack_require__(47047);
var isNativeReflectConstruct = __webpack_require__(91110);
function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
        module.exports = _construct = Reflect.construct.bind(), module.exports.__esModule = true, module.exports["default"] = module.exports;
    } else {
        module.exports = _construct = function _construct(Parent, args, Class) {
            var a = [
                null
            ];
            a.push.apply(a, args);
            var Constructor = Function.bind.apply(Parent, a);
            var instance = new Constructor();
            if (Class) setPrototypeOf(instance, Class.prototype);
            return instance;
        }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
    return _construct.apply(null, arguments);
}
module.exports = _construct, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 99304:
/***/ ((module) => {

"use strict";

function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 97054:
/***/ ((module) => {

"use strict";

function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 81370:
/***/ ((module) => {

"use strict";

function _extends() {
    module.exports = _extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    return _extends.apply(this, arguments);
}
module.exports = _extends, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 539:
/***/ ((module) => {

"use strict";

function _getPrototypeOf(o) {
    module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    return _getPrototypeOf(o);
}
module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 57697:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var setPrototypeOf = __webpack_require__(47047);
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    Object.defineProperty(subClass, "prototype", {
        writable: false
    });
    if (superClass) setPrototypeOf(subClass, superClass);
}
module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 11061:
/***/ ((module) => {

"use strict";

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    };
}
module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 91540:
/***/ ((module) => {

"use strict";

function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
module.exports = _isNativeFunction, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 91110:
/***/ ((module) => {

"use strict";

function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
module.exports = _isNativeReflectConstruct, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 99197:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var _typeof = (__webpack_require__(15987)["default"]);
var assertThisInitialized = __webpack_require__(91515);
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
    } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
    }
    return assertThisInitialized(self);
}
module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 96809:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var _typeof = (__webpack_require__(15987)["default"]);
function _regeneratorRuntime() {
    "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ 
    module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
        return exports;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
        obj[key] = desc.value;
    }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define(obj, key, value) {
        return Object.defineProperty(obj, key, {
            value: value,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }), obj[key];
    }
    try {
        define({}, "");
    } catch (err) {
        define = function define(obj, key, value) {
            return obj[key] = value;
        };
    }
    function wrap(innerFn, outerFn, self, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
        return defineProperty(generator, "_invoke", {
            value: makeInvokeMethod(innerFn, self, context)
        }), generator;
    }
    function tryCatch(fn, obj, arg) {
        try {
            return {
                type: "normal",
                arg: fn.call(obj, arg)
            };
        } catch (err) {
            return {
                type: "throw",
                arg: err
            };
        }
    }
    exports.wrap = wrap;
    var ContinueSentinel = {};
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function() {
        return this;
    });
    var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    function defineIteratorMethods(prototype) {
        [
            "next",
            "throw",
            "return"
        ].forEach(function(method) {
            define(prototype, method, function(arg) {
                return this._invoke(method, arg);
            });
        });
    }
    function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
            var record = tryCatch(generator[method], generator, arg);
            if ("throw" !== record.type) {
                var result = record.arg, value = result.value;
                return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value) {
                    invoke("next", value, resolve, reject);
                }, function(err) {
                    invoke("throw", err, resolve, reject);
                }) : PromiseImpl.resolve(value).then(function(unwrapped) {
                    result.value = unwrapped, resolve(result);
                }, function(error) {
                    return invoke("throw", error, resolve, reject);
                });
            }
            reject(record.arg);
        }
        var previousPromise;
        defineProperty(this, "_invoke", {
            value: function value(method, arg) {
                function callInvokeWithMethodAndArg() {
                    return new PromiseImpl(function(resolve, reject) {
                        invoke(method, arg, resolve, reject);
                    });
                }
                return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
            }
        });
    }
    function makeInvokeMethod(innerFn, self, context) {
        var state = "suspendedStart";
        return function(method, arg) {
            if ("executing" === state) throw new Error("Generator is already running");
            if ("completed" === state) {
                if ("throw" === method) throw arg;
                return doneResult();
            }
            for(context.method = method, context.arg = arg;;){
                var delegate = context.delegate;
                if (delegate) {
                    var delegateResult = maybeInvokeDelegate(delegate, context);
                    if (delegateResult) {
                        if (delegateResult === ContinueSentinel) continue;
                        return delegateResult;
                    }
                }
                if ("next" === context.method) context.sent = context._sent = context.arg;
                else if ("throw" === context.method) {
                    if ("suspendedStart" === state) throw state = "completed", context.arg;
                    context.dispatchException(context.arg);
                } else "return" === context.method && context.abrupt("return", context.arg);
                state = "executing";
                var record = tryCatch(innerFn, self, context);
                if ("normal" === record.type) {
                    if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
                    return {
                        value: record.arg,
                        done: context.done
                    };
                }
                "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
            }
        };
    }
    function maybeInvokeDelegate(delegate, context) {
        var method = delegate.iterator[context.method];
        if (undefined === method) {
            if (context.delegate = null, "throw" === context.method) {
                if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
                context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
            }
            return ContinueSentinel;
        }
        var record = tryCatch(method, delegate.iterator, context.arg);
        if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
        var info = record.arg;
        return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
    }
    function pushTryEntry(locs) {
        var entry = {
            tryLoc: locs[0]
        };
        1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal", delete record.arg, entry.completion = record;
    }
    function Context(tryLocsList) {
        this.tryEntries = [
            {
                tryLoc: "root"
            }
        ], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
    }
    function values(iterable) {
        if (iterable) {
            var iteratorMethod = iterable[iteratorSymbol];
            if (iteratorMethod) return iteratorMethod.call(iterable);
            if ("function" == typeof iterable.next) return iterable;
            if (!isNaN(iterable.length)) {
                var i = -1, next = function next() {
                    for(; ++i < iterable.length;){
                        if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
                    }
                    return next.value = undefined, next.done = !0, next;
                };
                return next.next = next;
            }
        }
        return {
            next: doneResult
        };
    }
    function doneResult() {
        return {
            value: undefined,
            done: !0
        };
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: !0
    }), defineProperty(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: !0
    }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
        var ctor = "function" == typeof genFun && genFun.constructor;
        return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
    }, exports.mark = function(genFun) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
    }, exports.awrap = function(arg) {
        return {
            __await: arg
        };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
    }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
        void 0 === PromiseImpl && (PromiseImpl = Promise);
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
        return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
            return result.done ? result.value : iter.next();
        });
    }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function() {
        return this;
    }), define(Gp, "toString", function() {
        return "[object Generator]";
    }), exports.keys = function(val) {
        var object = Object(val), keys = [];
        for(var key in object){
            keys.push(key);
        }
        return keys.reverse(), function next() {
            for(; keys.length;){
                var key = keys.pop();
                if (key in object) return next.value = key, next.done = !1, next;
            }
            return next.done = !0, next;
        };
    }, exports.values = values, Context.prototype = {
        constructor: Context,
        reset: function reset(skipTempReset) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for(var name in this){
                "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
            }
        },
        stop: function stop() {
            this.done = !0;
            var rootRecord = this.tryEntries[0].completion;
            if ("throw" === rootRecord.type) throw rootRecord.arg;
            return this.rval;
        },
        dispatchException: function dispatchException(exception) {
            if (this.done) throw exception;
            var context = this;
            function handle(loc, caught) {
                return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
            }
            for(var i = this.tryEntries.length - 1; i >= 0; --i){
                var entry = this.tryEntries[i], record = entry.completion;
                if ("root" === entry.tryLoc) return handle("end");
                if (entry.tryLoc <= this.prev) {
                    var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
                    if (hasCatch && hasFinally) {
                        if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
                        if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
                    } else if (hasCatch) {
                        if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
                    } else {
                        if (!hasFinally) throw new Error("try statement without catch or finally");
                        if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
                    }
                }
            }
        },
        abrupt: function abrupt(type, arg) {
            for(var i = this.tryEntries.length - 1; i >= 0; --i){
                var entry = this.tryEntries[i];
                if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                    var finallyEntry = entry;
                    break;
                }
            }
            finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
            var record = finallyEntry ? finallyEntry.completion : {};
            return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
        },
        complete: function complete(record, afterLoc) {
            if ("throw" === record.type) throw record.arg;
            return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
        },
        finish: function finish(finallyLoc) {
            for(var i = this.tryEntries.length - 1; i >= 0; --i){
                var entry = this.tryEntries[i];
                if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
            }
        },
        "catch": function _catch(tryLoc) {
            for(var i = this.tryEntries.length - 1; i >= 0; --i){
                var entry = this.tryEntries[i];
                if (entry.tryLoc === tryLoc) {
                    var record = entry.completion;
                    if ("throw" === record.type) {
                        var thrown = record.arg;
                        resetTryEntry(entry);
                    }
                    return thrown;
                }
            }
            throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
            return this.delegate = {
                iterator: values(iterable),
                resultName: resultName,
                nextLoc: nextLoc
            }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
        }
    }, exports;
}
module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 47047:
/***/ ((module) => {

"use strict";

function _setPrototypeOf(o, p) {
    module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    return _setPrototypeOf(o, p);
}
module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 15987:
/***/ ((module) => {

"use strict";

function _typeof(obj) {
    "@babel/helpers - typeof";
    return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(obj);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 46502:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getPrototypeOf = __webpack_require__(539);
var setPrototypeOf = __webpack_require__(47047);
var isNativeFunction = __webpack_require__(91540);
var construct = __webpack_require__(86462);
function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;
    module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
        if (Class === null || !isNativeFunction(Class)) return Class;
        if (typeof Class !== "function") {
            throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
            if (_cache.has(Class)) return _cache.get(Class);
            _cache.set(Class, Wrapper);
        }
        function Wrapper() {
            return construct(Class, arguments, getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class.prototype, {
            constructor: {
                value: Wrapper,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        return setPrototypeOf(Wrapper, Class);
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    return _wrapNativeSuper(Class);
}
module.exports = _wrapNativeSuper, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 88315:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// TODO(Babel 8): Remove this file.

var runtime = __webpack_require__(96809)();
module.exports = runtime;
// Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=
try {
    regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
    if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
    } else {
        Function("r", "regeneratorRuntime = r")(runtime);
    }
}


/***/ }),

/***/ 45158:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({
    value: true
});
exports.N = void 0;
function PrismaAdapter(p) {
    return {
        createUser: (data)=>p.user.create({
                data
            }),
        getUser: (id)=>p.user.findUnique({
                where: {
                    id
                }
            }),
        getUserByEmail: (email)=>p.user.findUnique({
                where: {
                    email
                }
            }),
        async getUserByAccount (provider_providerAccountId) {
            var _a;
            const account = await p.account.findUnique({
                where: {
                    provider_providerAccountId
                },
                select: {
                    user: true
                }
            });
            return (_a = account === null || account === void 0 ? void 0 : account.user) !== null && _a !== void 0 ? _a : null;
        },
        updateUser: ({ id , ...data })=>p.user.update({
                where: {
                    id
                },
                data
            }),
        deleteUser: (id)=>p.user.delete({
                where: {
                    id
                }
            }),
        linkAccount: (data)=>p.account.create({
                data
            }),
        unlinkAccount: (provider_providerAccountId)=>p.account.delete({
                where: {
                    provider_providerAccountId
                }
            }),
        async getSessionAndUser (sessionToken) {
            const userAndSession = await p.session.findUnique({
                where: {
                    sessionToken
                },
                include: {
                    user: true
                }
            });
            if (!userAndSession) return null;
            const { user , ...session } = userAndSession;
            return {
                user,
                session
            };
        },
        createSession: (data)=>p.session.create({
                data
            }),
        updateSession: (data)=>p.session.update({
                where: {
                    sessionToken: data.sessionToken
                },
                data
            }),
        deleteSession: (sessionToken)=>p.session.delete({
                where: {
                    sessionToken
                }
            }),
        async createVerificationToken (data) {
            const verificationToken = await p.verificationToken.create({
                data
            });
            // @ts-expect-errors // MongoDB needs an ID, but we don't
            if (verificationToken.id) delete verificationToken.id;
            return verificationToken;
        },
        async useVerificationToken (identifier_token) {
            try {
                const verificationToken = await p.verificationToken.delete({
                    where: {
                        identifier_token
                    }
                });
                // @ts-expect-errors // MongoDB needs an ID, but we don't
                if (verificationToken.id) delete verificationToken.id;
                return verificationToken;
            } catch (error) {
                // If token already used/deleted, just return null
                // https://www.prisma.io/docs/reference/api-reference/error-reference#p2025
                if (error.code === "P2025") return null;
                throw error;
            }
        }
    };
}
exports.N = PrismaAdapter;


/***/ }),

/***/ 37291:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": () => (/* binding */ esm_hkdf),
  "hkdf": () => (/* binding */ esm_hkdf)
});

// EXTERNAL MODULE: external "crypto"
var external_crypto_ = __webpack_require__(6113);
;// CONCATENATED MODULE: ./node_modules/.pnpm/@panva+hkdf@1.0.2/node_modules/@panva/hkdf/dist/node/esm/runtime/fallback.js

/* harmony default export */ const fallback = ((digest, ikm, salt, info, keylen)=>{
    const hashlen = parseInt(digest.substr(3), 10) >> 3 || 20;
    const prk = (0,external_crypto_.createHmac)(digest, salt.byteLength ? salt : new Uint8Array(hashlen)).update(ikm).digest();
    const N = Math.ceil(keylen / hashlen);
    const T = new Uint8Array(hashlen * N + info.byteLength + 1);
    let prev = 0;
    let start = 0;
    for(let c = 1; c <= N; c++){
        T.set(info, start);
        T[start + info.byteLength] = c;
        T.set((0,external_crypto_.createHmac)(digest, prk).update(T.subarray(prev, start + info.byteLength + 1)).digest(), start);
        prev = start;
        start += hashlen;
    }
    return T.slice(0, keylen);
});

;// CONCATENATED MODULE: ./node_modules/.pnpm/@panva+hkdf@1.0.2/node_modules/@panva/hkdf/dist/node/esm/runtime/hkdf.js


let hkdf;
if (typeof external_crypto_.hkdf === "function" && !process.versions.electron) {
    hkdf = async (...args)=>new Promise((resolve, reject)=>{
            external_crypto_.hkdf(...args, (err, arrayBuffer)=>{
                if (err) reject(err);
                else resolve(new Uint8Array(arrayBuffer));
            });
        });
}
/* harmony default export */ const runtime_hkdf = (async (digest, ikm, salt, info, keylen)=>(hkdf || fallback)(digest, ikm, salt, info, keylen));

;// CONCATENATED MODULE: ./node_modules/.pnpm/@panva+hkdf@1.0.2/node_modules/@panva/hkdf/dist/node/esm/index.js

function normalizeDigest(digest) {
    switch(digest){
        case "sha256":
        case "sha384":
        case "sha512":
        case "sha1":
            return digest;
        default:
            throw new TypeError('unsupported "digest" value');
    }
}
function normalizeUint8Array(input, label) {
    if (typeof input === "string") return new TextEncoder().encode(input);
    if (!(input instanceof Uint8Array)) throw new TypeError(`"${label}"" must be an instance of Uint8Array or a string`);
    return input;
}
function normalizeIkm(input) {
    const ikm = normalizeUint8Array(input, "ikm");
    if (!ikm.byteLength) throw new TypeError(`"ikm" must be at least one byte in length`);
    return ikm;
}
function normalizeInfo(input) {
    const info = normalizeUint8Array(input, "info");
    if (info.byteLength > 1024) {
        throw TypeError('"info" must not contain more than 1024 bytes');
    }
    return info;
}
function normalizeKeylen(input, digest) {
    if (typeof input !== "number" || !Number.isInteger(input) || input < 1) {
        throw new TypeError('"keylen" must be a positive integer');
    }
    const hashlen = parseInt(digest.substr(3), 10) >> 3 || 20;
    if (input > 255 * hashlen) {
        throw new TypeError('"keylen" too large');
    }
    return input;
}
async function esm_hkdf(digest, ikm, salt, info, keylen) {
    return runtime_hkdf(normalizeDigest(digest), normalizeIkm(ikm), normalizeUint8Array(salt, "salt"), normalizeInfo(info), normalizeKeylen(keylen, digest));
}



/***/ }),

/***/ 19138:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = __webpack_require__(43204);


/***/ }),

/***/ 60212:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var utils = __webpack_require__(78796);
var settle = __webpack_require__(94045);
var buildFullPath = __webpack_require__(75697);
var buildURL = __webpack_require__(48248);
var http = __webpack_require__(13685);
var https = __webpack_require__(95687);
var httpFollow = (__webpack_require__(45933).http);
var httpsFollow = (__webpack_require__(45933).https);
var url = __webpack_require__(57310);
var zlib = __webpack_require__(59796);
var VERSION = (__webpack_require__(24577).version);
var createError = __webpack_require__(80440);
var enhanceError = __webpack_require__(25058);
var defaults = __webpack_require__(25261);
var Cancel = __webpack_require__(6700);
var isHttps = /https:?/;
/**
 *
 * @param {http.ClientRequestArgs} options
 * @param {AxiosProxyConfig} proxy
 * @param {string} location
 */ function setProxy(options, proxy, location) {
    options.hostname = proxy.host;
    options.host = proxy.host;
    options.port = proxy.port;
    options.path = location;
    // Basic proxy authorization
    if (proxy.auth) {
        var base64 = Buffer.from(proxy.auth.username + ":" + proxy.auth.password, "utf8").toString("base64");
        options.headers["Proxy-Authorization"] = "Basic " + base64;
    }
    // If a proxy is used, any redirects must also pass through the proxy
    options.beforeRedirect = function beforeRedirect(redirection) {
        redirection.headers.host = redirection.host;
        setProxy(redirection, proxy, redirection.href);
    };
}
/*eslint consistent-return:0*/ module.exports = function httpAdapter(config) {
    return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
        var onCanceled;
        function done() {
            if (config.cancelToken) {
                config.cancelToken.unsubscribe(onCanceled);
            }
            if (config.signal) {
                config.signal.removeEventListener("abort", onCanceled);
            }
        }
        var resolve = function resolve(value) {
            done();
            resolvePromise(value);
        };
        var rejected = false;
        var reject = function reject(value) {
            done();
            rejected = true;
            rejectPromise(value);
        };
        var data = config.data;
        var headers = config.headers;
        var headerNames = {};
        Object.keys(headers).forEach(function storeLowerName(name) {
            headerNames[name.toLowerCase()] = name;
        });
        // Set User-Agent (required by some servers)
        // See https://github.com/axios/axios/issues/69
        if ("user-agent" in headerNames) {
            // User-Agent is specified; handle case where no UA header is desired
            if (!headers[headerNames["user-agent"]]) {
                delete headers[headerNames["user-agent"]];
            }
        // Otherwise, use specified value
        } else {
            // Only set header if it hasn't been set in config
            headers["User-Agent"] = "axios/" + VERSION;
        }
        if (data && !utils.isStream(data)) {
            if (Buffer.isBuffer(data)) {
            // Nothing to do...
            } else if (utils.isArrayBuffer(data)) {
                data = Buffer.from(new Uint8Array(data));
            } else if (utils.isString(data)) {
                data = Buffer.from(data, "utf-8");
            } else {
                return reject(createError("Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream", config));
            }
            if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
                return reject(createError("Request body larger than maxBodyLength limit", config));
            }
            // Add Content-Length header if data exists
            if (!headerNames["content-length"]) {
                headers["Content-Length"] = data.length;
            }
        }
        // HTTP basic authentication
        var auth = undefined;
        if (config.auth) {
            var username = config.auth.username || "";
            var password = config.auth.password || "";
            auth = username + ":" + password;
        }
        // Parse url
        var fullPath = buildFullPath(config.baseURL, config.url);
        var parsed = url.parse(fullPath);
        var protocol = parsed.protocol || "http:";
        if (!auth && parsed.auth) {
            var urlAuth = parsed.auth.split(":");
            var urlUsername = urlAuth[0] || "";
            var urlPassword = urlAuth[1] || "";
            auth = urlUsername + ":" + urlPassword;
        }
        if (auth && headerNames.authorization) {
            delete headers[headerNames.authorization];
        }
        var isHttpsRequest = isHttps.test(protocol);
        var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
        var options = {
            path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, ""),
            method: config.method.toUpperCase(),
            headers: headers,
            agent: agent,
            agents: {
                http: config.httpAgent,
                https: config.httpsAgent
            },
            auth: auth
        };
        if (config.socketPath) {
            options.socketPath = config.socketPath;
        } else {
            options.hostname = parsed.hostname;
            options.port = parsed.port;
        }
        var proxy = config.proxy;
        if (!proxy && proxy !== false) {
            var proxyEnv = protocol.slice(0, -1) + "_proxy";
            var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];
            if (proxyUrl) {
                var parsedProxyUrl = url.parse(proxyUrl);
                var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
                var shouldProxy = true;
                if (noProxyEnv) {
                    var noProxy = noProxyEnv.split(",").map(function trim(s) {
                        return s.trim();
                    });
                    shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
                        if (!proxyElement) {
                            return false;
                        }
                        if (proxyElement === "*") {
                            return true;
                        }
                        if (proxyElement[0] === "." && parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {
                            return true;
                        }
                        return parsed.hostname === proxyElement;
                    });
                }
                if (shouldProxy) {
                    proxy = {
                        host: parsedProxyUrl.hostname,
                        port: parsedProxyUrl.port,
                        protocol: parsedProxyUrl.protocol
                    };
                    if (parsedProxyUrl.auth) {
                        var proxyUrlAuth = parsedProxyUrl.auth.split(":");
                        proxy.auth = {
                            username: proxyUrlAuth[0],
                            password: proxyUrlAuth[1]
                        };
                    }
                }
            }
        }
        if (proxy) {
            options.headers.host = parsed.hostname + (parsed.port ? ":" + parsed.port : "");
            setProxy(options, proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
        }
        var transport;
        var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);
        if (config.transport) {
            transport = config.transport;
        } else if (config.maxRedirects === 0) {
            transport = isHttpsProxy ? https : http;
        } else {
            if (config.maxRedirects) {
                options.maxRedirects = config.maxRedirects;
            }
            transport = isHttpsProxy ? httpsFollow : httpFollow;
        }
        if (config.maxBodyLength > -1) {
            options.maxBodyLength = config.maxBodyLength;
        }
        if (config.insecureHTTPParser) {
            options.insecureHTTPParser = config.insecureHTTPParser;
        }
        // Create the request
        var req = transport.request(options, function handleResponse(res) {
            if (req.aborted) return;
            // uncompress the response body transparently if required
            var stream = res;
            // return the last request in case of redirects
            var lastRequest = res.req || req;
            // if no content, is HEAD request or decompress disabled we should not decompress
            if (res.statusCode !== 204 && lastRequest.method !== "HEAD" && config.decompress !== false) {
                switch(res.headers["content-encoding"]){
                    /*eslint default-case:0*/ case "gzip":
                    case "compress":
                    case "deflate":
                        // add the unzipper to the body stream processing pipeline
                        stream = stream.pipe(zlib.createUnzip());
                        // remove the content-encoding in order to not confuse downstream operations
                        delete res.headers["content-encoding"];
                        break;
                }
            }
            var response = {
                status: res.statusCode,
                statusText: res.statusMessage,
                headers: res.headers,
                config: config,
                request: lastRequest
            };
            if (config.responseType === "stream") {
                response.data = stream;
                settle(resolve, reject, response);
            } else {
                var responseBuffer = [];
                var totalResponseBytes = 0;
                stream.on("data", function handleStreamData(chunk) {
                    responseBuffer.push(chunk);
                    totalResponseBytes += chunk.length;
                    // make sure the content length is not over the maxContentLength if specified
                    if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
                        // stream.destoy() emit aborted event before calling reject() on Node.js v16
                        rejected = true;
                        stream.destroy();
                        reject(createError("maxContentLength size of " + config.maxContentLength + " exceeded", config, null, lastRequest));
                    }
                });
                stream.on("aborted", function handlerStreamAborted() {
                    if (rejected) {
                        return;
                    }
                    stream.destroy();
                    reject(createError("error request aborted", config, "ERR_REQUEST_ABORTED", lastRequest));
                });
                stream.on("error", function handleStreamError(err) {
                    if (req.aborted) return;
                    reject(enhanceError(err, config, null, lastRequest));
                });
                stream.on("end", function handleStreamEnd() {
                    try {
                        var responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
                        if (config.responseType !== "arraybuffer") {
                            responseData = responseData.toString(config.responseEncoding);
                            if (!config.responseEncoding || config.responseEncoding === "utf8") {
                                responseData = utils.stripBOM(responseData);
                            }
                        }
                        response.data = responseData;
                    } catch (err) {
                        reject(enhanceError(err, config, err.code, response.request, response));
                    }
                    settle(resolve, reject, response);
                });
            }
        });
        // Handle errors
        req.on("error", function handleRequestError(err) {
            if (req.aborted && err.code !== "ERR_FR_TOO_MANY_REDIRECTS") return;
            reject(enhanceError(err, config, null, req));
        });
        // set tcp keep alive to prevent drop connection by peer
        req.on("socket", function handleRequestSocket(socket) {
            // default interval of sending ack packet is 1 minute
            socket.setKeepAlive(true, 1000 * 60);
        });
        // Handle request timeout
        if (config.timeout) {
            // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.
            var timeout = parseInt(config.timeout, 10);
            if (isNaN(timeout)) {
                reject(createError("error trying to parse `config.timeout` to int", config, "ERR_PARSE_TIMEOUT", req));
                return;
            }
            // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.
            // And timer callback will be fired, and abort() will be invoked before connection, then get "socket hang up" and code ECONNRESET.
            // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.
            // And then these socket which be hang up will devoring CPU little by little.
            // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.
            req.setTimeout(timeout, function handleRequestTimeout() {
                req.abort();
                var transitional = config.transitional || defaults.transitional;
                reject(createError("timeout of " + timeout + "ms exceeded", config, transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED", req));
            });
        }
        if (config.cancelToken || config.signal) {
            // Handle cancellation
            // eslint-disable-next-line func-names
            onCanceled = function(cancel) {
                if (req.aborted) return;
                req.abort();
                reject(!cancel || cancel && cancel.type ? new Cancel("canceled") : cancel);
            };
            config.cancelToken && config.cancelToken.subscribe(onCanceled);
            if (config.signal) {
                config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
            }
        }
        // Send the request
        if (utils.isStream(data)) {
            data.on("error", function handleStreamError(err) {
                reject(enhanceError(err, config, null, req));
            }).pipe(req);
        } else {
            req.end(data);
        }
    });
};


/***/ }),

/***/ 89728:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var utils = __webpack_require__(78796);
var settle = __webpack_require__(94045);
var cookies = __webpack_require__(53115);
var buildURL = __webpack_require__(48248);
var buildFullPath = __webpack_require__(75697);
var parseHeaders = __webpack_require__(15331);
var isURLSameOrigin = __webpack_require__(84314);
var createError = __webpack_require__(80440);
var defaults = __webpack_require__(25261);
var Cancel = __webpack_require__(6700);
module.exports = function xhrAdapter(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
        var onCanceled;
        function done() {
            if (config.cancelToken) {
                config.cancelToken.unsubscribe(onCanceled);
            }
            if (config.signal) {
                config.signal.removeEventListener("abort", onCanceled);
            }
        }
        if (utils.isFormData(requestData)) {
            delete requestHeaders["Content-Type"]; // Let the browser set it
        }
        var request = new XMLHttpRequest();
        // HTTP basic authentication
        if (config.auth) {
            var username = config.auth.username || "";
            var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
            requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        // Set the request timeout in MS
        request.timeout = config.timeout;
        function onloadend() {
            if (!request) {
                return;
            }
            // Prepare the response
            var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
            var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
            var response = {
                data: responseData,
                status: request.status,
                statusText: request.statusText,
                headers: responseHeaders,
                config: config,
                request: request
            };
            settle(function _resolve(value) {
                resolve(value);
                done();
            }, function _reject(err) {
                reject(err);
                done();
            }, response);
            // Clean up request
            request = null;
        }
        if ("onloadend" in request) {
            // Use onloadend if available
            request.onloadend = onloadend;
        } else {
            // Listen for ready state to emulate onloadend
            request.onreadystatechange = function handleLoad() {
                if (!request || request.readyState !== 4) {
                    return;
                }
                // The request errored out and we didn't get a response, this will be
                // handled by onerror instead
                // With one exception: request that using file: protocol, most browsers
                // will return status as 0 even though it's a successful request
                if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
                    return;
                }
                // readystate handler is calling before onerror or ontimeout handlers,
                // so we should call onloadend on the next 'tick'
                setTimeout(onloadend);
            };
        }
        // Handle browser request cancellation (as opposed to a manual cancellation)
        request.onabort = function handleAbort() {
            if (!request) {
                return;
            }
            reject(createError("Request aborted", config, "ECONNABORTED", request));
            // Clean up request
            request = null;
        };
        // Handle low level network errors
        request.onerror = function handleError() {
            // Real errors are hidden from us by the browser
            // onerror should only fire if it's a network error
            reject(createError("Network Error", config, null, request));
            // Clean up request
            request = null;
        };
        // Handle timeout
        request.ontimeout = function handleTimeout() {
            var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
            var transitional = config.transitional || defaults.transitional;
            if (config.timeoutErrorMessage) {
                timeoutErrorMessage = config.timeoutErrorMessage;
            }
            reject(createError(timeoutErrorMessage, config, transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED", request));
            // Clean up request
            request = null;
        };
        // Add xsrf header
        // This is only done if running in a standard browser environment.
        // Specifically not if we're in a web worker, or react-native.
        if (utils.isStandardBrowserEnv()) {
            // Add xsrf header
            var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;
            if (xsrfValue) {
                requestHeaders[config.xsrfHeaderName] = xsrfValue;
            }
        }
        // Add headers to the request
        if ("setRequestHeader" in request) {
            utils.forEach(requestHeaders, function setRequestHeader(val, key) {
                if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
                    // Remove Content-Type if data is undefined
                    delete requestHeaders[key];
                } else {
                    // Otherwise add header to the request
                    request.setRequestHeader(key, val);
                }
            });
        }
        // Add withCredentials to request if needed
        if (!utils.isUndefined(config.withCredentials)) {
            request.withCredentials = !!config.withCredentials;
        }
        // Add responseType to request if needed
        if (responseType && responseType !== "json") {
            request.responseType = config.responseType;
        }
        // Handle progress if needed
        if (typeof config.onDownloadProgress === "function") {
            request.addEventListener("progress", config.onDownloadProgress);
        }
        // Not all browsers support upload events
        if (typeof config.onUploadProgress === "function" && request.upload) {
            request.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken || config.signal) {
            // Handle cancellation
            // eslint-disable-next-line func-names
            onCanceled = function(cancel) {
                if (!request) {
                    return;
                }
                reject(!cancel || cancel && cancel.type ? new Cancel("canceled") : cancel);
                request.abort();
                request = null;
            };
            config.cancelToken && config.cancelToken.subscribe(onCanceled);
            if (config.signal) {
                config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
            }
        }
        if (!requestData) {
            requestData = null;
        }
        // Send the request
        request.send(requestData);
    });
};


/***/ }),

/***/ 43204:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var utils = __webpack_require__(78796);
var bind = __webpack_require__(23237);
var Axios = __webpack_require__(28337);
var mergeConfig = __webpack_require__(6317);
var defaults = __webpack_require__(25261);
/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */ function createInstance(defaultConfig) {
    var context = new Axios(defaultConfig);
    var instance = bind(Axios.prototype.request, context);
    // Copy axios.prototype to instance
    utils.extend(instance, Axios.prototype, context);
    // Copy context to instance
    utils.extend(instance, context);
    // Factory for creating new instances
    instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
    };
    return instance;
}
// Create the default instance to be exported
var axios = createInstance(defaults);
// Expose Axios class to allow class inheritance
axios.Axios = Axios;
// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(6700);
axios.CancelToken = __webpack_require__(55297);
axios.isCancel = __webpack_require__(39662);
axios.VERSION = (__webpack_require__(24577).version);
// Expose all/spread
axios.all = function all(promises) {
    return Promise.all(promises);
};
axios.spread = __webpack_require__(75223);
// Expose isAxiosError
axios.isAxiosError = __webpack_require__(96731);
module.exports = axios;
// Allow use of default import syntax in TypeScript
module.exports["default"] = axios;


/***/ }),

/***/ 6700:
/***/ ((module) => {

"use strict";

/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */ function Cancel(message) {
    this.message = message;
}
Cancel.prototype.toString = function toString() {
    return "Cancel" + (this.message ? ": " + this.message : "");
};
Cancel.prototype.__CANCEL__ = true;
module.exports = Cancel;


/***/ }),

/***/ 55297:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Cancel = __webpack_require__(6700);
/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */ function CancelToken(executor) {
    if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
    }
    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
    });
    var token = this;
    // eslint-disable-next-line func-names
    this.promise.then(function(cancel) {
        if (!token._listeners) return;
        var i;
        var l = token._listeners.length;
        for(i = 0; i < l; i++){
            token._listeners[i](cancel);
        }
        token._listeners = null;
    });
    // eslint-disable-next-line func-names
    this.promise.then = function(onfulfilled) {
        var _resolve;
        // eslint-disable-next-line func-names
        var promise = new Promise(function(resolve) {
            token.subscribe(resolve);
            _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
            token.unsubscribe(_resolve);
        };
        return promise;
    };
    executor(function cancel(message) {
        if (token.reason) {
            // Cancellation has already been requested
            return;
        }
        token.reason = new Cancel(message);
        resolvePromise(token.reason);
    });
}
/**
 * Throws a `Cancel` if cancellation has been requested.
 */ CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
        throw this.reason;
    }
};
/**
 * Subscribe to the cancel signal
 */ CancelToken.prototype.subscribe = function subscribe(listener) {
    if (this.reason) {
        listener(this.reason);
        return;
    }
    if (this._listeners) {
        this._listeners.push(listener);
    } else {
        this._listeners = [
            listener
        ];
    }
};
/**
 * Unsubscribe from the cancel signal
 */ CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
    if (!this._listeners) {
        return;
    }
    var index = this._listeners.indexOf(listener);
    if (index !== -1) {
        this._listeners.splice(index, 1);
    }
};
/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */ CancelToken.source = function source() {
    var cancel;
    var token = new CancelToken(function executor(c) {
        cancel = c;
    });
    return {
        token: token,
        cancel: cancel
    };
};
module.exports = CancelToken;


/***/ }),

/***/ 39662:
/***/ ((module) => {

"use strict";

module.exports = function isCancel(value) {
    return !!(value && value.__CANCEL__);
};


/***/ }),

/***/ 28337:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var utils = __webpack_require__(78796);
var buildURL = __webpack_require__(48248);
var InterceptorManager = __webpack_require__(34745);
var dispatchRequest = __webpack_require__(52896);
var mergeConfig = __webpack_require__(6317);
var validator = __webpack_require__(16720);
var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */ function Axios(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
    };
}
/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */ Axios.prototype.request = function request(configOrUrl, config) {
    /*eslint no-param-reassign:0*/ // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
    } else {
        config = configOrUrl || {};
    }
    if (!config.url) {
        throw new Error("Provided config url is not valid");
    }
    config = mergeConfig(this.defaults, config);
    // Set config.method
    if (config.method) {
        config.method = config.method.toLowerCase();
    } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
    } else {
        config.method = "get";
    }
    var transitional = config.transitional;
    if (transitional !== undefined) {
        validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
    }
    // filter out skipped interceptors
    var requestInterceptorChain = [];
    var synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
            return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    var responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    var promise;
    if (!synchronousRequestInterceptors) {
        var chain = [
            dispatchRequest,
            undefined
        ];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config);
        while(chain.length){
            promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
    }
    var newConfig = config;
    while(requestInterceptorChain.length){
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
            newConfig = onFulfilled(newConfig);
        } catch (error) {
            onRejected(error);
            break;
        }
    }
    try {
        promise = dispatchRequest(newConfig);
    } catch (error1) {
        return Promise.reject(error1);
    }
    while(responseInterceptorChain.length){
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
    }
    return promise;
};
Axios.prototype.getUri = function getUri(config) {
    if (!config.url) {
        throw new Error("Provided config url is not valid");
    }
    config = mergeConfig(this.defaults, config);
    return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
};
// Provide aliases for supported request methods
utils.forEach([
    "delete",
    "get",
    "head",
    "options"
], function forEachMethodNoData(method) {
    /*eslint func-names:0*/ Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
            method: method,
            url: url,
            data: (config || {}).data
        }));
    };
});
utils.forEach([
    "post",
    "put",
    "patch"
], function forEachMethodWithData(method) {
    /*eslint func-names:0*/ Axios.prototype[method] = function(url, data, config) {
        return this.request(mergeConfig(config || {}, {
            method: method,
            url: url,
            data: data
        }));
    };
});
module.exports = Axios;


/***/ }),

/***/ 34745:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var utils = __webpack_require__(78796);
function InterceptorManager() {
    this.handlers = [];
}
/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */ InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
    this.handlers.push({
        fulfilled: fulfilled,
        rejected: rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
};
/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */ InterceptorManager.prototype.eject = function eject(id) {
    if (this.handlers[id]) {
        this.handlers[id] = null;
    }
};
/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */ InterceptorManager.prototype.forEach = function forEach(fn) {
    utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
            fn(h);
        }
    });
};
module.exports = InterceptorManager;


/***/ }),

/***/ 75697:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isAbsoluteURL = __webpack_require__(19839);
var combineURLs = __webpack_require__(94314);
/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */ module.exports = function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
};


/***/ }),

/***/ 80440:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var enhanceError = __webpack_require__(25058);
/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */ module.exports = function createError(message, config, code, request, response) {
    var error = new Error(message);
    return enhanceError(error, config, code, request, response);
};


/***/ }),

/***/ 52896:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var utils = __webpack_require__(78796);
var transformData = __webpack_require__(49148);
var isCancel = __webpack_require__(39662);
var defaults = __webpack_require__(25261);
var Cancel = __webpack_require__(6700);
/**
 * Throws a `Cancel` if cancellation has been requested.
 */ function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
    }
    if (config.signal && config.signal.aborted) {
        throw new Cancel("canceled");
    }
}
/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */ module.exports = function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    // Ensure headers exist
    config.headers = config.headers || {};
    // Transform request data
    config.data = transformData.call(config, config.data, config.headers, config.transformRequest);
    // Flatten headers
    config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
    utils.forEach([
        "delete",
        "get",
        "head",
        "post",
        "put",
        "patch",
        "common"
    ], function cleanHeaderConfig(method) {
        delete config.headers[method];
    });
    var adapter = config.adapter || defaults.adapter;
    return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        // Transform response data
        response.data = transformData.call(config, response.data, response.headers, config.transformResponse);
        return response;
    }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
            throwIfCancellationRequested(config);
            // Transform response data
            if (reason && reason.response) {
                reason.response.data = transformData.call(config, reason.response.data, reason.response.headers, config.transformResponse);
            }
        }
        return Promise.reject(reason);
    });
};


/***/ }),

/***/ 25058:
/***/ ((module) => {

"use strict";

/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */ module.exports = function enhanceError(error, config, code, request, response) {
    error.config = config;
    if (code) {
        error.code = code;
    }
    error.request = request;
    error.response = response;
    error.isAxiosError = true;
    error.toJSON = function toJSON() {
        return {
            // Standard
            message: this.message,
            name: this.name,
            // Microsoft
            description: this.description,
            number: this.number,
            // Mozilla
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            // Axios
            config: this.config,
            code: this.code,
            status: this.response && this.response.status ? this.response.status : null
        };
    };
    return error;
};


/***/ }),

/***/ 6317:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var utils = __webpack_require__(78796);
/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */ module.exports = function mergeConfig(config1, config2) {
    // eslint-disable-next-line no-param-reassign
    config2 = config2 || {};
    var config = {};
    function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
            return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
            return utils.merge({}, source);
        } else if (utils.isArray(source)) {
            return source.slice();
        }
        return source;
    }
    // eslint-disable-next-line consistent-return
    function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
            return getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
            return getMergedValue(undefined, config1[prop]);
        }
    }
    // eslint-disable-next-line consistent-return
    function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
            return getMergedValue(undefined, config2[prop]);
        }
    }
    // eslint-disable-next-line consistent-return
    function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
            return getMergedValue(undefined, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
            return getMergedValue(undefined, config1[prop]);
        }
    }
    // eslint-disable-next-line consistent-return
    function mergeDirectKeys(prop) {
        if (prop in config2) {
            return getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
            return getMergedValue(undefined, config1[prop]);
        }
    }
    var mergeMap = {
        "url": valueFromConfig2,
        "method": valueFromConfig2,
        "data": valueFromConfig2,
        "baseURL": defaultToConfig2,
        "transformRequest": defaultToConfig2,
        "transformResponse": defaultToConfig2,
        "paramsSerializer": defaultToConfig2,
        "timeout": defaultToConfig2,
        "timeoutMessage": defaultToConfig2,
        "withCredentials": defaultToConfig2,
        "adapter": defaultToConfig2,
        "responseType": defaultToConfig2,
        "xsrfCookieName": defaultToConfig2,
        "xsrfHeaderName": defaultToConfig2,
        "onUploadProgress": defaultToConfig2,
        "onDownloadProgress": defaultToConfig2,
        "decompress": defaultToConfig2,
        "maxContentLength": defaultToConfig2,
        "maxBodyLength": defaultToConfig2,
        "transport": defaultToConfig2,
        "httpAgent": defaultToConfig2,
        "httpsAgent": defaultToConfig2,
        "cancelToken": defaultToConfig2,
        "socketPath": defaultToConfig2,
        "responseEncoding": defaultToConfig2,
        "validateStatus": mergeDirectKeys
    };
    utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        var merge = mergeMap[prop] || mergeDeepProperties;
        var configValue = merge(prop);
        utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
    });
    return config;
};


/***/ }),

/***/ 94045:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var createError = __webpack_require__(80440);
/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */ module.exports = function settle(resolve, reject, response) {
    var validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
    } else {
        reject(createError("Request failed with status code " + response.status, response.config, null, response.request, response));
    }
};


/***/ }),

/***/ 49148:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var utils = __webpack_require__(78796);
var defaults = __webpack_require__(25261);
/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */ module.exports = function transformData(data, headers, fns) {
    var context = this || defaults;
    /*eslint no-param-reassign:0*/ utils.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers);
    });
    return data;
};


/***/ }),

/***/ 25261:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var utils = __webpack_require__(78796);
var normalizeHeaderName = __webpack_require__(71373);
var enhanceError = __webpack_require__(25058);
var DEFAULT_CONTENT_TYPE = {
    "Content-Type": "application/x-www-form-urlencoded"
};
function setContentTypeIfUnset(headers, value) {
    if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
    }
}
function getDefaultAdapter() {
    var adapter;
    if (typeof XMLHttpRequest !== "undefined") {
        // For browsers use XHR adapter
        adapter = __webpack_require__(89728);
    } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        // For node use HTTP adapter
        adapter = __webpack_require__(60212);
    }
    return adapter;
}
function stringifySafely(rawValue, parser, encoder) {
    if (utils.isString(rawValue)) {
        try {
            (parser || JSON.parse)(rawValue);
            return utils.trim(rawValue);
        } catch (e) {
            if (e.name !== "SyntaxError") {
                throw e;
            }
        }
    }
    return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
    transitional: {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
    },
    adapter: getDefaultAdapter(),
    transformRequest: [
        function transformRequest(data, headers) {
            normalizeHeaderName(headers, "Accept");
            normalizeHeaderName(headers, "Content-Type");
            if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
                return data;
            }
            if (utils.isArrayBufferView(data)) {
                return data.buffer;
            }
            if (utils.isURLSearchParams(data)) {
                setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
                return data.toString();
            }
            if (utils.isObject(data) || headers && headers["Content-Type"] === "application/json") {
                setContentTypeIfUnset(headers, "application/json");
                return stringifySafely(data);
            }
            return data;
        }
    ],
    transformResponse: [
        function transformResponse(data) {
            var transitional = this.transitional || defaults.transitional;
            var silentJSONParsing = transitional && transitional.silentJSONParsing;
            var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
            var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
            if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
                try {
                    return JSON.parse(data);
                } catch (e) {
                    if (strictJSONParsing) {
                        if (e.name === "SyntaxError") {
                            throw enhanceError(e, this, "E_JSON_PARSE");
                        }
                        throw e;
                    }
                }
            }
            return data;
        }
    ],
    /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */ timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
    },
    headers: {
        common: {
            "Accept": "application/json, text/plain, */*"
        }
    }
};
utils.forEach([
    "delete",
    "get",
    "head"
], function forEachMethodNoData(method) {
    defaults.headers[method] = {};
});
utils.forEach([
    "post",
    "put",
    "patch"
], function forEachMethodWithData(method) {
    defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});
module.exports = defaults;


/***/ }),

/***/ 24577:
/***/ ((module) => {

"use strict";

module.exports = {
    "version": "0.25.0"
};


/***/ }),

/***/ 23237:
/***/ ((module) => {

"use strict";

module.exports = function bind(fn, thisArg) {
    return function wrap() {
        var args = new Array(arguments.length);
        for(var i = 0; i < args.length; i++){
            args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
    };
};


/***/ }),

/***/ 48248:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var utils = __webpack_require__(78796);
function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */ module.exports = function buildURL(url, params, paramsSerializer) {
    /*eslint no-param-reassign:0*/ if (!params) {
        return url;
    }
    var serializedParams;
    if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
    } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
    } else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
            if (val === null || typeof val === "undefined") {
                return;
            }
            if (utils.isArray(val)) {
                key = key + "[]";
            } else {
                val = [
                    val
                ];
            }
            utils.forEach(val, function parseValue(v) {
                if (utils.isDate(v)) {
                    v = v.toISOString();
                } else if (utils.isObject(v)) {
                    v = JSON.stringify(v);
                }
                parts.push(encode(key) + "=" + encode(v));
            });
        });
        serializedParams = parts.join("&");
    }
    if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
            url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
};


/***/ }),

/***/ 94314:
/***/ ((module) => {

"use strict";

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */ module.exports = function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
};


/***/ }),

/***/ 53115:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var utils = __webpack_require__(78796);
module.exports = utils.isStandardBrowserEnv() ? // Standard browser envs support document.cookie
function standardBrowserEnv() {
    return {
        write: function write(name, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + "=" + encodeURIComponent(value));
            if (utils.isNumber(expires)) {
                cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils.isString(path)) {
                cookie.push("path=" + path);
            }
            if (utils.isString(domain)) {
                cookie.push("domain=" + domain);
            }
            if (secure === true) {
                cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
        },
        read: function read(name) {
            var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
        },
        remove: function remove(name) {
            this.write(name, "", Date.now() - 86400000);
        }
    };
}() : // Non standard browser env (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
    return {
        write: function write() {},
        read: function read() {
            return null;
        },
        remove: function remove() {}
    };
}();


/***/ }),

/***/ 19839:
/***/ ((module) => {

"use strict";

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */ module.exports = function isAbsoluteURL(url) {
    // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
    // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
    // by any combination of letters, digits, plus, period, or hyphen.
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
};


/***/ }),

/***/ 96731:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var utils = __webpack_require__(78796);
/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */ module.exports = function isAxiosError(payload) {
    return utils.isObject(payload) && payload.isAxiosError === true;
};


/***/ }),

/***/ 84314:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var utils = __webpack_require__(78796);
module.exports = utils.isStandardBrowserEnv() ? // Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement("a");
    var originURL;
    /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */ function resolveURL(url) {
        var href = url;
        if (msie) {
            // IE needs attribute set twice to normalize properties
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
    }
    originURL = resolveURL(window.location.href);
    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */ return function isURLSameOrigin(requestURL) {
        var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
}() : // Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
        return true;
    };
}();


/***/ }),

/***/ 71373:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var utils = __webpack_require__(78796);
module.exports = function normalizeHeaderName(headers, normalizedName) {
    utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
            headers[normalizedName] = value;
            delete headers[name];
        }
    });
};


/***/ }),

/***/ 15331:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var utils = __webpack_require__(78796);
// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
];
/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */ module.exports = function parseHeaders(headers) {
    var parsed = {};
    var key;
    var val;
    var i;
    if (!headers) {
        return parsed;
    }
    utils.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
        if (key) {
            if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
                return;
            }
            if (key === "set-cookie") {
                parsed[key] = (parsed[key] ? parsed[key] : []).concat([
                    val
                ]);
            } else {
                parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
            }
        }
    });
    return parsed;
};


/***/ }),

/***/ 75223:
/***/ ((module) => {

"use strict";

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */ module.exports = function spread(callback) {
    return function wrap(arr) {
        return callback.apply(null, arr);
    };
};


/***/ }),

/***/ 16720:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var VERSION = (__webpack_require__(24577).version);
var validators = {};
// eslint-disable-next-line func-names
[
    "object",
    "boolean",
    "number",
    "function",
    "string",
    "symbol"
].forEach(function(type, i) {
    validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
    };
});
var deprecatedWarnings = {};
/**
 * Transitional option validator
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 * @returns {function}
 */ validators.transitional = function transitional(validator, version, message) {
    function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    // eslint-disable-next-line func-names
    return function(value, opt, opts) {
        if (validator === false) {
            throw new Error(formatMessage(opt, " has been removed" + (version ? " in " + version : "")));
        }
        if (version && !deprecatedWarnings[opt]) {
            deprecatedWarnings[opt] = true;
            // eslint-disable-next-line no-console
            console.warn(formatMessage(opt, " has been deprecated since v" + version + " and will be removed in the near future"));
        }
        return validator ? validator(value, opt, opts) : true;
    };
};
/**
 * Assert object's properties type
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 */ function assertOptions(options, schema, allowUnknown) {
    if (typeof options !== "object") {
        throw new TypeError("options must be an object");
    }
    var keys = Object.keys(options);
    var i = keys.length;
    while(i-- > 0){
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
            var value = options[opt];
            var result = value === undefined || validator(value, opt, options);
            if (result !== true) {
                throw new TypeError("option " + opt + " must be " + result);
            }
            continue;
        }
        if (allowUnknown !== true) {
            throw Error("Unknown option " + opt);
        }
    }
}
module.exports = {
    assertOptions: assertOptions,
    validators: validators
};


/***/ }),

/***/ 78796:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var bind = __webpack_require__(23237);
// utils is a library of generic helper functions non-specific to axios
var toString = Object.prototype.toString;
/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */ function isArray(val) {
    return Array.isArray(val);
}
/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */ function isUndefined(val) {
    return typeof val === "undefined";
}
/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */ function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
}
/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */ function isArrayBuffer(val) {
    return toString.call(val) === "[object ArrayBuffer]";
}
/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */ function isFormData(val) {
    return toString.call(val) === "[object FormData]";
}
/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */ function isArrayBufferView(val) {
    var result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
    } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
    }
    return result;
}
/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */ function isString(val) {
    return typeof val === "string";
}
/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */ function isNumber(val) {
    return typeof val === "number";
}
/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */ function isObject(val) {
    return val !== null && typeof val === "object";
}
/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */ function isPlainObject(val) {
    if (toString.call(val) !== "[object Object]") {
        return false;
    }
    var prototype = Object.getPrototypeOf(val);
    return prototype === null || prototype === Object.prototype;
}
/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */ function isDate(val) {
    return toString.call(val) === "[object Date]";
}
/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */ function isFile(val) {
    return toString.call(val) === "[object File]";
}
/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */ function isBlob(val) {
    return toString.call(val) === "[object Blob]";
}
/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */ function isFunction(val) {
    return toString.call(val) === "[object Function]";
}
/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */ function isStream(val) {
    return isObject(val) && isFunction(val.pipe);
}
/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */ function isURLSearchParams(val) {
    return toString.call(val) === "[object URLSearchParams]";
}
/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */ function trim(str) {
    return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
}
/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */ function isStandardBrowserEnv() {
    if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
    }
    return  false && 0;
}
/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */ function forEach(obj, fn) {
    // Don't bother if no value provided
    if (obj === null || typeof obj === "undefined") {
        return;
    }
    // Force an array if not already something iterable
    if (typeof obj !== "object") {
        /*eslint no-param-reassign:0*/ obj = [
            obj
        ];
    }
    if (isArray(obj)) {
        // Iterate over array values
        for(var i = 0, l = obj.length; i < l; i++){
            fn.call(null, obj[i], i, obj);
        }
    } else {
        // Iterate over object keys
        for(var key in obj){
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                fn.call(null, obj[key], key, obj);
            }
        }
    }
}
/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */ function merge() {
    var result = {};
    function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
            result[key] = merge(result[key], val);
        } else if (isPlainObject(val)) {
            result[key] = merge({}, val);
        } else if (isArray(val)) {
            result[key] = val.slice();
        } else {
            result[key] = val;
        }
    }
    for(var i = 0, l = arguments.length; i < l; i++){
        forEach(arguments[i], assignValue);
    }
    return result;
}
/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */ function extend(a, b, thisArg) {
    forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
            a[key] = bind(val, thisArg);
        } else {
            a[key] = val;
        }
    });
    return a;
}
/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */ function stripBOM(content) {
    if (content.charCodeAt(0) === 0xFEFF) {
        content = content.slice(1);
    }
    return content;
}
module.exports = {
    isArray: isArray,
    isArrayBuffer: isArrayBuffer,
    isBuffer: isBuffer,
    isFormData: isFormData,
    isArrayBufferView: isArrayBufferView,
    isString: isString,
    isNumber: isNumber,
    isObject: isObject,
    isPlainObject: isPlainObject,
    isUndefined: isUndefined,
    isDate: isDate,
    isFile: isFile,
    isBlob: isBlob,
    isFunction: isFunction,
    isStream: isStream,
    isURLSearchParams: isURLSearchParams,
    isStandardBrowserEnv: isStandardBrowserEnv,
    forEach: forEach,
    merge: merge,
    extend: extend,
    trim: trim,
    stripBOM: stripBOM
};


/***/ }),

/***/ 3519:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ 
/**
 * Module exports.
 * @public
 */ exports.parse = parse;
exports.serialize = serialize;
/**
 * Module variables.
 * @private
 */ var __toString = Object.prototype.toString;
/**
 * RegExp to match field-content in RFC 7230 sec 3.2
 *
 * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]
 * field-vchar   = VCHAR / obs-text
 * obs-text      = %x80-FF
 */ var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
/**
 * Parse a cookie header.
 *
 * Parse the given cookie header string into an object
 * The object has the various cookies as keys(names) => values
 *
 * @param {string} str
 * @param {object} [options]
 * @return {object}
 * @public
 */ function parse(str, options) {
    if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
    }
    var obj = {};
    var opt = options || {};
    var dec = opt.decode || decode;
    var index = 0;
    while(index < str.length){
        var eqIdx = str.indexOf("=", index);
        // no more cookie pairs
        if (eqIdx === -1) {
            break;
        }
        var endIdx = str.indexOf(";", index);
        if (endIdx === -1) {
            endIdx = str.length;
        } else if (endIdx < eqIdx) {
            // backtrack on prior semicolon
            index = str.lastIndexOf(";", eqIdx - 1) + 1;
            continue;
        }
        var key = str.slice(index, eqIdx).trim();
        // only assign once
        if (undefined === obj[key]) {
            var val = str.slice(eqIdx + 1, endIdx).trim();
            // quoted values
            if (val.charCodeAt(0) === 0x22) {
                val = val.slice(1, -1);
            }
            obj[key] = tryDecode(val, dec);
        }
        index = endIdx + 1;
    }
    return obj;
}
/**
 * Serialize data into a cookie header.
 *
 * Serialize the a name value pair into a cookie string suitable for
 * http headers. An optional options object specified cookie parameters.
 *
 * serialize('foo', 'bar', { httpOnly: true })
 *   => "foo=bar; httpOnly"
 *
 * @param {string} name
 * @param {string} val
 * @param {object} [options]
 * @return {string}
 * @public
 */ function serialize(name, val, options) {
    var opt = options || {};
    var enc = opt.encode || encode;
    if (typeof enc !== "function") {
        throw new TypeError("option encode is invalid");
    }
    if (!fieldContentRegExp.test(name)) {
        throw new TypeError("argument name is invalid");
    }
    var value = enc(val);
    if (value && !fieldContentRegExp.test(value)) {
        throw new TypeError("argument val is invalid");
    }
    var str = name + "=" + value;
    if (null != opt.maxAge) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge) || !isFinite(maxAge)) {
            throw new TypeError("option maxAge is invalid");
        }
        str += "; Max-Age=" + Math.floor(maxAge);
    }
    if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain)) {
            throw new TypeError("option domain is invalid");
        }
        str += "; Domain=" + opt.domain;
    }
    if (opt.path) {
        if (!fieldContentRegExp.test(opt.path)) {
            throw new TypeError("option path is invalid");
        }
        str += "; Path=" + opt.path;
    }
    if (opt.expires) {
        var expires = opt.expires;
        if (!isDate(expires) || isNaN(expires.valueOf())) {
            throw new TypeError("option expires is invalid");
        }
        str += "; Expires=" + expires.toUTCString();
    }
    if (opt.httpOnly) {
        str += "; HttpOnly";
    }
    if (opt.secure) {
        str += "; Secure";
    }
    if (opt.priority) {
        var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
        switch(priority){
            case "low":
                str += "; Priority=Low";
                break;
            case "medium":
                str += "; Priority=Medium";
                break;
            case "high":
                str += "; Priority=High";
                break;
            default:
                throw new TypeError("option priority is invalid");
        }
    }
    if (opt.sameSite) {
        var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch(sameSite){
            case true:
                str += "; SameSite=Strict";
                break;
            case "lax":
                str += "; SameSite=Lax";
                break;
            case "strict":
                str += "; SameSite=Strict";
                break;
            case "none":
                str += "; SameSite=None";
                break;
            default:
                throw new TypeError("option sameSite is invalid");
        }
    }
    return str;
}
/**
 * URL-decode string value. Optimized to skip native call when no %.
 *
 * @param {string} str
 * @returns {string}
 */ function decode(str) {
    return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
}
/**
 * URL-encode value.
 *
 * @param {string} str
 * @returns {string}
 */ function encode(val) {
    return encodeURIComponent(val);
}
/**
 * Determine if value is a Date.
 *
 * @param {*} val
 * @private
 */ function isDate(val) {
    return __toString.call(val) === "[object Date]" || val instanceof Date;
}
/**
 * Try decoding a string using a decoding function.
 *
 * @param {string} str
 * @param {function} decode
 * @private
 */ function tryDecode(str, decode) {
    try {
        return decode(str);
    } catch (e) {
        return str;
    }
}


/***/ }),

/***/ 3301:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/* eslint-env browser */ /**
 * This is the web browser implementation of `debug()`.
 */ 
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (()=>{
    let warned = false;
    return ()=>{
        if (!warned) {
            warned = true;
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
    };
})();
/**
 * Colors.
 */ exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */ // eslint-disable-next-line complexity
function useColors() {
    // NB: In an Electron preload script, document will be defined but not fully
    // initialized. Since we know we're in Chrome, we'll just detect this case
    // explicitly
    if (false) {}
    // Internet Explorer and Edge do not support colors.
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
    }
    // Is webkit? http://stackoverflow.com/a/16459606/376773
    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
     false && (0) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */ function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
        return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    // The final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match)=>{
        if (match === "%%") {
            return;
        }
        index++;
        if (match === "%c") {
            // We only are interested in the *last* %c
            // (the user may have provided their own)
            lastC = index;
        }
    });
    args.splice(lastC, 0, c);
}
/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */ exports.log = console.debug || console.log || (()=>{});
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */ function save(namespaces) {
    try {
        if (namespaces) {
            exports.storage.setItem("debug", namespaces);
        } else {
            exports.storage.removeItem("debug");
        }
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */ function load() {
    let r;
    try {
        r = exports.storage.getItem("debug");
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
    if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
    }
    return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */ function localstorage() {
    try {
        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
        // The Browser also has localStorage in the global context.
        return localStorage;
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
module.exports = __webpack_require__(81943)(exports);
const { formatters  } = module.exports;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */ formatters.j = function(v) {
    try {
        return JSON.stringify(v);
    } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
    }
};


/***/ }),

/***/ 81943:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */ 
function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = __webpack_require__(46990);
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key)=>{
        createDebug[key] = env[key];
    });
    /**
	* The currently active debug mode names, and names to skip.
	*/ createDebug.names = [];
    createDebug.skips = [];
    /**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/ createDebug.formatters = {};
    /**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/ function selectColor(namespace) {
        let hash = 0;
        for(let i = 0; i < namespace.length; i++){
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0; // Convert to 32bit integer
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    /**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/ function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
            // Disabled?
            if (!debug.enabled) {
                return;
            }
            const self = debug;
            // Set `diff` timestamp
            const curr = Number(new Date());
            const ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") {
                // Anything else let's inspect with %O
                args.unshift("%O");
            }
            // Apply any `formatters` transformations
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{
                // If we encounter an escaped % then don't increase the array index
                if (match === "%%") {
                    return "%";
                }
                index++;
                const formatter = createDebug.formatters[format];
                if (typeof formatter === "function") {
                    const val = args[index];
                    match = formatter.call(self, val);
                    // Now we need to remove `args[index]` since it's inlined in the `format`
                    args.splice(index, 1);
                    index--;
                }
                return match;
            });
            // Apply env-specific formatting (colors, etc.)
            createDebug.formatArgs.call(self, args);
            const logFn = self.log || createDebug.log;
            logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.
        Object.defineProperty(debug, "enabled", {
            enumerable: true,
            configurable: false,
            get: ()=>{
                if (enableOverride !== null) {
                    return enableOverride;
                }
                if (namespacesCache !== createDebug.namespaces) {
                    namespacesCache = createDebug.namespaces;
                    enabledCache = createDebug.enabled(namespace);
                }
                return enabledCache;
            },
            set: (v)=>{
                enableOverride = v;
            }
        });
        // Env-specific initialization logic for debug instances
        if (typeof createDebug.init === "function") {
            createDebug.init(debug);
        }
        return debug;
    }
    function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
    }
    /**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/ function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for(i = 0; i < len; i++){
            if (!split[i]) {
                continue;
            }
            namespaces = split[i].replace(/\*/g, ".*?");
            if (namespaces[0] === "-") {
                createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
            } else {
                createDebug.names.push(new RegExp("^" + namespaces + "$"));
            }
        }
    }
    /**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/ function disable() {
        const namespaces = [
            ...createDebug.names.map(toNamespace),
            ...createDebug.skips.map(toNamespace).map((namespace)=>"-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
    }
    /**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/ function enabled(name) {
        if (name[name.length - 1] === "*") {
            return true;
        }
        let i;
        let len;
        for(i = 0, len = createDebug.skips.length; i < len; i++){
            if (createDebug.skips[i].test(name)) {
                return false;
            }
        }
        for(i = 0, len = createDebug.names.length; i < len; i++){
            if (createDebug.names[i].test(name)) {
                return true;
            }
        }
        return false;
    }
    /**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/ function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    /**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/ function coerce(val) {
        if (val instanceof Error) {
            return val.stack || val.message;
        }
        return val;
    }
    /**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/ function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
}
module.exports = setup;


/***/ }),

/***/ 56307:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */ 
if (typeof process === "undefined" || process.type === "renderer" || false === true || process.__nwjs) {
    module.exports = __webpack_require__(3301);
} else {
    module.exports = __webpack_require__(33926);
}


/***/ }),

/***/ 33926:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Module dependencies.
 */ 
const tty = __webpack_require__(76224);
const util = __webpack_require__(73837);
/**
 * This is the Node.js implementation of `debug()`.
 */ exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(()=>{}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
/**
 * Colors.
 */ exports.colors = [
    6,
    2,
    3,
    4,
    5,
    1
];
try {
    // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
    // eslint-disable-next-line import/no-extraneous-dependencies
    const supportsColor = __webpack_require__(46470);
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
            20,
            21,
            26,
            27,
            32,
            33,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            56,
            57,
            62,
            63,
            68,
            69,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            92,
            93,
            98,
            99,
            112,
            113,
            128,
            129,
            134,
            135,
            148,
            149,
            160,
            161,
            162,
            163,
            164,
            165,
            166,
            167,
            168,
            169,
            170,
            171,
            172,
            173,
            178,
            179,
            184,
            185,
            196,
            197,
            198,
            199,
            200,
            201,
            202,
            203,
            204,
            205,
            206,
            207,
            208,
            209,
            214,
            215,
            220,
            221
        ];
    }
} catch (error) {
// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}
/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */ exports.inspectOpts = Object.keys(process.env).filter((key)=>{
    return /^debug_/i.test(key);
}).reduce((obj, key)=>{
    // Camel-case
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k)=>{
        return k.toUpperCase();
    });
    // Coerce string value into JS value
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
    } else if (val === "null") {
        val = null;
    } else {
        val = Number(val);
    }
    obj[prop] = val;
    return obj;
}, {});
/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */ function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
}
/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */ function formatArgs(args) {
    const { namespace: name , useColors  } = this;
    if (useColors) {
        const c = this.color;
        const colorCode = "\x1b[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \u001B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1b[0m");
    } else {
        args[0] = getDate() + name + " " + args[0];
    }
}
function getDate() {
    if (exports.inspectOpts.hideDate) {
        return "";
    }
    return new Date().toISOString() + " ";
}
/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */ function log(...args) {
    return process.stderr.write(util.format(...args) + "\n");
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */ function save(namespaces) {
    if (namespaces) {
        process.env.DEBUG = namespaces;
    } else {
        // If you set a process.env field to null or undefined, it gets cast to the
        // string 'null' or 'undefined'. Just delete instead.
        delete process.env.DEBUG;
    }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */ function load() {
    return process.env.DEBUG;
}
/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */ function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for(let i = 0; i < keys.length; i++){
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
}
module.exports = __webpack_require__(81943)(exports);
const { formatters  } = module.exports;
/**
 * Map %o to `util.inspect()`, all on a single line.
 */ formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split("\n").map((str)=>str.trim()).join(" ");
};
/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */ formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
};


/***/ }),

/***/ 58112:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var debug;
module.exports = function() {
    if (!debug) {
        try {
            /* eslint global-require: off */ debug = __webpack_require__(56307)("follow-redirects");
        } catch (error) {}
        if (typeof debug !== "function") {
            debug = function() {};
        }
    }
    debug.apply(null, arguments);
};


/***/ }),

/***/ 45933:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var url = __webpack_require__(57310);
var URL = url.URL;
var http = __webpack_require__(13685);
var https = __webpack_require__(95687);
var Writable = (__webpack_require__(12781).Writable);
var assert = __webpack_require__(39491);
var debug = __webpack_require__(58112);
// Create handlers that pass events from native requests
var events = [
    "abort",
    "aborted",
    "connect",
    "error",
    "socket",
    "timeout"
];
var eventHandlers = Object.create(null);
events.forEach(function(event) {
    eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
    };
});
var InvalidUrlError = createErrorType("ERR_INVALID_URL", "Invalid URL", TypeError);
// Error types with codes
var RedirectionError = createErrorType("ERR_FR_REDIRECTION_FAILURE", "Redirected request failed");
var TooManyRedirectsError = createErrorType("ERR_FR_TOO_MANY_REDIRECTS", "Maximum number of redirects exceeded");
var MaxBodyLengthExceededError = createErrorType("ERR_FR_MAX_BODY_LENGTH_EXCEEDED", "Request body larger than maxBodyLength limit");
var WriteAfterEndError = createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
// An HTTP(S) request that can be redirected
function RedirectableRequest(options, responseCallback) {
    // Initialize the request
    Writable.call(this);
    this._sanitizeOptions(options);
    this._options = options;
    this._ended = false;
    this._ending = false;
    this._redirectCount = 0;
    this._redirects = [];
    this._requestBodyLength = 0;
    this._requestBodyBuffers = [];
    // Attach a callback if passed
    if (responseCallback) {
        this.on("response", responseCallback);
    }
    // React to responses of native requests
    var self = this;
    this._onNativeResponse = function(response) {
        self._processResponse(response);
    };
    // Perform the first request
    this._performRequest();
}
RedirectableRequest.prototype = Object.create(Writable.prototype);
RedirectableRequest.prototype.abort = function() {
    abortRequest(this._currentRequest);
    this.emit("abort");
};
// Writes buffered data to the current native request
RedirectableRequest.prototype.write = function(data, encoding, callback) {
    // Writing is not allowed if end has been called
    if (this._ending) {
        throw new WriteAfterEndError();
    }
    // Validate input and shift parameters if necessary
    if (!isString(data) && !isBuffer(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
    }
    if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
    }
    // Ignore empty buffers, since writing them doesn't invoke the callback
    // https://github.com/nodejs/node/issues/22066
    if (data.length === 0) {
        if (callback) {
            callback();
        }
        return;
    }
    // Only write when we don't exceed the maximum body length
    if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({
            data: data,
            encoding: encoding
        });
        this._currentRequest.write(data, encoding, callback);
    } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
    }
};
// Ends the current native request
RedirectableRequest.prototype.end = function(data, encoding, callback) {
    // Shift parameters if necessary
    if (isFunction(data)) {
        callback = data;
        data = encoding = null;
    } else if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
    }
    // Write data if needed and end
    if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
    } else {
        var self = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
            self._ended = true;
            currentRequest.end(null, null, callback);
        });
        this._ending = true;
    }
};
// Sets a header value on the current native request
RedirectableRequest.prototype.setHeader = function(name, value) {
    this._options.headers[name] = value;
    this._currentRequest.setHeader(name, value);
};
// Clears a header value on the current native request
RedirectableRequest.prototype.removeHeader = function(name) {
    delete this._options.headers[name];
    this._currentRequest.removeHeader(name);
};
// Global timeout for all underlying requests
RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
    var self = this;
    // Destroys the socket on timeout
    function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
    }
    // Sets up a timer to trigger a timeout event
    function startTimer(socket) {
        if (self._timeout) {
            clearTimeout(self._timeout);
        }
        self._timeout = setTimeout(function() {
            self.emit("timeout");
            clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
    }
    // Stops a timeout from triggering
    function clearTimer() {
        // Clear the timeout
        if (self._timeout) {
            clearTimeout(self._timeout);
            self._timeout = null;
        }
        // Clean up all attached listeners
        self.removeListener("abort", clearTimer);
        self.removeListener("error", clearTimer);
        self.removeListener("response", clearTimer);
        if (callback) {
            self.removeListener("timeout", callback);
        }
        if (!self.socket) {
            self._currentRequest.removeListener("socket", startTimer);
        }
    }
    // Attach callback if passed
    if (callback) {
        this.on("timeout", callback);
    }
    // Start the timer if or when the socket is opened
    if (this.socket) {
        startTimer(this.socket);
    } else {
        this._currentRequest.once("socket", startTimer);
    }
    // Clean up on events
    this.on("socket", destroyOnTimeout);
    this.on("abort", clearTimer);
    this.on("error", clearTimer);
    this.on("response", clearTimer);
    return this;
};
// Proxy all other public ClientRequest methods
[
    "flushHeaders",
    "getHeader",
    "setNoDelay",
    "setSocketKeepAlive"
].forEach(function(method) {
    RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
    };
});
// Proxy all public ClientRequest properties
[
    "aborted",
    "connection",
    "socket"
].forEach(function(property) {
    Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
            return this._currentRequest[property];
        }
    });
});
RedirectableRequest.prototype._sanitizeOptions = function(options) {
    // Ensure headers are always present
    if (!options.headers) {
        options.headers = {};
    }
    // Since http.request treats host as an alias of hostname,
    // but the url module interprets host as hostname plus port,
    // eliminate the host property to avoid confusion.
    if (options.host) {
        // Use hostname if set, because it has precedence
        if (!options.hostname) {
            options.hostname = options.host;
        }
        delete options.host;
    }
    // Complete the URL object when necessary
    if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
            options.pathname = options.path;
        } else {
            options.pathname = options.path.substring(0, searchPos);
            options.search = options.path.substring(searchPos);
        }
    }
};
// Executes the next native request (initial or redirect)
RedirectableRequest.prototype._performRequest = function() {
    // Load the native protocol
    var protocol = this._options.protocol;
    var nativeProtocol = this._options.nativeProtocols[protocol];
    if (!nativeProtocol) {
        this.emit("error", new TypeError("Unsupported protocol " + protocol));
        return;
    }
    // If specified, use the agent corresponding to the protocol
    // (HTTP and HTTPS use different types of agents)
    if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
    }
    // Create the native request and set up its event handlers
    var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
    request._redirectable = this;
    for (var event of events){
        request.on(event, eventHandlers[event]);
    }
    // RFC7230§5.3.1: When making a request directly to an origin server, […]
    // a client MUST send only the absolute path […] as the request-target.
    this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : // When making a request to a proxy, […]
    // a client MUST send the target URI in absolute-form […].
    this._options.path;
    // End a redirected request
    // (The first request must be ended explicitly with RedirectableRequest#end)
    if (this._isRedirect) {
        // Write the request entity and end
        var i = 0;
        var self = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
            // Only write if this request has not been redirected yet
            /* istanbul ignore else */ if (request === self._currentRequest) {
                // Report any write errors
                /* istanbul ignore if */ if (error) {
                    self.emit("error", error);
                } else if (i < buffers.length) {
                    var buffer = buffers[i++];
                    /* istanbul ignore else */ if (!request.finished) {
                        request.write(buffer.data, buffer.encoding, writeNext);
                    }
                } else if (self._ended) {
                    request.end();
                }
            }
        })();
    }
};
// Processes a response from the current native request
RedirectableRequest.prototype._processResponse = function(response) {
    // Store the redirected response
    var statusCode = response.statusCode;
    if (this._options.trackRedirects) {
        this._redirects.push({
            url: this._currentUrl,
            headers: response.headers,
            statusCode: statusCode
        });
    }
    // RFC7231§6.4: The 3xx (Redirection) class of status code indicates
    // that further action needs to be taken by the user agent in order to
    // fulfill the request. If a Location header field is provided,
    // the user agent MAY automatically redirect its request to the URI
    // referenced by the Location field value,
    // even if the specific status code is not understood.
    // If the response is not a redirect; return it as-is
    var location = response.headers.location;
    if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        // Clean up
        this._requestBodyBuffers = [];
        return;
    }
    // The response is a redirect, so abort the current request
    abortRequest(this._currentRequest);
    // Discard the remainder of the response to avoid waiting for data
    response.destroy();
    // RFC7231§6.4: A client SHOULD detect and intervene
    // in cyclical redirections (i.e., "infinite" redirection loops).
    if (++this._redirectCount > this._options.maxRedirects) {
        this.emit("error", new TooManyRedirectsError());
        return;
    }
    // Store the request headers if applicable
    var requestHeaders;
    var beforeRedirect = this._options.beforeRedirect;
    if (beforeRedirect) {
        requestHeaders = Object.assign({
            // The Host header was set by nativeProtocol.request
            Host: response.req.getHeader("host")
        }, this._options.headers);
    }
    // RFC7231§6.4: Automatic redirection needs to done with
    // care for methods not known to be safe, […]
    // RFC7231§6.4.2–3: For historical reasons, a user agent MAY change
    // the request method from POST to GET for the subsequent request.
    var method = this._options.method;
    if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC7231§6.4.4: The 303 (See Other) status code indicates that
    // the server is redirecting the user agent to a different resource […]
    // A user agent can perform a retrieval request targeting that URI
    // (a GET or HEAD request if using HTTP) […]
    statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        // Drop a possible entity and headers related to it
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
    }
    // Drop the Host header, as the redirect might lead to a different host
    var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
    // If the redirect is relative, carry over the host of the last request
    var currentUrlParts = url.parse(this._currentUrl);
    var currentHost = currentHostHeader || currentUrlParts.host;
    var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, {
        host: currentHost
    }));
    // Determine the URL of the redirection
    var redirectUrl;
    try {
        redirectUrl = url.resolve(currentUrl, location);
    } catch (cause) {
        this.emit("error", new RedirectionError({
            cause: cause
        }));
        return;
    }
    // Create the redirected request
    debug("redirecting to", redirectUrl);
    this._isRedirect = true;
    var redirectUrlParts = url.parse(redirectUrl);
    Object.assign(this._options, redirectUrlParts);
    // Drop confidential headers when redirecting to a less secure protocol
    // or to a different domain that is not a superdomain
    if (redirectUrlParts.protocol !== currentUrlParts.protocol && redirectUrlParts.protocol !== "https:" || redirectUrlParts.host !== currentHost && !isSubdomain(redirectUrlParts.host, currentHost)) {
        removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);
    }
    // Evaluate the beforeRedirect callback
    if (isFunction(beforeRedirect)) {
        var responseDetails = {
            headers: response.headers,
            statusCode: statusCode
        };
        var requestDetails = {
            url: currentUrl,
            method: method,
            headers: requestHeaders
        };
        try {
            beforeRedirect(this._options, responseDetails, requestDetails);
        } catch (err) {
            this.emit("error", err);
            return;
        }
        this._sanitizeOptions(this._options);
    }
    // Perform the redirected request
    try {
        this._performRequest();
    } catch (cause1) {
        this.emit("error", new RedirectionError({
            cause: cause1
        }));
    }
};
// Wraps the key/value object of protocols with redirect functionality
function wrap(protocols) {
    // Default settings
    var exports = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
    };
    // Wrap each protocol
    var nativeProtocols = {};
    Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);
        // Executes a request, following redirects
        function request(input, options, callback) {
            // Parse parameters
            if (isString(input)) {
                var parsed;
                try {
                    parsed = urlToOptions(new URL(input));
                } catch (err) {
                    /* istanbul ignore next */ parsed = url.parse(input);
                }
                if (!isString(parsed.protocol)) {
                    throw new InvalidUrlError({
                        input
                    });
                }
                input = parsed;
            } else if (URL && input instanceof URL) {
                input = urlToOptions(input);
            } else {
                callback = options;
                options = input;
                input = {
                    protocol: protocol
                };
            }
            if (isFunction(options)) {
                callback = options;
                options = null;
            }
            // Set defaults
            options = Object.assign({
                maxRedirects: exports.maxRedirects,
                maxBodyLength: exports.maxBodyLength
            }, input, options);
            options.nativeProtocols = nativeProtocols;
            if (!isString(options.host) && !isString(options.hostname)) {
                options.hostname = "::1";
            }
            assert.equal(options.protocol, protocol, "protocol mismatch");
            debug("options", options);
            return new RedirectableRequest(options, callback);
        }
        // Executes a GET request, following redirects
        function get(input, options, callback) {
            var wrappedRequest = wrappedProtocol.request(input, options, callback);
            wrappedRequest.end();
            return wrappedRequest;
        }
        // Expose the properties on the wrapped protocol
        Object.defineProperties(wrappedProtocol, {
            request: {
                value: request,
                configurable: true,
                enumerable: true,
                writable: true
            },
            get: {
                value: get,
                configurable: true,
                enumerable: true,
                writable: true
            }
        });
    });
    return exports;
}
/* istanbul ignore next */ function noop() {}
// from https://github.com/nodejs/node/blob/master/lib/internal/url.js
function urlToOptions(urlObject) {
    var options = {
        protocol: urlObject.protocol,
        hostname: urlObject.hostname.startsWith("[") ? /* istanbul ignore next */ urlObject.hostname.slice(1, -1) : urlObject.hostname,
        hash: urlObject.hash,
        search: urlObject.search,
        pathname: urlObject.pathname,
        path: urlObject.pathname + urlObject.search,
        href: urlObject.href
    };
    if (urlObject.port !== "") {
        options.port = Number(urlObject.port);
    }
    return options;
}
function removeMatchingHeaders(regex, headers) {
    var lastValue;
    for(var header in headers){
        if (regex.test(header)) {
            lastValue = headers[header];
            delete headers[header];
        }
    }
    return lastValue === null || typeof lastValue === "undefined" ? undefined : String(lastValue).trim();
}
function createErrorType(code, message, baseClass) {
    // Create constructor
    function CustomError(properties) {
        Error.captureStackTrace(this, this.constructor);
        Object.assign(this, properties || {});
        this.code = code;
        this.message = this.cause ? message + ": " + this.cause.message : message;
    }
    // Attach constructor and set default properties
    CustomError.prototype = new (baseClass || Error)();
    CustomError.prototype.constructor = CustomError;
    CustomError.prototype.name = "Error [" + code + "]";
    return CustomError;
}
function abortRequest(request) {
    for (var event of events){
        request.removeListener(event, eventHandlers[event]);
    }
    request.on("error", noop);
    request.abort();
}
function isSubdomain(subdomain, domain) {
    assert(isString(subdomain) && isString(domain));
    var dot = subdomain.length - domain.length - 1;
    return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
}
function isString(value) {
    return typeof value === "string" || value instanceof String;
}
function isFunction(value) {
    return typeof value === "function";
}
function isBuffer(value) {
    return typeof value === "object" && "length" in value;
}
// Exports
module.exports = wrap({
    http: http,
    https: https
});
module.exports.wrap = wrap;


/***/ }),

/***/ 1379:
/***/ ((module) => {

"use strict";

module.exports = (flag, argv = process.argv)=>{
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};


/***/ }),

/***/ 89723:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "CompactEncrypt": () => (/* reexport */ CompactEncrypt),
  "CompactSign": () => (/* reexport */ CompactSign),
  "EmbeddedJWK": () => (/* reexport */ EmbeddedJWK),
  "EncryptJWT": () => (/* reexport */ EncryptJWT),
  "FlattenedEncrypt": () => (/* reexport */ FlattenedEncrypt),
  "FlattenedSign": () => (/* reexport */ FlattenedSign),
  "GeneralEncrypt": () => (/* reexport */ GeneralEncrypt),
  "GeneralSign": () => (/* reexport */ GeneralSign),
  "SignJWT": () => (/* reexport */ SignJWT),
  "UnsecuredJWT": () => (/* reexport */ UnsecuredJWT),
  "base64url": () => (/* reexport */ util_base64url_namespaceObject),
  "calculateJwkThumbprint": () => (/* reexport */ calculateJwkThumbprint),
  "calculateJwkThumbprintUri": () => (/* reexport */ calculateJwkThumbprintUri),
  "compactDecrypt": () => (/* reexport */ compactDecrypt),
  "compactVerify": () => (/* reexport */ compactVerify),
  "createLocalJWKSet": () => (/* reexport */ createLocalJWKSet),
  "createRemoteJWKSet": () => (/* reexport */ createRemoteJWKSet),
  "decodeJwt": () => (/* reexport */ decodeJwt),
  "decodeProtectedHeader": () => (/* reexport */ decodeProtectedHeader),
  "errors": () => (/* reexport */ errors_namespaceObject),
  "exportJWK": () => (/* reexport */ exportJWK),
  "exportPKCS8": () => (/* reexport */ exportPKCS8),
  "exportSPKI": () => (/* reexport */ exportSPKI),
  "flattenedDecrypt": () => (/* reexport */ flattenedDecrypt),
  "flattenedVerify": () => (/* reexport */ flattenedVerify),
  "generalDecrypt": () => (/* reexport */ generalDecrypt),
  "generalVerify": () => (/* reexport */ generalVerify),
  "generateKeyPair": () => (/* reexport */ generate_key_pair_generateKeyPair),
  "generateSecret": () => (/* reexport */ generate_secret_generateSecret),
  "importJWK": () => (/* reexport */ importJWK),
  "importPKCS8": () => (/* reexport */ importPKCS8),
  "importSPKI": () => (/* reexport */ importSPKI),
  "importX509": () => (/* reexport */ importX509),
  "jwtDecrypt": () => (/* reexport */ jwtDecrypt),
  "jwtVerify": () => (/* reexport */ jwtVerify)
});

// NAMESPACE OBJECT: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/util/errors.js
var errors_namespaceObject = {};
__webpack_require__.r(errors_namespaceObject);
__webpack_require__.d(errors_namespaceObject, {
  "JOSEAlgNotAllowed": () => (JOSEAlgNotAllowed),
  "JOSEError": () => (JOSEError),
  "JOSENotSupported": () => (JOSENotSupported),
  "JWEDecryptionFailed": () => (JWEDecryptionFailed),
  "JWEInvalid": () => (JWEInvalid),
  "JWKInvalid": () => (JWKInvalid),
  "JWKSInvalid": () => (JWKSInvalid),
  "JWKSMultipleMatchingKeys": () => (JWKSMultipleMatchingKeys),
  "JWKSNoMatchingKey": () => (JWKSNoMatchingKey),
  "JWKSTimeout": () => (JWKSTimeout),
  "JWSInvalid": () => (JWSInvalid),
  "JWSSignatureVerificationFailed": () => (JWSSignatureVerificationFailed),
  "JWTClaimValidationFailed": () => (JWTClaimValidationFailed),
  "JWTExpired": () => (JWTExpired),
  "JWTInvalid": () => (JWTInvalid)
});

// NAMESPACE OBJECT: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/util/base64url.js
var util_base64url_namespaceObject = {};
__webpack_require__.r(util_base64url_namespaceObject);
__webpack_require__.d(util_base64url_namespaceObject, {
  "decode": () => (base64url_decode),
  "encode": () => (base64url_encode)
});

// EXTERNAL MODULE: external "buffer"
var external_buffer_ = __webpack_require__(14300);
// EXTERNAL MODULE: external "crypto"
var external_crypto_ = __webpack_require__(6113);
;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/runtime/digest.js

const digest = (algorithm, data)=>(0,external_crypto_.createHash)(algorithm).update(data).digest();
/* harmony default export */ const runtime_digest = (digest);

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/lib/buffer_utils.js

const encoder = new TextEncoder();
const decoder = new TextDecoder();
const MAX_INT32 = 2 ** 32;
function concat(...buffers) {
    const size = buffers.reduce((acc, { length  })=>acc + length, 0);
    const buf = new Uint8Array(size);
    let i = 0;
    buffers.forEach((buffer)=>{
        buf.set(buffer, i);
        i += buffer.length;
    });
    return buf;
}
function buffer_utils_p2s(alg, p2sInput) {
    return concat(encoder.encode(alg), new Uint8Array([
        0
    ]), p2sInput);
}
function writeUInt32BE(buf, value, offset) {
    if (value < 0 || value >= MAX_INT32) {
        throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);
    }
    buf.set([
        value >>> 24,
        value >>> 16,
        value >>> 8,
        value & 0xff
    ], offset);
}
function uint64be(value) {
    const high = Math.floor(value / MAX_INT32);
    const low = value % MAX_INT32;
    const buf = new Uint8Array(8);
    writeUInt32BE(buf, high, 0);
    writeUInt32BE(buf, low, 4);
    return buf;
}
function uint32be(value) {
    const buf = new Uint8Array(4);
    writeUInt32BE(buf, value);
    return buf;
}
function lengthAndInput(input) {
    return concat(uint32be(input.length), input);
}
async function concatKdf(secret, bits, value) {
    const iterations = Math.ceil((bits >> 3) / 32);
    const res = new Uint8Array(iterations * 32);
    for(let iter = 0; iter < iterations; iter++){
        const buf = new Uint8Array(4 + secret.length + value.length);
        buf.set(uint32be(iter + 1));
        buf.set(secret, 4);
        buf.set(value, 4 + secret.length);
        res.set(await runtime_digest("sha256", buf), iter * 32);
    }
    return res.slice(0, bits >> 3);
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/runtime/base64url.js


let encode;
function normalize(input) {
    let encoded = input;
    if (encoded instanceof Uint8Array) {
        encoded = decoder.decode(encoded);
    }
    return encoded;
}
if (external_buffer_.Buffer.isEncoding("base64url")) {
    encode = (input)=>external_buffer_.Buffer.from(input).toString("base64url");
} else {
    encode = (input)=>external_buffer_.Buffer.from(input).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
const decodeBase64 = (input)=>external_buffer_.Buffer.from(input, "base64");
const encodeBase64 = (input)=>external_buffer_.Buffer.from(input).toString("base64");

const decode = (input)=>external_buffer_.Buffer.from(normalize(input), "base64");

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/util/errors.js
class JOSEError extends Error {
    constructor(message){
        var _a;
        super(message);
        this.code = "ERR_JOSE_GENERIC";
        this.name = this.constructor.name;
        (_a = Error.captureStackTrace) === null || _a === void 0 ? void 0 : _a.call(Error, this, this.constructor);
    }
    static get code() {
        return "ERR_JOSE_GENERIC";
    }
}
class JWTClaimValidationFailed extends JOSEError {
    constructor(message, claim = "unspecified", reason = "unspecified"){
        super(message);
        this.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
        this.claim = claim;
        this.reason = reason;
    }
    static get code() {
        return "ERR_JWT_CLAIM_VALIDATION_FAILED";
    }
}
class JWTExpired extends JOSEError {
    constructor(message, claim = "unspecified", reason = "unspecified"){
        super(message);
        this.code = "ERR_JWT_EXPIRED";
        this.claim = claim;
        this.reason = reason;
    }
    static get code() {
        return "ERR_JWT_EXPIRED";
    }
}
class JOSEAlgNotAllowed extends JOSEError {
    constructor(){
        super(...arguments);
        this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
    }
    static get code() {
        return "ERR_JOSE_ALG_NOT_ALLOWED";
    }
}
class JOSENotSupported extends JOSEError {
    constructor(){
        super(...arguments);
        this.code = "ERR_JOSE_NOT_SUPPORTED";
    }
    static get code() {
        return "ERR_JOSE_NOT_SUPPORTED";
    }
}
class JWEDecryptionFailed extends JOSEError {
    constructor(){
        super(...arguments);
        this.code = "ERR_JWE_DECRYPTION_FAILED";
        this.message = "decryption operation failed";
    }
    static get code() {
        return "ERR_JWE_DECRYPTION_FAILED";
    }
}
class JWEInvalid extends JOSEError {
    constructor(){
        super(...arguments);
        this.code = "ERR_JWE_INVALID";
    }
    static get code() {
        return "ERR_JWE_INVALID";
    }
}
class JWSInvalid extends JOSEError {
    constructor(){
        super(...arguments);
        this.code = "ERR_JWS_INVALID";
    }
    static get code() {
        return "ERR_JWS_INVALID";
    }
}
class JWTInvalid extends JOSEError {
    constructor(){
        super(...arguments);
        this.code = "ERR_JWT_INVALID";
    }
    static get code() {
        return "ERR_JWT_INVALID";
    }
}
class JWKInvalid extends JOSEError {
    constructor(){
        super(...arguments);
        this.code = "ERR_JWK_INVALID";
    }
    static get code() {
        return "ERR_JWK_INVALID";
    }
}
class JWKSInvalid extends JOSEError {
    constructor(){
        super(...arguments);
        this.code = "ERR_JWKS_INVALID";
    }
    static get code() {
        return "ERR_JWKS_INVALID";
    }
}
class JWKSNoMatchingKey extends JOSEError {
    constructor(){
        super(...arguments);
        this.code = "ERR_JWKS_NO_MATCHING_KEY";
        this.message = "no applicable key found in the JSON Web Key Set";
    }
    static get code() {
        return "ERR_JWKS_NO_MATCHING_KEY";
    }
}
class JWKSMultipleMatchingKeys extends JOSEError {
    constructor(){
        super(...arguments);
        this.code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
        this.message = "multiple matching keys found in the JSON Web Key Set";
    }
    static get code() {
        return "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
    }
}
class JWKSTimeout extends JOSEError {
    constructor(){
        super(...arguments);
        this.code = "ERR_JWKS_TIMEOUT";
        this.message = "request timed out";
    }
    static get code() {
        return "ERR_JWKS_TIMEOUT";
    }
}
class JWSSignatureVerificationFailed extends JOSEError {
    constructor(){
        super(...arguments);
        this.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
        this.message = "signature verification failed";
    }
    static get code() {
        return "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
    }
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/runtime/random.js


;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/lib/iv.js


function bitLength(alg) {
    switch(alg){
        case "A128GCM":
        case "A128GCMKW":
        case "A192GCM":
        case "A192GCMKW":
        case "A256GCM":
        case "A256GCMKW":
            return 96;
        case "A128CBC-HS256":
        case "A192CBC-HS384":
        case "A256CBC-HS512":
            return 128;
        default:
            throw new JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);
    }
}
/* harmony default export */ const lib_iv = ((alg)=>(0,external_crypto_.randomFillSync)(new Uint8Array(bitLength(alg) >> 3)));

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/lib/check_iv_length.js


const checkIvLength = (enc, iv)=>{
    if (iv.length << 3 !== bitLength(enc)) {
        throw new JWEInvalid("Invalid Initialization Vector length");
    }
};
/* harmony default export */ const check_iv_length = (checkIvLength);

// EXTERNAL MODULE: external "util"
var external_util_ = __webpack_require__(73837);
;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/runtime/is_key_object.js


/* harmony default export */ const is_key_object = (external_util_.types.isKeyObject ? (obj)=>external_util_.types.isKeyObject(obj) : (obj)=>obj != null && obj instanceof external_crypto_.KeyObject);

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/runtime/check_cek_length.js


const checkCekLength = (enc, cek)=>{
    let expected;
    switch(enc){
        case "A128CBC-HS256":
        case "A192CBC-HS384":
        case "A256CBC-HS512":
            expected = parseInt(enc.slice(-3), 10);
            break;
        case "A128GCM":
        case "A192GCM":
        case "A256GCM":
            expected = parseInt(enc.slice(1, 4), 10);
            break;
        default:
            throw new JOSENotSupported(`Content Encryption Algorithm ${enc} is not supported either by JOSE or your javascript runtime`);
    }
    if (cek instanceof Uint8Array) {
        const actual = cek.byteLength << 3;
        if (actual !== expected) {
            throw new JWEInvalid(`Invalid Content Encryption Key length. Expected ${expected} bits, got ${actual} bits`);
        }
        return;
    }
    if (is_key_object(cek) && cek.type === "secret") {
        const actual1 = cek.symmetricKeySize << 3;
        if (actual1 !== expected) {
            throw new JWEInvalid(`Invalid Content Encryption Key length. Expected ${expected} bits, got ${actual1} bits`);
        }
        return;
    }
    throw new TypeError("Invalid Content Encryption Key type");
};
/* harmony default export */ const check_cek_length = (checkCekLength);

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/runtime/timing_safe_equal.js

const timingSafeEqual = external_crypto_.timingSafeEqual;
/* harmony default export */ const timing_safe_equal = (timingSafeEqual);

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/runtime/cbc_tag.js


function cbcTag(aad, iv, ciphertext, macSize, macKey, keySize) {
    const macData = concat(aad, iv, ciphertext, uint64be(aad.length << 3));
    const hmac = (0,external_crypto_.createHmac)(`sha${macSize}`, macKey);
    hmac.update(macData);
    return hmac.digest().slice(0, keySize >> 3);
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/runtime/webcrypto.js


const webcrypto = external_crypto_.webcrypto;
/* harmony default export */ const runtime_webcrypto = ((/* unused pure expression or super */ null && (webcrypto)));
const isCryptoKey = external_util_.types.isCryptoKey ? (key)=>external_util_.types.isCryptoKey(key) : (key)=>false;

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/runtime/env.js
function isCloudflareWorkers() {
    return false;
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/lib/crypto_key.js

function unusable(name, prop = "algorithm.name") {
    return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
}
function isAlgorithm(algorithm, name) {
    return algorithm.name === name;
}
function getHashLength(hash) {
    return parseInt(hash.name.slice(4), 10);
}
function getNamedCurve(alg) {
    switch(alg){
        case "ES256":
            return "P-256";
        case "ES384":
            return "P-384";
        case "ES512":
            return "P-521";
        default:
            throw new Error("unreachable");
    }
}
function checkUsage(key, usages) {
    if (usages.length && !usages.some((expected)=>key.usages.includes(expected))) {
        let msg = "CryptoKey does not support this operation, its usages must include ";
        if (usages.length > 2) {
            const last = usages.pop();
            msg += `one of ${usages.join(", ")}, or ${last}.`;
        } else if (usages.length === 2) {
            msg += `one of ${usages[0]} or ${usages[1]}.`;
        } else {
            msg += `${usages[0]}.`;
        }
        throw new TypeError(msg);
    }
}
function checkSigCryptoKey(key, alg, ...usages) {
    switch(alg){
        case "HS256":
        case "HS384":
        case "HS512":
            {
                if (!isAlgorithm(key.algorithm, "HMAC")) throw unusable("HMAC");
                const expected = parseInt(alg.slice(2), 10);
                const actual = getHashLength(key.algorithm.hash);
                if (actual !== expected) throw unusable(`SHA-${expected}`, "algorithm.hash");
                break;
            }
        case "RS256":
        case "RS384":
        case "RS512":
            {
                if (!isAlgorithm(key.algorithm, "RSASSA-PKCS1-v1_5")) throw unusable("RSASSA-PKCS1-v1_5");
                const expected1 = parseInt(alg.slice(2), 10);
                const actual1 = getHashLength(key.algorithm.hash);
                if (actual1 !== expected1) throw unusable(`SHA-${expected1}`, "algorithm.hash");
                break;
            }
        case "PS256":
        case "PS384":
        case "PS512":
            {
                if (!isAlgorithm(key.algorithm, "RSA-PSS")) throw unusable("RSA-PSS");
                const expected2 = parseInt(alg.slice(2), 10);
                const actual2 = getHashLength(key.algorithm.hash);
                if (actual2 !== expected2) throw unusable(`SHA-${expected2}`, "algorithm.hash");
                break;
            }
        case isCloudflareWorkers() && "EdDSA":
            {
                if (!isAlgorithm(key.algorithm, "NODE-ED25519")) throw unusable("NODE-ED25519");
                break;
            }
        case "EdDSA":
            {
                if (key.algorithm.name !== "Ed25519" && key.algorithm.name !== "Ed448") {
                    throw unusable("Ed25519 or Ed448");
                }
                break;
            }
        case "ES256":
        case "ES384":
        case "ES512":
            {
                if (!isAlgorithm(key.algorithm, "ECDSA")) throw unusable("ECDSA");
                const expected3 = getNamedCurve(alg);
                const actual3 = key.algorithm.namedCurve;
                if (actual3 !== expected3) throw unusable(expected3, "algorithm.namedCurve");
                break;
            }
        default:
            throw new TypeError("CryptoKey does not support this operation");
    }
    checkUsage(key, usages);
}
function checkEncCryptoKey(key, alg, ...usages) {
    switch(alg){
        case "A128GCM":
        case "A192GCM":
        case "A256GCM":
            {
                if (!isAlgorithm(key.algorithm, "AES-GCM")) throw unusable("AES-GCM");
                const expected = parseInt(alg.slice(1, 4), 10);
                const actual = key.algorithm.length;
                if (actual !== expected) throw unusable(expected, "algorithm.length");
                break;
            }
        case "A128KW":
        case "A192KW":
        case "A256KW":
            {
                if (!isAlgorithm(key.algorithm, "AES-KW")) throw unusable("AES-KW");
                const expected1 = parseInt(alg.slice(1, 4), 10);
                const actual1 = key.algorithm.length;
                if (actual1 !== expected1) throw unusable(expected1, "algorithm.length");
                break;
            }
        case "ECDH":
            {
                switch(key.algorithm.name){
                    case "ECDH":
                    case "X25519":
                    case "X448":
                        break;
                    default:
                        throw unusable("ECDH, X25519, or X448");
                }
                break;
            }
        case "PBES2-HS256+A128KW":
        case "PBES2-HS384+A192KW":
        case "PBES2-HS512+A256KW":
            if (!isAlgorithm(key.algorithm, "PBKDF2")) throw unusable("PBKDF2");
            break;
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
            {
                if (!isAlgorithm(key.algorithm, "RSA-OAEP")) throw unusable("RSA-OAEP");
                const expected2 = parseInt(alg.slice(9), 10) || 1;
                const actual2 = getHashLength(key.algorithm.hash);
                if (actual2 !== expected2) throw unusable(`SHA-${expected2}`, "algorithm.hash");
                break;
            }
        default:
            throw new TypeError("CryptoKey does not support this operation");
    }
    checkUsage(key, usages);
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/lib/invalid_key_input.js
function message(msg, actual, ...types) {
    if (types.length > 2) {
        const last = types.pop();
        msg += `one of type ${types.join(", ")}, or ${last}.`;
    } else if (types.length === 2) {
        msg += `one of type ${types[0]} or ${types[1]}.`;
    } else {
        msg += `of type ${types[0]}.`;
    }
    if (actual == null) {
        msg += ` Received ${actual}`;
    } else if (typeof actual === "function" && actual.name) {
        msg += ` Received function ${actual.name}`;
    } else if (typeof actual === "object" && actual != null) {
        if (actual.constructor && actual.constructor.name) {
            msg += ` Received an instance of ${actual.constructor.name}`;
        }
    }
    return msg;
}
/* harmony default export */ const invalid_key_input = ((actual, ...types)=>{
    return message("Key must be ", actual, ...types);
});
function withAlg(alg, actual, ...types) {
    return message(`Key for the ${alg} algorithm must be `, actual, ...types);
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/runtime/ciphers.js

let ciphers;
/* harmony default export */ const runtime_ciphers = ((algorithm)=>{
    ciphers || (ciphers = new Set((0,external_crypto_.getCiphers)()));
    return ciphers.has(algorithm);
});

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/runtime/is_key_like.js


/* harmony default export */ const is_key_like = ((key)=>is_key_object(key) || isCryptoKey(key));
const types = [
    "KeyObject"
];
if (parseInt(process.versions.node) >= 16) {
    types.push("CryptoKey");
}


;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/runtime/decrypt.js













function cbcDecrypt(enc, cek, ciphertext, iv, tag, aad) {
    const keySize = parseInt(enc.slice(1, 4), 10);
    if (is_key_object(cek)) {
        cek = cek.export();
    }
    const encKey = cek.subarray(keySize >> 3);
    const macKey = cek.subarray(0, keySize >> 3);
    const macSize = parseInt(enc.slice(-3), 10);
    const algorithm = `aes-${keySize}-cbc`;
    if (!runtime_ciphers(algorithm)) {
        throw new JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);
    }
    const expectedTag = cbcTag(aad, iv, ciphertext, macSize, macKey, keySize);
    let macCheckPassed;
    try {
        macCheckPassed = timing_safe_equal(tag, expectedTag);
    } catch  {}
    if (!macCheckPassed) {
        throw new JWEDecryptionFailed();
    }
    let plaintext;
    try {
        const decipher = (0,external_crypto_.createDecipheriv)(algorithm, encKey, iv);
        plaintext = concat(decipher.update(ciphertext), decipher.final());
    } catch  {}
    if (!plaintext) {
        throw new JWEDecryptionFailed();
    }
    return plaintext;
}
function gcmDecrypt(enc, cek, ciphertext, iv, tag, aad) {
    const keySize = parseInt(enc.slice(1, 4), 10);
    const algorithm = `aes-${keySize}-gcm`;
    if (!runtime_ciphers(algorithm)) {
        throw new JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);
    }
    try {
        const decipher = (0,external_crypto_.createDecipheriv)(algorithm, cek, iv, {
            authTagLength: 16
        });
        decipher.setAuthTag(tag);
        if (aad.byteLength) {
            decipher.setAAD(aad, {
                plaintextLength: ciphertext.length
            });
        }
        const plaintext = decipher.update(ciphertext);
        decipher.final();
        return plaintext;
    } catch  {
        throw new JWEDecryptionFailed();
    }
}
const decrypt = (enc, cek, ciphertext, iv, tag, aad)=>{
    let key;
    if (isCryptoKey(cek)) {
        checkEncCryptoKey(cek, enc, "decrypt");
        key = external_crypto_.KeyObject.from(cek);
    } else if (cek instanceof Uint8Array || is_key_object(cek)) {
        key = cek;
    } else {
        throw new TypeError(invalid_key_input(cek, ...types, "Uint8Array"));
    }
    check_cek_length(enc, key);
    check_iv_length(enc, iv);
    switch(enc){
        case "A128CBC-HS256":
        case "A192CBC-HS384":
        case "A256CBC-HS512":
            return cbcDecrypt(enc, key, ciphertext, iv, tag, aad);
        case "A128GCM":
        case "A192GCM":
        case "A256GCM":
            return gcmDecrypt(enc, key, ciphertext, iv, tag, aad);
        default:
            throw new JOSENotSupported("Unsupported JWE Content Encryption Algorithm");
    }
};
/* harmony default export */ const runtime_decrypt = (decrypt);

// EXTERNAL MODULE: external "zlib"
var external_zlib_ = __webpack_require__(59796);
;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/runtime/zlib.js


const inflateRaw = (0,external_util_.promisify)(external_zlib_.inflateRaw);
const deflateRaw = (0,external_util_.promisify)(external_zlib_.deflateRaw);
const inflate = (input)=>inflateRaw(input);
const deflate = (input)=>deflateRaw(input);

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/lib/is_disjoint.js
const isDisjoint = (...headers)=>{
    const sources = headers.filter(Boolean);
    if (sources.length === 0 || sources.length === 1) {
        return true;
    }
    let acc;
    for (const header of sources){
        const parameters = Object.keys(header);
        if (!acc || acc.size === 0) {
            acc = new Set(parameters);
            continue;
        }
        for (const parameter of parameters){
            if (acc.has(parameter)) {
                return false;
            }
            acc.add(parameter);
        }
    }
    return true;
};
/* harmony default export */ const is_disjoint = (isDisjoint);

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/lib/is_object.js
function isObjectLike(value) {
    return typeof value === "object" && value !== null;
}
function isObject(input) {
    if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
        return false;
    }
    if (Object.getPrototypeOf(input) === null) {
        return true;
    }
    let proto = input;
    while(Object.getPrototypeOf(proto) !== null){
        proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(input) === proto;
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/runtime/aeskw.js










function checkKeySize(key, alg) {
    if (key.symmetricKeySize << 3 !== parseInt(alg.slice(1, 4), 10)) {
        throw new TypeError(`Invalid key size for alg: ${alg}`);
    }
}
function ensureKeyObject(key, alg, usage) {
    if (is_key_object(key)) {
        return key;
    }
    if (key instanceof Uint8Array) {
        return (0,external_crypto_.createSecretKey)(key);
    }
    if (isCryptoKey(key)) {
        checkEncCryptoKey(key, alg, usage);
        return external_crypto_.KeyObject.from(key);
    }
    throw new TypeError(invalid_key_input(key, ...types, "Uint8Array"));
}
const wrap = (alg, key, cek)=>{
    const size = parseInt(alg.slice(1, 4), 10);
    const algorithm = `aes${size}-wrap`;
    if (!runtime_ciphers(algorithm)) {
        throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
    }
    const keyObject = ensureKeyObject(key, alg, "wrapKey");
    checkKeySize(keyObject, alg);
    const cipher = (0,external_crypto_.createCipheriv)(algorithm, keyObject, external_buffer_.Buffer.alloc(8, 0xa6));
    return concat(cipher.update(cek), cipher.final());
};
const unwrap = (alg, key, encryptedKey)=>{
    const size = parseInt(alg.slice(1, 4), 10);
    const algorithm = `aes${size}-wrap`;
    if (!runtime_ciphers(algorithm)) {
        throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
    }
    const keyObject = ensureKeyObject(key, alg, "unwrapKey");
    checkKeySize(keyObject, alg);
    const cipher = (0,external_crypto_.createDecipheriv)(algorithm, keyObject, external_buffer_.Buffer.alloc(8, 0xa6));
    return concat(cipher.update(encryptedKey), cipher.final());
};

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/runtime/get_named_curve.js







const p256 = external_buffer_.Buffer.from([
    42,
    134,
    72,
    206,
    61,
    3,
    1,
    7
]);
const p384 = external_buffer_.Buffer.from([
    43,
    129,
    4,
    0,
    34
]);
const p521 = external_buffer_.Buffer.from([
    43,
    129,
    4,
    0,
    35
]);
const secp256k1 = external_buffer_.Buffer.from([
    43,
    129,
    4,
    0,
    10
]);
const weakMap = new WeakMap();
const namedCurveToJOSE = (namedCurve)=>{
    switch(namedCurve){
        case "prime256v1":
            return "P-256";
        case "secp384r1":
            return "P-384";
        case "secp521r1":
            return "P-521";
        case "secp256k1":
            return "secp256k1";
        default:
            throw new JOSENotSupported("Unsupported key curve for this operation");
    }
};
const get_named_curve_getNamedCurve = (kee, raw)=>{
    var _a;
    let key;
    if (isCryptoKey(kee)) {
        key = external_crypto_.KeyObject.from(kee);
    } else if (is_key_object(kee)) {
        key = kee;
    } else {
        throw new TypeError(invalid_key_input(kee, ...types));
    }
    if (key.type === "secret") {
        throw new TypeError('only "private" or "public" type keys can be used for this operation');
    }
    switch(key.asymmetricKeyType){
        case "ed25519":
        case "ed448":
            return `Ed${key.asymmetricKeyType.slice(2)}`;
        case "x25519":
        case "x448":
            return `X${key.asymmetricKeyType.slice(1)}`;
        case "ec":
            {
                if (weakMap.has(key)) {
                    return weakMap.get(key);
                }
                let namedCurve = (_a = key.asymmetricKeyDetails) === null || _a === void 0 ? void 0 : _a.namedCurve;
                if (!namedCurve && key.type === "private") {
                    namedCurve = get_named_curve_getNamedCurve((0,external_crypto_.createPublicKey)(key), true);
                } else if (!namedCurve) {
                    const buf = key.export({
                        format: "der",
                        type: "spki"
                    });
                    const i = buf[1] < 128 ? 14 : 15;
                    const len = buf[i];
                    const curveOid = buf.slice(i + 1, i + 1 + len);
                    if (curveOid.equals(p256)) {
                        namedCurve = "prime256v1";
                    } else if (curveOid.equals(p384)) {
                        namedCurve = "secp384r1";
                    } else if (curveOid.equals(p521)) {
                        namedCurve = "secp521r1";
                    } else if (curveOid.equals(secp256k1)) {
                        namedCurve = "secp256k1";
                    } else {
                        throw new JOSENotSupported("Unsupported key curve for this operation");
                    }
                }
                if (raw) return namedCurve;
                const curve = namedCurveToJOSE(namedCurve);
                weakMap.set(key, curve);
                return curve;
            }
        default:
            throw new TypeError("Invalid asymmetric key type for this operation");
    }
};
function setCurve(keyObject, curve) {
    weakMap.set(keyObject, curve);
}
/* harmony default export */ const get_named_curve = (get_named_curve_getNamedCurve);

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/runtime/ecdhes.js










const generateKeyPair = (0,external_util_.promisify)(external_crypto_.generateKeyPair);
async function deriveKey(publicKee, privateKee, algorithm, keyLength, apu = new Uint8Array(0), apv = new Uint8Array(0)) {
    let publicKey;
    if (isCryptoKey(publicKee)) {
        checkEncCryptoKey(publicKee, "ECDH");
        publicKey = external_crypto_.KeyObject.from(publicKee);
    } else if (is_key_object(publicKee)) {
        publicKey = publicKee;
    } else {
        throw new TypeError(invalid_key_input(publicKee, ...types));
    }
    let privateKey;
    if (isCryptoKey(privateKee)) {
        checkEncCryptoKey(privateKee, "ECDH", "deriveBits");
        privateKey = external_crypto_.KeyObject.from(privateKee);
    } else if (is_key_object(privateKee)) {
        privateKey = privateKee;
    } else {
        throw new TypeError(invalid_key_input(privateKee, ...types));
    }
    const value = concat(lengthAndInput(encoder.encode(algorithm)), lengthAndInput(apu), lengthAndInput(apv), uint32be(keyLength));
    const sharedSecret = (0,external_crypto_.diffieHellman)({
        privateKey,
        publicKey
    });
    return concatKdf(sharedSecret, keyLength, value);
}
async function generateEpk(kee) {
    let key;
    if (isCryptoKey(kee)) {
        key = external_crypto_.KeyObject.from(kee);
    } else if (is_key_object(kee)) {
        key = kee;
    } else {
        throw new TypeError(invalid_key_input(kee, ...types));
    }
    switch(key.asymmetricKeyType){
        case "x25519":
            return generateKeyPair("x25519");
        case "x448":
            {
                return generateKeyPair("x448");
            }
        case "ec":
            {
                const namedCurve = get_named_curve(key);
                return generateKeyPair("ec", {
                    namedCurve
                });
            }
        default:
            throw new JOSENotSupported("Invalid or unsupported EPK");
    }
}
const ecdhAllowed = (key)=>[
        "P-256",
        "P-384",
        "P-521",
        "X25519",
        "X448"
    ].includes(get_named_curve(key));

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/lib/check_p2s.js

function checkP2s(p2s) {
    if (!(p2s instanceof Uint8Array) || p2s.length < 8) {
        throw new JWEInvalid("PBES2 Salt Input must be 8 or more octets");
    }
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/runtime/pbes2kw.js












const pbkdf2 = (0,external_util_.promisify)(external_crypto_.pbkdf2);
function getPassword(key, alg) {
    if (is_key_object(key)) {
        return key.export();
    }
    if (key instanceof Uint8Array) {
        return key;
    }
    if (isCryptoKey(key)) {
        checkEncCryptoKey(key, alg, "deriveBits", "deriveKey");
        return external_crypto_.KeyObject.from(key).export();
    }
    throw new TypeError(invalid_key_input(key, ...types, "Uint8Array"));
}
const encrypt = async (alg, key, cek, p2c = 2048, p2s = (0,external_crypto_.randomFillSync)(new Uint8Array(16)))=>{
    checkP2s(p2s);
    const salt = buffer_utils_p2s(alg, p2s);
    const keylen = parseInt(alg.slice(13, 16), 10) >> 3;
    const password = getPassword(key, alg);
    const derivedKey = await pbkdf2(password, salt, p2c, keylen, `sha${alg.slice(8, 11)}`);
    const encryptedKey = await wrap(alg.slice(-6), derivedKey, cek);
    return {
        encryptedKey,
        p2c,
        p2s: encode(p2s)
    };
};
const pbes2kw_decrypt = async (alg, key, encryptedKey, p2c, p2s)=>{
    checkP2s(p2s);
    const salt = buffer_utils_p2s(alg, p2s);
    const keylen = parseInt(alg.slice(13, 16), 10) >> 3;
    const password = getPassword(key, alg);
    const derivedKey = await pbkdf2(password, salt, p2c, keylen, `sha${alg.slice(8, 11)}`);
    return unwrap(alg.slice(-6), derivedKey, encryptedKey);
};

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/runtime/check_modulus_length.js
const check_modulus_length_weakMap = new WeakMap();
const getLength = (buf, index)=>{
    let len = buf.readUInt8(1);
    if ((len & 0x80) === 0) {
        if (index === 0) {
            return len;
        }
        return getLength(buf.subarray(2 + len), index - 1);
    }
    const num = len & 0x7f;
    len = 0;
    for(let i = 0; i < num; i++){
        len <<= 8;
        const j = buf.readUInt8(2 + i);
        len |= j;
    }
    if (index === 0) {
        return len;
    }
    return getLength(buf.subarray(2 + len), index - 1);
};
const getLengthOfSeqIndex = (sequence, index)=>{
    const len = sequence.readUInt8(1);
    if ((len & 0x80) === 0) {
        return getLength(sequence.subarray(2), index);
    }
    const num = len & 0x7f;
    return getLength(sequence.subarray(2 + num), index);
};
const getModulusLength = (key)=>{
    var _a, _b;
    if (check_modulus_length_weakMap.has(key)) {
        return check_modulus_length_weakMap.get(key);
    }
    const modulusLength = (_b = (_a = key.asymmetricKeyDetails) === null || _a === void 0 ? void 0 : _a.modulusLength) !== null && _b !== void 0 ? _b : getLengthOfSeqIndex(key.export({
        format: "der",
        type: "pkcs1"
    }), key.type === "private" ? 1 : 0) - 1 << 3;
    check_modulus_length_weakMap.set(key, modulusLength);
    return modulusLength;
};
const setModulusLength = (keyObject, modulusLength)=>{
    check_modulus_length_weakMap.set(keyObject, modulusLength);
};
/* harmony default export */ const check_modulus_length = ((key, alg)=>{
    if (getModulusLength(key) < 2048) {
        throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
    }
});

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/runtime/rsaes.js







const checkKey = (key, alg)=>{
    if (key.asymmetricKeyType !== "rsa") {
        throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be rsa");
    }
    check_modulus_length(key, alg);
};
const resolvePadding = (alg)=>{
    switch(alg){
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
            return external_crypto_.constants.RSA_PKCS1_OAEP_PADDING;
        case "RSA1_5":
            return external_crypto_.constants.RSA_PKCS1_PADDING;
        default:
            return undefined;
    }
};
const resolveOaepHash = (alg)=>{
    switch(alg){
        case "RSA-OAEP":
            return "sha1";
        case "RSA-OAEP-256":
            return "sha256";
        case "RSA-OAEP-384":
            return "sha384";
        case "RSA-OAEP-512":
            return "sha512";
        default:
            return undefined;
    }
};
function rsaes_ensureKeyObject(key, alg, ...usages) {
    if (is_key_object(key)) {
        return key;
    }
    if (isCryptoKey(key)) {
        checkEncCryptoKey(key, alg, ...usages);
        return external_crypto_.KeyObject.from(key);
    }
    throw new TypeError(invalid_key_input(key, ...types));
}
const rsaes_encrypt = (alg, key, cek)=>{
    const padding = resolvePadding(alg);
    const oaepHash = resolveOaepHash(alg);
    const keyObject = rsaes_ensureKeyObject(key, alg, "wrapKey", "encrypt");
    checkKey(keyObject, alg);
    return (0,external_crypto_.publicEncrypt)({
        key: keyObject,
        oaepHash,
        padding
    }, cek);
};
const rsaes_decrypt = (alg, key, encryptedKey)=>{
    const padding = resolvePadding(alg);
    const oaepHash = resolveOaepHash(alg);
    const keyObject = rsaes_ensureKeyObject(key, alg, "unwrapKey", "decrypt");
    checkKey(keyObject, alg);
    return (0,external_crypto_.privateDecrypt)({
        key: keyObject,
        oaepHash,
        padding
    }, encryptedKey);
};

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/lib/cek.js


function cek_bitLength(alg) {
    switch(alg){
        case "A128GCM":
            return 128;
        case "A192GCM":
            return 192;
        case "A256GCM":
        case "A128CBC-HS256":
            return 256;
        case "A192CBC-HS384":
            return 384;
        case "A256CBC-HS512":
            return 512;
        default:
            throw new JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);
    }
}
/* harmony default export */ const lib_cek = ((alg)=>(0,external_crypto_.randomFillSync)(new Uint8Array(cek_bitLength(alg) >> 3)));

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/runtime/asn1.js






const genericExport = (keyType, keyFormat, key)=>{
    let keyObject;
    if (isCryptoKey(key)) {
        if (!key.extractable) {
            throw new TypeError("CryptoKey is not extractable");
        }
        keyObject = external_crypto_.KeyObject.from(key);
    } else if (is_key_object(key)) {
        keyObject = key;
    } else {
        throw new TypeError(invalid_key_input(key, ...types));
    }
    if (keyObject.type !== keyType) {
        throw new TypeError(`key is not a ${keyType} key`);
    }
    return keyObject.export({
        format: "pem",
        type: keyFormat
    });
};
const toSPKI = (key)=>{
    return genericExport("public", "spki", key);
};
const toPKCS8 = (key)=>{
    return genericExport("private", "pkcs8", key);
};
const fromPKCS8 = (pem)=>(0,external_crypto_.createPrivateKey)({
        key: external_buffer_.Buffer.from(pem.replace(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g, ""), "base64"),
        type: "pkcs8",
        format: "der"
    });
const fromSPKI = (pem)=>(0,external_crypto_.createPublicKey)({
        key: external_buffer_.Buffer.from(pem.replace(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g, ""), "base64"),
        type: "spki",
        format: "der"
    });

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/runtime/asn1_sequence_encoder.js


const tagInteger = 0x02;
const tagBitStr = 0x03;
const tagOctStr = 0x04;
const tagSequence = 0x30;
const bZero = external_buffer_.Buffer.from([
    0x00
]);
const bTagInteger = external_buffer_.Buffer.from([
    tagInteger
]);
const bTagBitStr = external_buffer_.Buffer.from([
    tagBitStr
]);
const bTagSequence = external_buffer_.Buffer.from([
    tagSequence
]);
const bTagOctStr = external_buffer_.Buffer.from([
    tagOctStr
]);
const encodeLength = (len)=>{
    if (len < 128) return external_buffer_.Buffer.from([
        len
    ]);
    const buffer = external_buffer_.Buffer.alloc(5);
    buffer.writeUInt32BE(len, 1);
    let offset = 1;
    while(buffer[offset] === 0)offset++;
    buffer[offset - 1] = 0x80 | 5 - offset;
    return buffer.slice(offset - 1);
};
const oids = new Map([
    [
        "P-256",
        external_buffer_.Buffer.from("06 08 2A 86 48 CE 3D 03 01 07".replace(/ /g, ""), "hex")
    ],
    [
        "secp256k1",
        external_buffer_.Buffer.from("06 05 2B 81 04 00 0A".replace(/ /g, ""), "hex")
    ],
    [
        "P-384",
        external_buffer_.Buffer.from("06 05 2B 81 04 00 22".replace(/ /g, ""), "hex")
    ],
    [
        "P-521",
        external_buffer_.Buffer.from("06 05 2B 81 04 00 23".replace(/ /g, ""), "hex")
    ],
    [
        "ecPublicKey",
        external_buffer_.Buffer.from("06 07 2A 86 48 CE 3D 02 01".replace(/ /g, ""), "hex")
    ],
    [
        "X25519",
        external_buffer_.Buffer.from("06 03 2B 65 6E".replace(/ /g, ""), "hex")
    ],
    [
        "X448",
        external_buffer_.Buffer.from("06 03 2B 65 6F".replace(/ /g, ""), "hex")
    ],
    [
        "Ed25519",
        external_buffer_.Buffer.from("06 03 2B 65 70".replace(/ /g, ""), "hex")
    ],
    [
        "Ed448",
        external_buffer_.Buffer.from("06 03 2B 65 71".replace(/ /g, ""), "hex")
    ]
]);
class DumbAsn1Encoder {
    constructor(){
        this.length = 0;
        this.elements = [];
    }
    oidFor(oid) {
        const bOid = oids.get(oid);
        if (!bOid) {
            throw new JOSENotSupported("Invalid or unsupported OID");
        }
        this.elements.push(bOid);
        this.length += bOid.length;
    }
    zero() {
        this.elements.push(bTagInteger, external_buffer_.Buffer.from([
            0x01
        ]), bZero);
        this.length += 3;
    }
    one() {
        this.elements.push(bTagInteger, external_buffer_.Buffer.from([
            0x01
        ]), external_buffer_.Buffer.from([
            0x01
        ]));
        this.length += 3;
    }
    unsignedInteger(integer) {
        if (integer[0] & 0x80) {
            const len = encodeLength(integer.length + 1);
            this.elements.push(bTagInteger, len, bZero, integer);
            this.length += 2 + len.length + integer.length;
        } else {
            let i = 0;
            while(integer[i] === 0 && (integer[i + 1] & 0x80) === 0)i++;
            const len1 = encodeLength(integer.length - i);
            this.elements.push(bTagInteger, encodeLength(integer.length - i), integer.slice(i));
            this.length += 1 + len1.length + integer.length - i;
        }
    }
    octStr(octStr) {
        const len = encodeLength(octStr.length);
        this.elements.push(bTagOctStr, encodeLength(octStr.length), octStr);
        this.length += 1 + len.length + octStr.length;
    }
    bitStr(bitS) {
        const len = encodeLength(bitS.length + 1);
        this.elements.push(bTagBitStr, encodeLength(bitS.length + 1), bZero, bitS);
        this.length += 1 + len.length + bitS.length + 1;
    }
    add(seq) {
        this.elements.push(seq);
        this.length += seq.length;
    }
    end(tag = bTagSequence) {
        const len = encodeLength(this.length);
        return external_buffer_.Buffer.concat([
            tag,
            len,
            ...this.elements
        ], 1 + len.length + this.length);
    }
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/runtime/jwk_to_key.js







const [major, minor] = process.version.slice(1).split(".").map((str)=>parseInt(str, 10));
const jwkImportSupported = major >= 16 || major === 15 && minor >= 12;
const parse = (jwk)=>{
    if (jwkImportSupported && jwk.kty !== "oct") {
        return jwk.d ? (0,external_crypto_.createPrivateKey)({
            format: "jwk",
            key: jwk
        }) : (0,external_crypto_.createPublicKey)({
            format: "jwk",
            key: jwk
        });
    }
    switch(jwk.kty){
        case "oct":
            {
                return (0,external_crypto_.createSecretKey)(decode(jwk.k));
            }
        case "RSA":
            {
                const enc = new DumbAsn1Encoder();
                const isPrivate = jwk.d !== undefined;
                const modulus = external_buffer_.Buffer.from(jwk.n, "base64");
                const exponent = external_buffer_.Buffer.from(jwk.e, "base64");
                if (isPrivate) {
                    enc.zero();
                    enc.unsignedInteger(modulus);
                    enc.unsignedInteger(exponent);
                    enc.unsignedInteger(external_buffer_.Buffer.from(jwk.d, "base64"));
                    enc.unsignedInteger(external_buffer_.Buffer.from(jwk.p, "base64"));
                    enc.unsignedInteger(external_buffer_.Buffer.from(jwk.q, "base64"));
                    enc.unsignedInteger(external_buffer_.Buffer.from(jwk.dp, "base64"));
                    enc.unsignedInteger(external_buffer_.Buffer.from(jwk.dq, "base64"));
                    enc.unsignedInteger(external_buffer_.Buffer.from(jwk.qi, "base64"));
                } else {
                    enc.unsignedInteger(modulus);
                    enc.unsignedInteger(exponent);
                }
                const der = enc.end();
                const createInput = {
                    key: der,
                    format: "der",
                    type: "pkcs1"
                };
                const keyObject = isPrivate ? (0,external_crypto_.createPrivateKey)(createInput) : (0,external_crypto_.createPublicKey)(createInput);
                setModulusLength(keyObject, modulus.length << 3);
                return keyObject;
            }
        case "EC":
            {
                const enc1 = new DumbAsn1Encoder();
                const isPrivate1 = jwk.d !== undefined;
                const pub = external_buffer_.Buffer.concat([
                    external_buffer_.Buffer.alloc(1, 4),
                    external_buffer_.Buffer.from(jwk.x, "base64"),
                    external_buffer_.Buffer.from(jwk.y, "base64")
                ]);
                if (isPrivate1) {
                    enc1.zero();
                    const enc$1 = new DumbAsn1Encoder();
                    enc$1.oidFor("ecPublicKey");
                    enc$1.oidFor(jwk.crv);
                    enc1.add(enc$1.end());
                    const enc$2 = new DumbAsn1Encoder();
                    enc$2.one();
                    enc$2.octStr(external_buffer_.Buffer.from(jwk.d, "base64"));
                    const enc$3 = new DumbAsn1Encoder();
                    enc$3.bitStr(pub);
                    const f2 = enc$3.end(external_buffer_.Buffer.from([
                        0xa1
                    ]));
                    enc$2.add(f2);
                    const f = enc$2.end();
                    const enc$4 = new DumbAsn1Encoder();
                    enc$4.add(f);
                    const f3 = enc$4.end(external_buffer_.Buffer.from([
                        0x04
                    ]));
                    enc1.add(f3);
                    const der1 = enc1.end();
                    const keyObject1 = (0,external_crypto_.createPrivateKey)({
                        key: der1,
                        format: "der",
                        type: "pkcs8"
                    });
                    setCurve(keyObject1, jwk.crv);
                    return keyObject1;
                }
                const enc$11 = new DumbAsn1Encoder();
                enc$11.oidFor("ecPublicKey");
                enc$11.oidFor(jwk.crv);
                enc1.add(enc$11.end());
                enc1.bitStr(pub);
                const der2 = enc1.end();
                const keyObject2 = (0,external_crypto_.createPublicKey)({
                    key: der2,
                    format: "der",
                    type: "spki"
                });
                setCurve(keyObject2, jwk.crv);
                return keyObject2;
            }
        case "OKP":
            {
                const enc2 = new DumbAsn1Encoder();
                const isPrivate2 = jwk.d !== undefined;
                if (isPrivate2) {
                    enc2.zero();
                    const enc$12 = new DumbAsn1Encoder();
                    enc$12.oidFor(jwk.crv);
                    enc2.add(enc$12.end());
                    const enc$21 = new DumbAsn1Encoder();
                    enc$21.octStr(external_buffer_.Buffer.from(jwk.d, "base64"));
                    const f1 = enc$21.end(external_buffer_.Buffer.from([
                        0x04
                    ]));
                    enc2.add(f1);
                    const der3 = enc2.end();
                    return (0,external_crypto_.createPrivateKey)({
                        key: der3,
                        format: "der",
                        type: "pkcs8"
                    });
                }
                const enc$13 = new DumbAsn1Encoder();
                enc$13.oidFor(jwk.crv);
                enc2.add(enc$13.end());
                enc2.bitStr(external_buffer_.Buffer.from(jwk.x, "base64"));
                const der4 = enc2.end();
                return (0,external_crypto_.createPublicKey)({
                    key: der4,
                    format: "der",
                    type: "spki"
                });
            }
        default:
            throw new JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
    }
};
/* harmony default export */ const jwk_to_key = (parse);

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/lib/format_pem.js
/* harmony default export */ const format_pem = ((b64, descriptor)=>{
    const newlined = (b64.match(/.{1,64}/g) || []).join("\n");
    return `-----BEGIN ${descriptor}-----\n${newlined}\n-----END ${descriptor}-----`;
});

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/key/import.js







function getElement(seq) {
    let result = [];
    let next = 0;
    while(next < seq.length){
        let nextPart = parseElement(seq.subarray(next));
        result.push(nextPart);
        next += nextPart.byteLength;
    }
    return result;
}
function parseElement(bytes) {
    let position = 0;
    let tag = bytes[0] & 0x1f;
    position++;
    if (tag === 0x1f) {
        tag = 0;
        while(bytes[position] >= 0x80){
            tag = tag * 128 + bytes[position] - 0x80;
            position++;
        }
        tag = tag * 128 + bytes[position] - 0x80;
        position++;
    }
    let length = 0;
    if (bytes[position] < 0x80) {
        length = bytes[position];
        position++;
    } else if (length === 0x80) {
        length = 0;
        while(bytes[position + length] !== 0 || bytes[position + length + 1] !== 0){
            if (length > bytes.byteLength) {
                throw new TypeError("invalid indefinite form length");
            }
            length++;
        }
        const byteLength = position + length + 2;
        return {
            byteLength,
            contents: bytes.subarray(position, position + length),
            raw: bytes.subarray(0, byteLength)
        };
    } else {
        let numberOfDigits = bytes[position] & 0x7f;
        position++;
        length = 0;
        for(let i = 0; i < numberOfDigits; i++){
            length = length * 256 + bytes[position];
            position++;
        }
    }
    const byteLength1 = position + length;
    return {
        byteLength: byteLength1,
        contents: bytes.subarray(position, byteLength1),
        raw: bytes.subarray(0, byteLength1)
    };
}
function spkiFromX509(buf) {
    const tbsCertificate = getElement(getElement(parseElement(buf).contents)[0].contents);
    return encodeBase64(tbsCertificate[tbsCertificate[0].raw[0] === 0xa0 ? 6 : 5].raw);
}
function getSPKI(x509) {
    const pem = x509.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\s)/g, "");
    const raw = decodeBase64(pem);
    return format_pem(spkiFromX509(raw), "PUBLIC KEY");
}
async function importSPKI(spki, alg, options) {
    if (typeof spki !== "string" || spki.indexOf("-----BEGIN PUBLIC KEY-----") !== 0) {
        throw new TypeError('"spki" must be SPKI formatted string');
    }
    return fromSPKI(spki, alg, options);
}
async function importX509(x509, alg, options) {
    if (typeof x509 !== "string" || x509.indexOf("-----BEGIN CERTIFICATE-----") !== 0) {
        throw new TypeError('"x509" must be X.509 formatted string');
    }
    let spki;
    try {
        spki = getSPKI(x509);
    } catch (cause) {
        throw new TypeError("failed to parse the X.509 certificate", {
            cause
        });
    }
    return fromSPKI(spki, alg, options);
}
async function importPKCS8(pkcs8, alg, options) {
    if (typeof pkcs8 !== "string" || pkcs8.indexOf("-----BEGIN PRIVATE KEY-----") !== 0) {
        throw new TypeError('"pkcs8" must be PKCS#8 formatted string');
    }
    return fromPKCS8(pkcs8, alg, options);
}
async function importJWK(jwk, alg, octAsKeyObject) {
    var _a;
    if (!isObject(jwk)) {
        throw new TypeError("JWK must be an object");
    }
    alg || (alg = jwk.alg);
    if (typeof alg !== "string" || !alg) {
        throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
    }
    switch(jwk.kty){
        case "oct":
            if (typeof jwk.k !== "string" || !jwk.k) {
                throw new TypeError('missing "k" (Key Value) Parameter value');
            }
            octAsKeyObject !== null && octAsKeyObject !== void 0 ? octAsKeyObject : octAsKeyObject = jwk.ext !== true;
            if (octAsKeyObject) {
                return jwk_to_key({
                    ...jwk,
                    alg,
                    ext: (_a = jwk.ext) !== null && _a !== void 0 ? _a : false
                });
            }
            return decode(jwk.k);
        case "RSA":
            if (jwk.oth !== undefined) {
                throw new JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');
            }
        case "EC":
        case "OKP":
            return jwk_to_key({
                ...jwk,
                alg
            });
        default:
            throw new JOSENotSupported('Unsupported "kty" (Key Type) Parameter value');
    }
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/lib/check_key_type.js


const symmetricTypeCheck = (alg, key)=>{
    if (key instanceof Uint8Array) return;
    if (!is_key_like(key)) {
        throw new TypeError(withAlg(alg, key, ...types, "Uint8Array"));
    }
    if (key.type !== "secret") {
        throw new TypeError(`${types.join(" or ")} instances for symmetric algorithms must be of type "secret"`);
    }
};
const asymmetricTypeCheck = (alg, key, usage)=>{
    if (!is_key_like(key)) {
        throw new TypeError(withAlg(alg, key, ...types));
    }
    if (key.type === "secret") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);
    }
    if (usage === "sign" && key.type === "public") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);
    }
    if (usage === "decrypt" && key.type === "public") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);
    }
    if (key.algorithm && usage === "verify" && key.type === "private") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);
    }
    if (key.algorithm && usage === "encrypt" && key.type === "private") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`);
    }
};
const checkKeyType = (alg, key, usage)=>{
    const symmetric = alg.startsWith("HS") || alg === "dir" || alg.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(alg);
    if (symmetric) {
        symmetricTypeCheck(alg, key);
    } else {
        asymmetricTypeCheck(alg, key, usage);
    }
};
/* harmony default export */ const check_key_type = (checkKeyType);

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/runtime/encrypt.js












function cbcEncrypt(enc, plaintext, cek, iv, aad) {
    const keySize = parseInt(enc.slice(1, 4), 10);
    if (is_key_object(cek)) {
        cek = cek.export();
    }
    const encKey = cek.subarray(keySize >> 3);
    const macKey = cek.subarray(0, keySize >> 3);
    const algorithm = `aes-${keySize}-cbc`;
    if (!runtime_ciphers(algorithm)) {
        throw new JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);
    }
    const cipher = (0,external_crypto_.createCipheriv)(algorithm, encKey, iv);
    const ciphertext = concat(cipher.update(plaintext), cipher.final());
    const macSize = parseInt(enc.slice(-3), 10);
    const tag = cbcTag(aad, iv, ciphertext, macSize, macKey, keySize);
    return {
        ciphertext,
        tag
    };
}
function gcmEncrypt(enc, plaintext, cek, iv, aad) {
    const keySize = parseInt(enc.slice(1, 4), 10);
    const algorithm = `aes-${keySize}-gcm`;
    if (!runtime_ciphers(algorithm)) {
        throw new JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);
    }
    const cipher = (0,external_crypto_.createCipheriv)(algorithm, cek, iv, {
        authTagLength: 16
    });
    if (aad.byteLength) {
        cipher.setAAD(aad, {
            plaintextLength: plaintext.length
        });
    }
    const ciphertext = cipher.update(plaintext);
    cipher.final();
    const tag = cipher.getAuthTag();
    return {
        ciphertext,
        tag
    };
}
const encrypt_encrypt = (enc, plaintext, cek, iv, aad)=>{
    let key;
    if (isCryptoKey(cek)) {
        checkEncCryptoKey(cek, enc, "encrypt");
        key = external_crypto_.KeyObject.from(cek);
    } else if (cek instanceof Uint8Array || is_key_object(cek)) {
        key = cek;
    } else {
        throw new TypeError(invalid_key_input(cek, ...types, "Uint8Array"));
    }
    check_cek_length(enc, key);
    check_iv_length(enc, iv);
    switch(enc){
        case "A128CBC-HS256":
        case "A192CBC-HS384":
        case "A256CBC-HS512":
            return cbcEncrypt(enc, plaintext, key, iv, aad);
        case "A128GCM":
        case "A192GCM":
        case "A256GCM":
            return gcmEncrypt(enc, plaintext, key, iv, aad);
        default:
            throw new JOSENotSupported("Unsupported JWE Content Encryption Algorithm");
    }
};
/* harmony default export */ const runtime_encrypt = (encrypt_encrypt);

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/lib/aesgcmkw.js




async function aesgcmkw_wrap(alg, key, cek, iv) {
    const jweAlgorithm = alg.slice(0, 7);
    iv || (iv = lib_iv(jweAlgorithm));
    const { ciphertext: encryptedKey , tag  } = await runtime_encrypt(jweAlgorithm, cek, key, iv, new Uint8Array(0));
    return {
        encryptedKey,
        iv: encode(iv),
        tag: encode(tag)
    };
}
async function aesgcmkw_unwrap(alg, key, encryptedKey, iv, tag) {
    const jweAlgorithm = alg.slice(0, 7);
    return runtime_decrypt(jweAlgorithm, key, encryptedKey, iv, tag, new Uint8Array(0));
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/lib/decrypt_key_management.js











async function decryptKeyManagement(alg, key, encryptedKey, joseHeader, options) {
    check_key_type(alg, key, "decrypt");
    switch(alg){
        case "dir":
            {
                if (encryptedKey !== undefined) throw new JWEInvalid("Encountered unexpected JWE Encrypted Key");
                return key;
            }
        case "ECDH-ES":
            if (encryptedKey !== undefined) throw new JWEInvalid("Encountered unexpected JWE Encrypted Key");
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
            {
                if (!isObject(joseHeader.epk)) throw new JWEInvalid(`JOSE Header "epk" (Ephemeral Public Key) missing or invalid`);
                if (!ecdhAllowed(key)) throw new JOSENotSupported("ECDH with the provided key is not allowed or not supported by your javascript runtime");
                const epk = await importJWK(joseHeader.epk, alg);
                let partyUInfo;
                let partyVInfo;
                if (joseHeader.apu !== undefined) {
                    if (typeof joseHeader.apu !== "string") throw new JWEInvalid(`JOSE Header "apu" (Agreement PartyUInfo) invalid`);
                    partyUInfo = decode(joseHeader.apu);
                }
                if (joseHeader.apv !== undefined) {
                    if (typeof joseHeader.apv !== "string") throw new JWEInvalid(`JOSE Header "apv" (Agreement PartyVInfo) invalid`);
                    partyVInfo = decode(joseHeader.apv);
                }
                const sharedSecret = await deriveKey(epk, key, alg === "ECDH-ES" ? joseHeader.enc : alg, alg === "ECDH-ES" ? cek_bitLength(joseHeader.enc) : parseInt(alg.slice(-5, -2), 10), partyUInfo, partyVInfo);
                if (alg === "ECDH-ES") return sharedSecret;
                if (encryptedKey === undefined) throw new JWEInvalid("JWE Encrypted Key missing");
                return unwrap(alg.slice(-6), sharedSecret, encryptedKey);
            }
        case "RSA1_5":
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
            {
                if (encryptedKey === undefined) throw new JWEInvalid("JWE Encrypted Key missing");
                return rsaes_decrypt(alg, key, encryptedKey);
            }
        case "PBES2-HS256+A128KW":
        case "PBES2-HS384+A192KW":
        case "PBES2-HS512+A256KW":
            {
                if (encryptedKey === undefined) throw new JWEInvalid("JWE Encrypted Key missing");
                if (typeof joseHeader.p2c !== "number") throw new JWEInvalid(`JOSE Header "p2c" (PBES2 Count) missing or invalid`);
                const p2cLimit = (options === null || options === void 0 ? void 0 : options.maxPBES2Count) || 10000;
                if (joseHeader.p2c > p2cLimit) throw new JWEInvalid(`JOSE Header "p2c" (PBES2 Count) out is of acceptable bounds`);
                if (typeof joseHeader.p2s !== "string") throw new JWEInvalid(`JOSE Header "p2s" (PBES2 Salt) missing or invalid`);
                return pbes2kw_decrypt(alg, key, encryptedKey, joseHeader.p2c, decode(joseHeader.p2s));
            }
        case "A128KW":
        case "A192KW":
        case "A256KW":
            {
                if (encryptedKey === undefined) throw new JWEInvalid("JWE Encrypted Key missing");
                return unwrap(alg, key, encryptedKey);
            }
        case "A128GCMKW":
        case "A192GCMKW":
        case "A256GCMKW":
            {
                if (encryptedKey === undefined) throw new JWEInvalid("JWE Encrypted Key missing");
                if (typeof joseHeader.iv !== "string") throw new JWEInvalid(`JOSE Header "iv" (Initialization Vector) missing or invalid`);
                if (typeof joseHeader.tag !== "string") throw new JWEInvalid(`JOSE Header "tag" (Authentication Tag) missing or invalid`);
                const iv = decode(joseHeader.iv);
                const tag = decode(joseHeader.tag);
                return aesgcmkw_unwrap(alg, key, encryptedKey, iv, tag);
            }
        default:
            {
                throw new JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value');
            }
    }
}
/* harmony default export */ const decrypt_key_management = (decryptKeyManagement);

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/lib/validate_crit.js

function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
    if (joseHeader.crit !== undefined && protectedHeader.crit === undefined) {
        throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
    }
    if (!protectedHeader || protectedHeader.crit === undefined) {
        return new Set();
    }
    if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input)=>typeof input !== "string" || input.length === 0)) {
        throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
    }
    let recognized;
    if (recognizedOption !== undefined) {
        recognized = new Map([
            ...Object.entries(recognizedOption),
            ...recognizedDefault.entries()
        ]);
    } else {
        recognized = recognizedDefault;
    }
    for (const parameter of protectedHeader.crit){
        if (!recognized.has(parameter)) {
            throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
        }
        if (joseHeader[parameter] === undefined) {
            throw new Err(`Extension Header Parameter "${parameter}" is missing`);
        } else if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {
            throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
        }
    }
    return new Set(protectedHeader.crit);
}
/* harmony default export */ const validate_crit = (validateCrit);

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/lib/validate_algorithms.js
const validateAlgorithms = (option, algorithms)=>{
    if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some((s)=>typeof s !== "string"))) {
        throw new TypeError(`"${option}" option must be an array of strings`);
    }
    if (!algorithms) {
        return undefined;
    }
    return new Set(algorithms);
};
/* harmony default export */ const validate_algorithms = (validateAlgorithms);

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/jwe/flattened/decrypt.js











async function flattenedDecrypt(jwe, key, options) {
    var _a;
    if (!isObject(jwe)) {
        throw new JWEInvalid("Flattened JWE must be an object");
    }
    if (jwe.protected === undefined && jwe.header === undefined && jwe.unprotected === undefined) {
        throw new JWEInvalid("JOSE Header missing");
    }
    if (typeof jwe.iv !== "string") {
        throw new JWEInvalid("JWE Initialization Vector missing or incorrect type");
    }
    if (typeof jwe.ciphertext !== "string") {
        throw new JWEInvalid("JWE Ciphertext missing or incorrect type");
    }
    if (typeof jwe.tag !== "string") {
        throw new JWEInvalid("JWE Authentication Tag missing or incorrect type");
    }
    if (jwe.protected !== undefined && typeof jwe.protected !== "string") {
        throw new JWEInvalid("JWE Protected Header incorrect type");
    }
    if (jwe.encrypted_key !== undefined && typeof jwe.encrypted_key !== "string") {
        throw new JWEInvalid("JWE Encrypted Key incorrect type");
    }
    if (jwe.aad !== undefined && typeof jwe.aad !== "string") {
        throw new JWEInvalid("JWE AAD incorrect type");
    }
    if (jwe.header !== undefined && !isObject(jwe.header)) {
        throw new JWEInvalid("JWE Shared Unprotected Header incorrect type");
    }
    if (jwe.unprotected !== undefined && !isObject(jwe.unprotected)) {
        throw new JWEInvalid("JWE Per-Recipient Unprotected Header incorrect type");
    }
    let parsedProt;
    if (jwe.protected) {
        try {
            const protectedHeader = decode(jwe.protected);
            parsedProt = JSON.parse(decoder.decode(protectedHeader));
        } catch  {
            throw new JWEInvalid("JWE Protected Header is invalid");
        }
    }
    if (!is_disjoint(parsedProt, jwe.header, jwe.unprotected)) {
        throw new JWEInvalid("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");
    }
    const joseHeader = {
        ...parsedProt,
        ...jwe.header,
        ...jwe.unprotected
    };
    validate_crit(JWEInvalid, new Map(), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
    if (joseHeader.zip !== undefined) {
        if (!parsedProt || !parsedProt.zip) {
            throw new JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
        }
        if (joseHeader.zip !== "DEF") {
            throw new JOSENotSupported('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value');
        }
    }
    const { alg , enc  } = joseHeader;
    if (typeof alg !== "string" || !alg) {
        throw new JWEInvalid("missing JWE Algorithm (alg) in JWE Header");
    }
    if (typeof enc !== "string" || !enc) {
        throw new JWEInvalid("missing JWE Encryption Algorithm (enc) in JWE Header");
    }
    const keyManagementAlgorithms = options && validate_algorithms("keyManagementAlgorithms", options.keyManagementAlgorithms);
    const contentEncryptionAlgorithms = options && validate_algorithms("contentEncryptionAlgorithms", options.contentEncryptionAlgorithms);
    if (keyManagementAlgorithms && !keyManagementAlgorithms.has(alg)) {
        throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
    }
    if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) {
        throw new JOSEAlgNotAllowed('"enc" (Encryption Algorithm) Header Parameter not allowed');
    }
    let encryptedKey;
    if (jwe.encrypted_key !== undefined) {
        encryptedKey = decode(jwe.encrypted_key);
    }
    let resolvedKey = false;
    if (typeof key === "function") {
        key = await key(parsedProt, jwe);
        resolvedKey = true;
    }
    let cek;
    try {
        cek = await decrypt_key_management(alg, key, encryptedKey, joseHeader, options);
    } catch (err) {
        if (err instanceof TypeError || err instanceof JWEInvalid || err instanceof JOSENotSupported) {
            throw err;
        }
        cek = lib_cek(enc);
    }
    const iv = decode(jwe.iv);
    const tag = decode(jwe.tag);
    const protectedHeader1 = encoder.encode((_a = jwe.protected) !== null && _a !== void 0 ? _a : "");
    let additionalData;
    if (jwe.aad !== undefined) {
        additionalData = concat(protectedHeader1, encoder.encode("."), encoder.encode(jwe.aad));
    } else {
        additionalData = protectedHeader1;
    }
    let plaintext = await runtime_decrypt(enc, cek, decode(jwe.ciphertext), iv, tag, additionalData);
    if (joseHeader.zip === "DEF") {
        plaintext = await ((options === null || options === void 0 ? void 0 : options.inflateRaw) || inflate)(plaintext);
    }
    const result = {
        plaintext
    };
    if (jwe.protected !== undefined) {
        result.protectedHeader = parsedProt;
    }
    if (jwe.aad !== undefined) {
        result.additionalAuthenticatedData = decode(jwe.aad);
    }
    if (jwe.unprotected !== undefined) {
        result.sharedUnprotectedHeader = jwe.unprotected;
    }
    if (jwe.header !== undefined) {
        result.unprotectedHeader = jwe.header;
    }
    if (resolvedKey) {
        return {
            ...result,
            key
        };
    }
    return result;
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/jwe/compact/decrypt.js



async function compactDecrypt(jwe, key, options) {
    if (jwe instanceof Uint8Array) {
        jwe = decoder.decode(jwe);
    }
    if (typeof jwe !== "string") {
        throw new JWEInvalid("Compact JWE must be a string or Uint8Array");
    }
    const { 0: protectedHeader , 1: encryptedKey , 2: iv , 3: ciphertext , 4: tag , length  } = jwe.split(".");
    if (length !== 5) {
        throw new JWEInvalid("Invalid Compact JWE");
    }
    const decrypted = await flattenedDecrypt({
        ciphertext,
        iv: iv || undefined,
        protected: protectedHeader || undefined,
        tag: tag || undefined,
        encrypted_key: encryptedKey || undefined
    }, key, options);
    const result = {
        plaintext: decrypted.plaintext,
        protectedHeader: decrypted.protectedHeader
    };
    if (typeof key === "function") {
        return {
            ...result,
            key: decrypted.key
        };
    }
    return result;
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/jwe/general/decrypt.js



async function generalDecrypt(jwe, key, options) {
    if (!isObject(jwe)) {
        throw new JWEInvalid("General JWE must be an object");
    }
    if (!Array.isArray(jwe.recipients) || !jwe.recipients.every(isObject)) {
        throw new JWEInvalid("JWE Recipients missing or incorrect type");
    }
    if (!jwe.recipients.length) {
        throw new JWEInvalid("JWE Recipients has no members");
    }
    for (const recipient of jwe.recipients){
        try {
            return await flattenedDecrypt({
                aad: jwe.aad,
                ciphertext: jwe.ciphertext,
                encrypted_key: recipient.encrypted_key,
                header: recipient.header,
                iv: jwe.iv,
                protected: jwe.protected,
                tag: jwe.tag,
                unprotected: jwe.unprotected
            }, key, options);
        } catch  {}
    }
    throw new JWEDecryptionFailed();
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/runtime/asn1_sequence_decoder.js
const asn1_sequence_decoder_tagInteger = 0x02;
const asn1_sequence_decoder_tagSequence = 0x30;
class Asn1SequenceDecoder {
    constructor(buffer){
        if (buffer[0] !== asn1_sequence_decoder_tagSequence) {
            throw new TypeError();
        }
        this.buffer = buffer;
        this.offset = 1;
        const len = this.decodeLength();
        if (len !== buffer.length - this.offset) {
            throw new TypeError();
        }
    }
    decodeLength() {
        let length = this.buffer[this.offset++];
        if (length & 0x80) {
            const nBytes = length & ~0x80;
            length = 0;
            for(let i = 0; i < nBytes; i++)length = length << 8 | this.buffer[this.offset + i];
            this.offset += nBytes;
        }
        return length;
    }
    unsignedInteger() {
        if (this.buffer[this.offset++] !== asn1_sequence_decoder_tagInteger) {
            throw new TypeError();
        }
        let length = this.decodeLength();
        if (this.buffer[this.offset] === 0) {
            this.offset++;
            length--;
        }
        const result = this.buffer.slice(this.offset, this.offset + length);
        this.offset += length;
        return result;
    }
    end() {
        if (this.offset !== this.buffer.length) {
            throw new TypeError();
        }
    }
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/runtime/key_to_jwk.js









const [key_to_jwk_major, key_to_jwk_minor] = process.version.slice(1).split(".").map((str)=>parseInt(str, 10));
const jwkExportSupported = key_to_jwk_major >= 16 || key_to_jwk_major === 15 && key_to_jwk_minor >= 9;
const keyToJWK = (key)=>{
    let keyObject;
    if (isCryptoKey(key)) {
        if (!key.extractable) {
            throw new TypeError("CryptoKey is not extractable");
        }
        keyObject = external_crypto_.KeyObject.from(key);
    } else if (is_key_object(key)) {
        keyObject = key;
    } else if (key instanceof Uint8Array) {
        return {
            kty: "oct",
            k: encode(key)
        };
    } else {
        throw new TypeError(invalid_key_input(key, ...types, "Uint8Array"));
    }
    if (jwkExportSupported) {
        if (keyObject.type !== "secret" && ![
            "rsa",
            "ec",
            "ed25519",
            "x25519",
            "ed448",
            "x448"
        ].includes(keyObject.asymmetricKeyType)) {
            throw new JOSENotSupported("Unsupported key asymmetricKeyType");
        }
        return keyObject.export({
            format: "jwk"
        });
    }
    switch(keyObject.type){
        case "secret":
            return {
                kty: "oct",
                k: encode(keyObject.export())
            };
        case "private":
        case "public":
            {
                switch(keyObject.asymmetricKeyType){
                    case "rsa":
                        {
                            const der = keyObject.export({
                                format: "der",
                                type: "pkcs1"
                            });
                            const dec = new Asn1SequenceDecoder(der);
                            if (keyObject.type === "private") {
                                dec.unsignedInteger();
                            }
                            const n = encode(dec.unsignedInteger());
                            const e = encode(dec.unsignedInteger());
                            let jwk;
                            if (keyObject.type === "private") {
                                jwk = {
                                    d: encode(dec.unsignedInteger()),
                                    p: encode(dec.unsignedInteger()),
                                    q: encode(dec.unsignedInteger()),
                                    dp: encode(dec.unsignedInteger()),
                                    dq: encode(dec.unsignedInteger()),
                                    qi: encode(dec.unsignedInteger())
                                };
                            }
                            dec.end();
                            return {
                                kty: "RSA",
                                n,
                                e,
                                ...jwk
                            };
                        }
                    case "ec":
                        {
                            const crv = get_named_curve(keyObject);
                            let len;
                            let offset;
                            let correction;
                            switch(crv){
                                case "secp256k1":
                                    len = 64;
                                    offset = 31 + 2;
                                    correction = -1;
                                    break;
                                case "P-256":
                                    len = 64;
                                    offset = 34 + 2;
                                    correction = -1;
                                    break;
                                case "P-384":
                                    len = 96;
                                    offset = 33 + 2;
                                    correction = -3;
                                    break;
                                case "P-521":
                                    len = 132;
                                    offset = 33 + 2;
                                    correction = -3;
                                    break;
                                default:
                                    throw new JOSENotSupported("Unsupported curve");
                            }
                            if (keyObject.type === "public") {
                                const der1 = keyObject.export({
                                    type: "spki",
                                    format: "der"
                                });
                                return {
                                    kty: "EC",
                                    crv,
                                    x: encode(der1.subarray(-len, -len / 2)),
                                    y: encode(der1.subarray(-len / 2))
                                };
                            }
                            const der2 = keyObject.export({
                                type: "pkcs8",
                                format: "der"
                            });
                            if (der2.length < 100) {
                                offset += correction;
                            }
                            return {
                                ...keyToJWK((0,external_crypto_.createPublicKey)(keyObject)),
                                d: encode(der2.subarray(offset, offset + len / 2))
                            };
                        }
                    case "ed25519":
                    case "x25519":
                        {
                            const crv1 = get_named_curve(keyObject);
                            if (keyObject.type === "public") {
                                const der3 = keyObject.export({
                                    type: "spki",
                                    format: "der"
                                });
                                return {
                                    kty: "OKP",
                                    crv: crv1,
                                    x: encode(der3.subarray(-32))
                                };
                            }
                            const der4 = keyObject.export({
                                type: "pkcs8",
                                format: "der"
                            });
                            return {
                                ...keyToJWK((0,external_crypto_.createPublicKey)(keyObject)),
                                d: encode(der4.subarray(-32))
                            };
                        }
                    case "ed448":
                    case "x448":
                        {
                            const crv2 = get_named_curve(keyObject);
                            if (keyObject.type === "public") {
                                const der5 = keyObject.export({
                                    type: "spki",
                                    format: "der"
                                });
                                return {
                                    kty: "OKP",
                                    crv: crv2,
                                    x: encode(der5.subarray(crv2 === "Ed448" ? -57 : -56))
                                };
                            }
                            const der6 = keyObject.export({
                                type: "pkcs8",
                                format: "der"
                            });
                            return {
                                ...keyToJWK((0,external_crypto_.createPublicKey)(keyObject)),
                                d: encode(der6.subarray(crv2 === "Ed448" ? -57 : -56))
                            };
                        }
                    default:
                        throw new JOSENotSupported("Unsupported key asymmetricKeyType");
                }
            }
        default:
            throw new JOSENotSupported("Unsupported key type");
    }
};
/* harmony default export */ const key_to_jwk = (keyToJWK);

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/key/export.js



async function exportSPKI(key) {
    return toSPKI(key);
}
async function exportPKCS8(key) {
    return toPKCS8(key);
}
async function exportJWK(key) {
    return key_to_jwk(key);
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/lib/encrypt_key_management.js










async function encryptKeyManagement(alg, enc, key, providedCek, providedParameters = {}) {
    let encryptedKey;
    let parameters;
    let cek;
    check_key_type(alg, key, "encrypt");
    switch(alg){
        case "dir":
            {
                cek = key;
                break;
            }
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
            {
                if (!ecdhAllowed(key)) {
                    throw new JOSENotSupported("ECDH with the provided key is not allowed or not supported by your javascript runtime");
                }
                const { apu , apv  } = providedParameters;
                let { epk: ephemeralKey  } = providedParameters;
                ephemeralKey || (ephemeralKey = (await generateEpk(key)).privateKey);
                const { x , y , crv , kty  } = await exportJWK(ephemeralKey);
                const sharedSecret = await deriveKey(key, ephemeralKey, alg === "ECDH-ES" ? enc : alg, alg === "ECDH-ES" ? cek_bitLength(enc) : parseInt(alg.slice(-5, -2), 10), apu, apv);
                parameters = {
                    epk: {
                        x,
                        crv,
                        kty
                    }
                };
                if (kty === "EC") parameters.epk.y = y;
                if (apu) parameters.apu = encode(apu);
                if (apv) parameters.apv = encode(apv);
                if (alg === "ECDH-ES") {
                    cek = sharedSecret;
                    break;
                }
                cek = providedCek || lib_cek(enc);
                const kwAlg = alg.slice(-6);
                encryptedKey = await wrap(kwAlg, sharedSecret, cek);
                break;
            }
        case "RSA1_5":
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
            {
                cek = providedCek || lib_cek(enc);
                encryptedKey = await rsaes_encrypt(alg, key, cek);
                break;
            }
        case "PBES2-HS256+A128KW":
        case "PBES2-HS384+A192KW":
        case "PBES2-HS512+A256KW":
            {
                cek = providedCek || lib_cek(enc);
                const { p2c , p2s  } = providedParameters;
                ({ encryptedKey , ...parameters } = await encrypt(alg, key, cek, p2c, p2s));
                break;
            }
        case "A128KW":
        case "A192KW":
        case "A256KW":
            {
                cek = providedCek || lib_cek(enc);
                encryptedKey = await wrap(alg, key, cek);
                break;
            }
        case "A128GCMKW":
        case "A192GCMKW":
        case "A256GCMKW":
            {
                cek = providedCek || lib_cek(enc);
                const { iv  } = providedParameters;
                ({ encryptedKey , ...parameters } = await aesgcmkw_wrap(alg, key, cek, iv));
                break;
            }
        default:
            {
                throw new JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value');
            }
    }
    return {
        cek,
        encryptedKey,
        parameters
    };
}
/* harmony default export */ const encrypt_key_management = (encryptKeyManagement);

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/jwe/flattened/encrypt.js









const unprotected = Symbol();
class FlattenedEncrypt {
    constructor(plaintext){
        if (!(plaintext instanceof Uint8Array)) {
            throw new TypeError("plaintext must be an instance of Uint8Array");
        }
        this._plaintext = plaintext;
    }
    setKeyManagementParameters(parameters) {
        if (this._keyManagementParameters) {
            throw new TypeError("setKeyManagementParameters can only be called once");
        }
        this._keyManagementParameters = parameters;
        return this;
    }
    setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
            throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
    }
    setSharedUnprotectedHeader(sharedUnprotectedHeader) {
        if (this._sharedUnprotectedHeader) {
            throw new TypeError("setSharedUnprotectedHeader can only be called once");
        }
        this._sharedUnprotectedHeader = sharedUnprotectedHeader;
        return this;
    }
    setUnprotectedHeader(unprotectedHeader) {
        if (this._unprotectedHeader) {
            throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this._unprotectedHeader = unprotectedHeader;
        return this;
    }
    setAdditionalAuthenticatedData(aad) {
        this._aad = aad;
        return this;
    }
    setContentEncryptionKey(cek) {
        if (this._cek) {
            throw new TypeError("setContentEncryptionKey can only be called once");
        }
        this._cek = cek;
        return this;
    }
    setInitializationVector(iv) {
        if (this._iv) {
            throw new TypeError("setInitializationVector can only be called once");
        }
        this._iv = iv;
        return this;
    }
    async encrypt(key, options) {
        if (!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader) {
            throw new JWEInvalid("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");
        }
        if (!is_disjoint(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader)) {
            throw new JWEInvalid("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");
        }
        const joseHeader = {
            ...this._protectedHeader,
            ...this._unprotectedHeader,
            ...this._sharedUnprotectedHeader
        };
        validate_crit(JWEInvalid, new Map(), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);
        if (joseHeader.zip !== undefined) {
            if (!this._protectedHeader || !this._protectedHeader.zip) {
                throw new JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
            }
            if (joseHeader.zip !== "DEF") {
                throw new JOSENotSupported('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value');
            }
        }
        const { alg , enc  } = joseHeader;
        if (typeof alg !== "string" || !alg) {
            throw new JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');
        }
        if (typeof enc !== "string" || !enc) {
            throw new JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
        }
        let encryptedKey;
        if (alg === "dir") {
            if (this._cek) {
                throw new TypeError("setContentEncryptionKey cannot be called when using Direct Encryption");
            }
        } else if (alg === "ECDH-ES") {
            if (this._cek) {
                throw new TypeError("setContentEncryptionKey cannot be called when using Direct Key Agreement");
            }
        }
        let cek;
        {
            let parameters;
            ({ cek , encryptedKey , parameters  } = await encrypt_key_management(alg, enc, key, this._cek, this._keyManagementParameters));
            if (parameters) {
                if (options && unprotected in options) {
                    if (!this._unprotectedHeader) {
                        this.setUnprotectedHeader(parameters);
                    } else {
                        this._unprotectedHeader = {
                            ...this._unprotectedHeader,
                            ...parameters
                        };
                    }
                } else {
                    if (!this._protectedHeader) {
                        this.setProtectedHeader(parameters);
                    } else {
                        this._protectedHeader = {
                            ...this._protectedHeader,
                            ...parameters
                        };
                    }
                }
            }
        }
        this._iv || (this._iv = lib_iv(enc));
        let additionalData;
        let protectedHeader;
        let aadMember;
        if (this._protectedHeader) {
            protectedHeader = encoder.encode(encode(JSON.stringify(this._protectedHeader)));
        } else {
            protectedHeader = encoder.encode("");
        }
        if (this._aad) {
            aadMember = encode(this._aad);
            additionalData = concat(protectedHeader, encoder.encode("."), encoder.encode(aadMember));
        } else {
            additionalData = protectedHeader;
        }
        let ciphertext;
        let tag;
        if (joseHeader.zip === "DEF") {
            const deflated = await ((options === null || options === void 0 ? void 0 : options.deflateRaw) || deflate)(this._plaintext);
            ({ ciphertext , tag  } = await runtime_encrypt(enc, deflated, cek, this._iv, additionalData));
        } else {
            ;
            ({ ciphertext , tag  } = await runtime_encrypt(enc, this._plaintext, cek, this._iv, additionalData));
        }
        const jwe = {
            ciphertext: encode(ciphertext),
            iv: encode(this._iv),
            tag: encode(tag)
        };
        if (encryptedKey) {
            jwe.encrypted_key = encode(encryptedKey);
        }
        if (aadMember) {
            jwe.aad = aadMember;
        }
        if (this._protectedHeader) {
            jwe.protected = decoder.decode(protectedHeader);
        }
        if (this._sharedUnprotectedHeader) {
            jwe.unprotected = this._sharedUnprotectedHeader;
        }
        if (this._unprotectedHeader) {
            jwe.header = this._unprotectedHeader;
        }
        return jwe;
    }
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/jwe/general/encrypt.js







class IndividualRecipient {
    constructor(enc, key, options){
        this.parent = enc;
        this.key = key;
        this.options = options;
    }
    setUnprotectedHeader(unprotectedHeader) {
        if (this.unprotectedHeader) {
            throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this.unprotectedHeader = unprotectedHeader;
        return this;
    }
    addRecipient(...args) {
        return this.parent.addRecipient(...args);
    }
    encrypt(...args) {
        return this.parent.encrypt(...args);
    }
    done() {
        return this.parent;
    }
}
class GeneralEncrypt {
    constructor(plaintext){
        this._recipients = [];
        this._plaintext = plaintext;
    }
    addRecipient(key, options) {
        const recipient = new IndividualRecipient(this, key, {
            crit: options === null || options === void 0 ? void 0 : options.crit
        });
        this._recipients.push(recipient);
        return recipient;
    }
    setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
            throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
    }
    setSharedUnprotectedHeader(sharedUnprotectedHeader) {
        if (this._unprotectedHeader) {
            throw new TypeError("setSharedUnprotectedHeader can only be called once");
        }
        this._unprotectedHeader = sharedUnprotectedHeader;
        return this;
    }
    setAdditionalAuthenticatedData(aad) {
        this._aad = aad;
        return this;
    }
    async encrypt(options) {
        var _a, _b, _c;
        if (!this._recipients.length) {
            throw new JWEInvalid("at least one recipient must be added");
        }
        options = {
            deflateRaw: options === null || options === void 0 ? void 0 : options.deflateRaw
        };
        if (this._recipients.length === 1) {
            const [recipient] = this._recipients;
            const flattened = await new FlattenedEncrypt(this._plaintext).setAdditionalAuthenticatedData(this._aad).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(recipient.unprotectedHeader).encrypt(recipient.key, {
                ...recipient.options,
                ...options
            });
            let jwe = {
                ciphertext: flattened.ciphertext,
                iv: flattened.iv,
                recipients: [
                    {}
                ],
                tag: flattened.tag
            };
            if (flattened.aad) jwe.aad = flattened.aad;
            if (flattened.protected) jwe.protected = flattened.protected;
            if (flattened.unprotected) jwe.unprotected = flattened.unprotected;
            if (flattened.encrypted_key) jwe.recipients[0].encrypted_key = flattened.encrypted_key;
            if (flattened.header) jwe.recipients[0].header = flattened.header;
            return jwe;
        }
        let enc;
        for(let i = 0; i < this._recipients.length; i++){
            const recipient1 = this._recipients[i];
            if (!is_disjoint(this._protectedHeader, this._unprotectedHeader, recipient1.unprotectedHeader)) {
                throw new JWEInvalid("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");
            }
            const joseHeader = {
                ...this._protectedHeader,
                ...this._unprotectedHeader,
                ...recipient1.unprotectedHeader
            };
            const { alg  } = joseHeader;
            if (typeof alg !== "string" || !alg) {
                throw new JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');
            }
            if (alg === "dir" || alg === "ECDH-ES") {
                throw new JWEInvalid('"dir" and "ECDH-ES" alg may only be used with a single recipient');
            }
            if (typeof joseHeader.enc !== "string" || !joseHeader.enc) {
                throw new JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
            }
            if (!enc) {
                enc = joseHeader.enc;
            } else if (enc !== joseHeader.enc) {
                throw new JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter must be the same for all recipients');
            }
            validate_crit(JWEInvalid, new Map(), recipient1.options.crit, this._protectedHeader, joseHeader);
            if (joseHeader.zip !== undefined) {
                if (!this._protectedHeader || !this._protectedHeader.zip) {
                    throw new JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
                }
            }
        }
        const cek = lib_cek(enc);
        let jwe1 = {
            ciphertext: "",
            iv: "",
            recipients: [],
            tag: ""
        };
        for(let i1 = 0; i1 < this._recipients.length; i1++){
            const recipient2 = this._recipients[i1];
            const target = {};
            jwe1.recipients.push(target);
            const joseHeader1 = {
                ...this._protectedHeader,
                ...this._unprotectedHeader,
                ...recipient2.unprotectedHeader
            };
            const p2c = joseHeader1.alg.startsWith("PBES2") ? 2048 + i1 : undefined;
            if (i1 === 0) {
                const flattened1 = await new FlattenedEncrypt(this._plaintext).setAdditionalAuthenticatedData(this._aad).setContentEncryptionKey(cek).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(recipient2.unprotectedHeader).setKeyManagementParameters({
                    p2c
                }).encrypt(recipient2.key, {
                    ...recipient2.options,
                    ...options,
                    [unprotected]: true
                });
                jwe1.ciphertext = flattened1.ciphertext;
                jwe1.iv = flattened1.iv;
                jwe1.tag = flattened1.tag;
                if (flattened1.aad) jwe1.aad = flattened1.aad;
                if (flattened1.protected) jwe1.protected = flattened1.protected;
                if (flattened1.unprotected) jwe1.unprotected = flattened1.unprotected;
                target.encrypted_key = flattened1.encrypted_key;
                if (flattened1.header) target.header = flattened1.header;
                continue;
            }
            const { encryptedKey , parameters  } = await encrypt_key_management(((_a = recipient2.unprotectedHeader) === null || _a === void 0 ? void 0 : _a.alg) || ((_b = this._protectedHeader) === null || _b === void 0 ? void 0 : _b.alg) || ((_c = this._unprotectedHeader) === null || _c === void 0 ? void 0 : _c.alg), enc, recipient2.key, cek, {
                p2c
            });
            target.encrypted_key = encode(encryptedKey);
            if (recipient2.unprotectedHeader || parameters) target.header = {
                ...recipient2.unprotectedHeader,
                ...parameters
            };
        }
        return jwe1;
    }
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/runtime/dsa_digest.js

function dsaDigest(alg) {
    switch(alg){
        case "PS256":
        case "RS256":
        case "ES256":
        case "ES256K":
            return "sha256";
        case "PS384":
        case "RS384":
        case "ES384":
            return "sha384";
        case "PS512":
        case "RS512":
        case "ES512":
            return "sha512";
        case "EdDSA":
            return undefined;
        default:
            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
    }
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/runtime/node_key.js




const [node_key_major, node_key_minor] = process.version.slice(1).split(".").map((str)=>parseInt(str, 10));
const electron = "electron" in process.versions;
const rsaPssParams = !electron && (node_key_major >= 17 || node_key_major === 16 && node_key_minor >= 9);
const PSS = {
    padding: external_crypto_.constants.RSA_PKCS1_PSS_PADDING,
    saltLength: external_crypto_.constants.RSA_PSS_SALTLEN_DIGEST
};
const ecCurveAlgMap = new Map([
    [
        "ES256",
        "P-256"
    ],
    [
        "ES256K",
        "secp256k1"
    ],
    [
        "ES384",
        "P-384"
    ],
    [
        "ES512",
        "P-521"
    ]
]);
function keyForCrypto(alg, key) {
    switch(alg){
        case "EdDSA":
            if (![
                "ed25519",
                "ed448"
            ].includes(key.asymmetricKeyType)) {
                throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be ed25519 or ed448");
            }
            return key;
        case "RS256":
        case "RS384":
        case "RS512":
            if (key.asymmetricKeyType !== "rsa") {
                throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be rsa");
            }
            check_modulus_length(key, alg);
            return key;
        case rsaPssParams && "PS256":
        case rsaPssParams && "PS384":
        case rsaPssParams && "PS512":
            if (key.asymmetricKeyType === "rsa-pss") {
                const { hashAlgorithm , mgf1HashAlgorithm , saltLength  } = key.asymmetricKeyDetails;
                const length = parseInt(alg.slice(-3), 10);
                if (hashAlgorithm !== undefined && (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm)) {
                    throw new TypeError(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${alg}`);
                }
                if (saltLength !== undefined && saltLength > length >> 3) {
                    throw new TypeError(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${alg}`);
                }
            } else if (key.asymmetricKeyType !== "rsa") {
                throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be rsa or rsa-pss");
            }
            check_modulus_length(key, alg);
            return {
                key,
                ...PSS
            };
        case !rsaPssParams && "PS256":
        case !rsaPssParams && "PS384":
        case !rsaPssParams && "PS512":
            if (key.asymmetricKeyType !== "rsa") {
                throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be rsa");
            }
            check_modulus_length(key, alg);
            return {
                key,
                ...PSS
            };
        case "ES256":
        case "ES256K":
        case "ES384":
        case "ES512":
            {
                if (key.asymmetricKeyType !== "ec") {
                    throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be ec");
                }
                const actual = get_named_curve(key);
                const expected = ecCurveAlgMap.get(alg);
                if (actual !== expected) {
                    throw new TypeError(`Invalid key curve for the algorithm, its curve must be ${expected}, got ${actual}`);
                }
                return {
                    dsaEncoding: "ieee-p1363",
                    key
                };
            }
        default:
            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
    }
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/runtime/hmac_digest.js

function hmacDigest(alg) {
    switch(alg){
        case "HS256":
            return "sha256";
        case "HS384":
            return "sha384";
        case "HS512":
            return "sha512";
        default:
            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
    }
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/runtime/get_sign_verify_key.js





function getSignVerifyKey(alg, key, usage) {
    if (key instanceof Uint8Array) {
        if (!alg.startsWith("HS")) {
            throw new TypeError(invalid_key_input(key, ...types));
        }
        return (0,external_crypto_.createSecretKey)(key);
    }
    if (key instanceof external_crypto_.KeyObject) {
        return key;
    }
    if (isCryptoKey(key)) {
        checkSigCryptoKey(key, alg, usage);
        return external_crypto_.KeyObject.from(key);
    }
    throw new TypeError(invalid_key_input(key, ...types, "Uint8Array"));
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/runtime/sign.js






let oneShotSign;
if (external_crypto_.sign.length > 3) {
    oneShotSign = (0,external_util_.promisify)(external_crypto_.sign);
} else {
    oneShotSign = external_crypto_.sign;
}
const sign = async (alg, key, data)=>{
    const keyObject = getSignVerifyKey(alg, key, "sign");
    if (alg.startsWith("HS")) {
        const hmac = external_crypto_.createHmac(hmacDigest(alg), keyObject);
        hmac.update(data);
        return hmac.digest();
    }
    return oneShotSign(dsaDigest(alg), data, keyForCrypto(alg, keyObject));
};
/* harmony default export */ const runtime_sign = (sign);

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/runtime/verify.js






const [verify_major, verify_minor] = process.version.slice(1).split(".").map((str)=>parseInt(str, 10));
const oneShotCallbackSupported = verify_major >= 16 || verify_major === 15 && verify_minor >= 13;
let oneShotVerify;
if (external_crypto_.verify.length > 4 && oneShotCallbackSupported) {
    oneShotVerify = (0,external_util_.promisify)(external_crypto_.verify);
} else {
    oneShotVerify = external_crypto_.verify;
}
const verify = async (alg, key, signature, data)=>{
    const keyObject = getSignVerifyKey(alg, key, "verify");
    if (alg.startsWith("HS")) {
        const expected = await runtime_sign(alg, keyObject, data);
        const actual = signature;
        try {
            return external_crypto_.timingSafeEqual(actual, expected);
        } catch  {
            return false;
        }
    }
    const algorithm = dsaDigest(alg);
    const keyInput = keyForCrypto(alg, keyObject);
    try {
        return await oneShotVerify(algorithm, data, keyInput, signature);
    } catch  {
        return false;
    }
};
/* harmony default export */ const runtime_verify = (verify);

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/jws/flattened/verify.js









async function flattenedVerify(jws, key, options) {
    var _a;
    if (!isObject(jws)) {
        throw new JWSInvalid("Flattened JWS must be an object");
    }
    if (jws.protected === undefined && jws.header === undefined) {
        throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
    }
    if (jws.protected !== undefined && typeof jws.protected !== "string") {
        throw new JWSInvalid("JWS Protected Header incorrect type");
    }
    if (jws.payload === undefined) {
        throw new JWSInvalid("JWS Payload missing");
    }
    if (typeof jws.signature !== "string") {
        throw new JWSInvalid("JWS Signature missing or incorrect type");
    }
    if (jws.header !== undefined && !isObject(jws.header)) {
        throw new JWSInvalid("JWS Unprotected Header incorrect type");
    }
    let parsedProt = {};
    if (jws.protected) {
        try {
            const protectedHeader = decode(jws.protected);
            parsedProt = JSON.parse(decoder.decode(protectedHeader));
        } catch  {
            throw new JWSInvalid("JWS Protected Header is invalid");
        }
    }
    if (!is_disjoint(parsedProt, jws.header)) {
        throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
    }
    const joseHeader = {
        ...parsedProt,
        ...jws.header
    };
    const extensions = validate_crit(JWSInvalid, new Map([
        [
            "b64",
            true
        ]
    ]), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
    let b64 = true;
    if (extensions.has("b64")) {
        b64 = parsedProt.b64;
        if (typeof b64 !== "boolean") {
            throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
        }
    }
    const { alg  } = joseHeader;
    if (typeof alg !== "string" || !alg) {
        throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
    }
    const algorithms = options && validate_algorithms("algorithms", options.algorithms);
    if (algorithms && !algorithms.has(alg)) {
        throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
    }
    if (b64) {
        if (typeof jws.payload !== "string") {
            throw new JWSInvalid("JWS Payload must be a string");
        }
    } else if (typeof jws.payload !== "string" && !(jws.payload instanceof Uint8Array)) {
        throw new JWSInvalid("JWS Payload must be a string or an Uint8Array instance");
    }
    let resolvedKey = false;
    if (typeof key === "function") {
        key = await key(parsedProt, jws);
        resolvedKey = true;
    }
    check_key_type(alg, key, "verify");
    const data = concat(encoder.encode((_a = jws.protected) !== null && _a !== void 0 ? _a : ""), encoder.encode("."), typeof jws.payload === "string" ? encoder.encode(jws.payload) : jws.payload);
    const signature = decode(jws.signature);
    const verified = await runtime_verify(alg, key, signature, data);
    if (!verified) {
        throw new JWSSignatureVerificationFailed();
    }
    let payload;
    if (b64) {
        payload = decode(jws.payload);
    } else if (typeof jws.payload === "string") {
        payload = encoder.encode(jws.payload);
    } else {
        payload = jws.payload;
    }
    const result = {
        payload
    };
    if (jws.protected !== undefined) {
        result.protectedHeader = parsedProt;
    }
    if (jws.header !== undefined) {
        result.unprotectedHeader = jws.header;
    }
    if (resolvedKey) {
        return {
            ...result,
            key
        };
    }
    return result;
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/jws/compact/verify.js



async function compactVerify(jws, key, options) {
    if (jws instanceof Uint8Array) {
        jws = decoder.decode(jws);
    }
    if (typeof jws !== "string") {
        throw new JWSInvalid("Compact JWS must be a string or Uint8Array");
    }
    const { 0: protectedHeader , 1: payload , 2: signature , length  } = jws.split(".");
    if (length !== 3) {
        throw new JWSInvalid("Invalid Compact JWS");
    }
    const verified = await flattenedVerify({
        payload,
        protected: protectedHeader,
        signature
    }, key, options);
    const result = {
        payload: verified.payload,
        protectedHeader: verified.protectedHeader
    };
    if (typeof key === "function") {
        return {
            ...result,
            key: verified.key
        };
    }
    return result;
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/jws/general/verify.js



async function generalVerify(jws, key, options) {
    if (!isObject(jws)) {
        throw new JWSInvalid("General JWS must be an object");
    }
    if (!Array.isArray(jws.signatures) || !jws.signatures.every(isObject)) {
        throw new JWSInvalid("JWS Signatures missing or incorrect type");
    }
    for (const signature of jws.signatures){
        try {
            return await flattenedVerify({
                header: signature.header,
                payload: jws.payload,
                protected: signature.protected,
                signature: signature.signature
            }, key, options);
        } catch  {}
    }
    throw new JWSSignatureVerificationFailed();
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/lib/epoch.js
/* harmony default export */ const epoch = ((date)=>Math.floor(date.getTime() / 1000));

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/lib/secs.js
const minute = 60;
const hour = minute * 60;
const day = hour * 24;
const week = day * 7;
const year = day * 365.25;
const REGEX = /^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;
/* harmony default export */ const secs = ((str)=>{
    const matched = REGEX.exec(str);
    if (!matched) {
        throw new TypeError("Invalid time period format");
    }
    const value = parseFloat(matched[1]);
    const unit = matched[2].toLowerCase();
    switch(unit){
        case "sec":
        case "secs":
        case "second":
        case "seconds":
        case "s":
            return Math.round(value);
        case "minute":
        case "minutes":
        case "min":
        case "mins":
        case "m":
            return Math.round(value * minute);
        case "hour":
        case "hours":
        case "hr":
        case "hrs":
        case "h":
            return Math.round(value * hour);
        case "day":
        case "days":
        case "d":
            return Math.round(value * day);
        case "week":
        case "weeks":
        case "w":
            return Math.round(value * week);
        default:
            return Math.round(value * year);
    }
});

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/lib/jwt_claims_set.js





const normalizeTyp = (value)=>value.toLowerCase().replace(/^application\//, "");
const checkAudiencePresence = (audPayload, audOption)=>{
    if (typeof audPayload === "string") {
        return audOption.includes(audPayload);
    }
    if (Array.isArray(audPayload)) {
        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
    }
    return false;
};
/* harmony default export */ const jwt_claims_set = ((protectedHeader, encodedPayload, options = {})=>{
    const { typ  } = options;
    if (typ && (typeof protectedHeader.typ !== "string" || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
        throw new JWTClaimValidationFailed('unexpected "typ" JWT header value', "typ", "check_failed");
    }
    let payload;
    try {
        payload = JSON.parse(decoder.decode(encodedPayload));
    } catch  {}
    if (!isObject(payload)) {
        throw new JWTInvalid("JWT Claims Set must be a top-level JSON object");
    }
    const { issuer  } = options;
    if (issuer && !(Array.isArray(issuer) ? issuer : [
        issuer
    ]).includes(payload.iss)) {
        throw new JWTClaimValidationFailed('unexpected "iss" claim value', "iss", "check_failed");
    }
    const { subject  } = options;
    if (subject && payload.sub !== subject) {
        throw new JWTClaimValidationFailed('unexpected "sub" claim value', "sub", "check_failed");
    }
    const { audience  } = options;
    if (audience && !checkAudiencePresence(payload.aud, typeof audience === "string" ? [
        audience
    ] : audience)) {
        throw new JWTClaimValidationFailed('unexpected "aud" claim value', "aud", "check_failed");
    }
    let tolerance;
    switch(typeof options.clockTolerance){
        case "string":
            tolerance = secs(options.clockTolerance);
            break;
        case "number":
            tolerance = options.clockTolerance;
            break;
        case "undefined":
            tolerance = 0;
            break;
        default:
            throw new TypeError("Invalid clockTolerance option type");
    }
    const { currentDate  } = options;
    const now = epoch(currentDate || new Date());
    if ((payload.iat !== undefined || options.maxTokenAge) && typeof payload.iat !== "number") {
        throw new JWTClaimValidationFailed('"iat" claim must be a number', "iat", "invalid");
    }
    if (payload.nbf !== undefined) {
        if (typeof payload.nbf !== "number") {
            throw new JWTClaimValidationFailed('"nbf" claim must be a number', "nbf", "invalid");
        }
        if (payload.nbf > now + tolerance) {
            throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed', "nbf", "check_failed");
        }
    }
    if (payload.exp !== undefined) {
        if (typeof payload.exp !== "number") {
            throw new JWTClaimValidationFailed('"exp" claim must be a number', "exp", "invalid");
        }
        if (payload.exp <= now - tolerance) {
            throw new JWTExpired('"exp" claim timestamp check failed', "exp", "check_failed");
        }
    }
    if (options.maxTokenAge) {
        const age = now - payload.iat;
        const max = typeof options.maxTokenAge === "number" ? options.maxTokenAge : secs(options.maxTokenAge);
        if (age - tolerance > max) {
            throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)', "iat", "check_failed");
        }
        if (age < 0 - tolerance) {
            throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', "iat", "check_failed");
        }
    }
    return payload;
});

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/jwt/verify.js



async function jwtVerify(jwt, key, options) {
    var _a;
    const verified = await compactVerify(jwt, key, options);
    if (((_a = verified.protectedHeader.crit) === null || _a === void 0 ? void 0 : _a.includes("b64")) && verified.protectedHeader.b64 === false) {
        throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
    }
    const payload = jwt_claims_set(verified.protectedHeader, verified.payload, options);
    const result = {
        payload,
        protectedHeader: verified.protectedHeader
    };
    if (typeof key === "function") {
        return {
            ...result,
            key: verified.key
        };
    }
    return result;
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/jwt/decrypt.js



async function jwtDecrypt(jwt, key, options) {
    const decrypted = await compactDecrypt(jwt, key, options);
    const payload = jwt_claims_set(decrypted.protectedHeader, decrypted.plaintext, options);
    const { protectedHeader  } = decrypted;
    if (protectedHeader.iss !== undefined && protectedHeader.iss !== payload.iss) {
        throw new JWTClaimValidationFailed('replicated "iss" claim header parameter mismatch', "iss", "mismatch");
    }
    if (protectedHeader.sub !== undefined && protectedHeader.sub !== payload.sub) {
        throw new JWTClaimValidationFailed('replicated "sub" claim header parameter mismatch', "sub", "mismatch");
    }
    if (protectedHeader.aud !== undefined && JSON.stringify(protectedHeader.aud) !== JSON.stringify(payload.aud)) {
        throw new JWTClaimValidationFailed('replicated "aud" claim header parameter mismatch', "aud", "mismatch");
    }
    const result = {
        payload,
        protectedHeader
    };
    if (typeof key === "function") {
        return {
            ...result,
            key: decrypted.key
        };
    }
    return result;
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/jwe/compact/encrypt.js

class CompactEncrypt {
    constructor(plaintext){
        this._flattened = new FlattenedEncrypt(plaintext);
    }
    setContentEncryptionKey(cek) {
        this._flattened.setContentEncryptionKey(cek);
        return this;
    }
    setInitializationVector(iv) {
        this._flattened.setInitializationVector(iv);
        return this;
    }
    setProtectedHeader(protectedHeader) {
        this._flattened.setProtectedHeader(protectedHeader);
        return this;
    }
    setKeyManagementParameters(parameters) {
        this._flattened.setKeyManagementParameters(parameters);
        return this;
    }
    async encrypt(key, options) {
        const jwe = await this._flattened.encrypt(key, options);
        return [
            jwe.protected,
            jwe.encrypted_key,
            jwe.iv,
            jwe.ciphertext,
            jwe.tag
        ].join(".");
    }
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/jws/flattened/sign.js







class FlattenedSign {
    constructor(payload){
        if (!(payload instanceof Uint8Array)) {
            throw new TypeError("payload must be an instance of Uint8Array");
        }
        this._payload = payload;
    }
    setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
            throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
    }
    setUnprotectedHeader(unprotectedHeader) {
        if (this._unprotectedHeader) {
            throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this._unprotectedHeader = unprotectedHeader;
        return this;
    }
    async sign(key, options) {
        if (!this._protectedHeader && !this._unprotectedHeader) {
            throw new JWSInvalid("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");
        }
        if (!is_disjoint(this._protectedHeader, this._unprotectedHeader)) {
            throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
        }
        const joseHeader = {
            ...this._protectedHeader,
            ...this._unprotectedHeader
        };
        const extensions = validate_crit(JWSInvalid, new Map([
            [
                "b64",
                true
            ]
        ]), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);
        let b64 = true;
        if (extensions.has("b64")) {
            b64 = this._protectedHeader.b64;
            if (typeof b64 !== "boolean") {
                throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
            }
        }
        const { alg  } = joseHeader;
        if (typeof alg !== "string" || !alg) {
            throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
        }
        check_key_type(alg, key, "sign");
        let payload = this._payload;
        if (b64) {
            payload = encoder.encode(encode(payload));
        }
        let protectedHeader;
        if (this._protectedHeader) {
            protectedHeader = encoder.encode(encode(JSON.stringify(this._protectedHeader)));
        } else {
            protectedHeader = encoder.encode("");
        }
        const data = concat(protectedHeader, encoder.encode("."), payload);
        const signature = await runtime_sign(alg, key, data);
        const jws = {
            signature: encode(signature),
            payload: ""
        };
        if (b64) {
            jws.payload = decoder.decode(payload);
        }
        if (this._unprotectedHeader) {
            jws.header = this._unprotectedHeader;
        }
        if (this._protectedHeader) {
            jws.protected = decoder.decode(protectedHeader);
        }
        return jws;
    }
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/jws/compact/sign.js

class CompactSign {
    constructor(payload){
        this._flattened = new FlattenedSign(payload);
    }
    setProtectedHeader(protectedHeader) {
        this._flattened.setProtectedHeader(protectedHeader);
        return this;
    }
    async sign(key, options) {
        const jws = await this._flattened.sign(key, options);
        if (jws.payload === undefined) {
            throw new TypeError("use the flattened module for creating JWS with b64: false");
        }
        return `${jws.protected}.${jws.payload}.${jws.signature}`;
    }
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/jws/general/sign.js


class IndividualSignature {
    constructor(sig, key, options){
        this.parent = sig;
        this.key = key;
        this.options = options;
    }
    setProtectedHeader(protectedHeader) {
        if (this.protectedHeader) {
            throw new TypeError("setProtectedHeader can only be called once");
        }
        this.protectedHeader = protectedHeader;
        return this;
    }
    setUnprotectedHeader(unprotectedHeader) {
        if (this.unprotectedHeader) {
            throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this.unprotectedHeader = unprotectedHeader;
        return this;
    }
    addSignature(...args) {
        return this.parent.addSignature(...args);
    }
    sign(...args) {
        return this.parent.sign(...args);
    }
    done() {
        return this.parent;
    }
}
class GeneralSign {
    constructor(payload){
        this._signatures = [];
        this._payload = payload;
    }
    addSignature(key, options) {
        const signature = new IndividualSignature(this, key, options);
        this._signatures.push(signature);
        return signature;
    }
    async sign() {
        if (!this._signatures.length) {
            throw new JWSInvalid("at least one signature must be added");
        }
        const jws = {
            signatures: [],
            payload: ""
        };
        for(let i = 0; i < this._signatures.length; i++){
            const signature = this._signatures[i];
            const flattened = new FlattenedSign(this._payload);
            flattened.setProtectedHeader(signature.protectedHeader);
            flattened.setUnprotectedHeader(signature.unprotectedHeader);
            const { payload , ...rest } = await flattened.sign(signature.key, signature.options);
            if (i === 0) {
                jws.payload = payload;
            } else if (jws.payload !== payload) {
                throw new JWSInvalid("inconsistent use of JWS Unencoded Payload Option (RFC7797)");
            }
            jws.signatures.push(rest);
        }
        return jws;
    }
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/jwt/produce.js



class ProduceJWT {
    constructor(payload){
        if (!isObject(payload)) {
            throw new TypeError("JWT Claims Set MUST be an object");
        }
        this._payload = payload;
    }
    setIssuer(issuer) {
        this._payload = {
            ...this._payload,
            iss: issuer
        };
        return this;
    }
    setSubject(subject) {
        this._payload = {
            ...this._payload,
            sub: subject
        };
        return this;
    }
    setAudience(audience) {
        this._payload = {
            ...this._payload,
            aud: audience
        };
        return this;
    }
    setJti(jwtId) {
        this._payload = {
            ...this._payload,
            jti: jwtId
        };
        return this;
    }
    setNotBefore(input) {
        if (typeof input === "number") {
            this._payload = {
                ...this._payload,
                nbf: input
            };
        } else {
            this._payload = {
                ...this._payload,
                nbf: epoch(new Date()) + secs(input)
            };
        }
        return this;
    }
    setExpirationTime(input) {
        if (typeof input === "number") {
            this._payload = {
                ...this._payload,
                exp: input
            };
        } else {
            this._payload = {
                ...this._payload,
                exp: epoch(new Date()) + secs(input)
            };
        }
        return this;
    }
    setIssuedAt(input) {
        if (typeof input === "undefined") {
            this._payload = {
                ...this._payload,
                iat: epoch(new Date())
            };
        } else {
            this._payload = {
                ...this._payload,
                iat: input
            };
        }
        return this;
    }
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/jwt/sign.js




class SignJWT extends ProduceJWT {
    setProtectedHeader(protectedHeader) {
        this._protectedHeader = protectedHeader;
        return this;
    }
    async sign(key, options) {
        var _a;
        const sig = new CompactSign(encoder.encode(JSON.stringify(this._payload)));
        sig.setProtectedHeader(this._protectedHeader);
        if (Array.isArray((_a = this._protectedHeader) === null || _a === void 0 ? void 0 : _a.crit) && this._protectedHeader.crit.includes("b64") && this._protectedHeader.b64 === false) {
            throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
        }
        return sig.sign(key, options);
    }
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/jwt/encrypt.js



class EncryptJWT extends ProduceJWT {
    setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
            throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
    }
    setKeyManagementParameters(parameters) {
        if (this._keyManagementParameters) {
            throw new TypeError("setKeyManagementParameters can only be called once");
        }
        this._keyManagementParameters = parameters;
        return this;
    }
    setContentEncryptionKey(cek) {
        if (this._cek) {
            throw new TypeError("setContentEncryptionKey can only be called once");
        }
        this._cek = cek;
        return this;
    }
    setInitializationVector(iv) {
        if (this._iv) {
            throw new TypeError("setInitializationVector can only be called once");
        }
        this._iv = iv;
        return this;
    }
    replicateIssuerAsHeader() {
        this._replicateIssuerAsHeader = true;
        return this;
    }
    replicateSubjectAsHeader() {
        this._replicateSubjectAsHeader = true;
        return this;
    }
    replicateAudienceAsHeader() {
        this._replicateAudienceAsHeader = true;
        return this;
    }
    async encrypt(key, options) {
        const enc = new CompactEncrypt(encoder.encode(JSON.stringify(this._payload)));
        if (this._replicateIssuerAsHeader) {
            this._protectedHeader = {
                ...this._protectedHeader,
                iss: this._payload.iss
            };
        }
        if (this._replicateSubjectAsHeader) {
            this._protectedHeader = {
                ...this._protectedHeader,
                sub: this._payload.sub
            };
        }
        if (this._replicateAudienceAsHeader) {
            this._protectedHeader = {
                ...this._protectedHeader,
                aud: this._payload.aud
            };
        }
        enc.setProtectedHeader(this._protectedHeader);
        if (this._iv) {
            enc.setInitializationVector(this._iv);
        }
        if (this._cek) {
            enc.setContentEncryptionKey(this._cek);
        }
        if (this._keyManagementParameters) {
            enc.setKeyManagementParameters(this._keyManagementParameters);
        }
        return enc.encrypt(key, options);
    }
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/jwk/thumbprint.js





const check = (value, description)=>{
    if (typeof value !== "string" || !value) {
        throw new JWKInvalid(`${description} missing or invalid`);
    }
};
async function calculateJwkThumbprint(jwk, digestAlgorithm) {
    if (!isObject(jwk)) {
        throw new TypeError("JWK must be an object");
    }
    digestAlgorithm !== null && digestAlgorithm !== void 0 ? digestAlgorithm : digestAlgorithm = "sha256";
    if (digestAlgorithm !== "sha256" && digestAlgorithm !== "sha384" && digestAlgorithm !== "sha512") {
        throw new TypeError('digestAlgorithm must one of "sha256", "sha384", or "sha512"');
    }
    let components;
    switch(jwk.kty){
        case "EC":
            check(jwk.crv, '"crv" (Curve) Parameter');
            check(jwk.x, '"x" (X Coordinate) Parameter');
            check(jwk.y, '"y" (Y Coordinate) Parameter');
            components = {
                crv: jwk.crv,
                kty: jwk.kty,
                x: jwk.x,
                y: jwk.y
            };
            break;
        case "OKP":
            check(jwk.crv, '"crv" (Subtype of Key Pair) Parameter');
            check(jwk.x, '"x" (Public Key) Parameter');
            components = {
                crv: jwk.crv,
                kty: jwk.kty,
                x: jwk.x
            };
            break;
        case "RSA":
            check(jwk.e, '"e" (Exponent) Parameter');
            check(jwk.n, '"n" (Modulus) Parameter');
            components = {
                e: jwk.e,
                kty: jwk.kty,
                n: jwk.n
            };
            break;
        case "oct":
            check(jwk.k, '"k" (Key Value) Parameter');
            components = {
                k: jwk.k,
                kty: jwk.kty
            };
            break;
        default:
            throw new JOSENotSupported('"kty" (Key Type) Parameter missing or unsupported');
    }
    const data = encoder.encode(JSON.stringify(components));
    return encode(await runtime_digest(digestAlgorithm, data));
}
async function calculateJwkThumbprintUri(jwk, digestAlgorithm) {
    digestAlgorithm !== null && digestAlgorithm !== void 0 ? digestAlgorithm : digestAlgorithm = "sha256";
    const thumbprint = await calculateJwkThumbprint(jwk, digestAlgorithm);
    return `urn:ietf:params:oauth:jwk-thumbprint:sha-${digestAlgorithm.slice(-3)}:${thumbprint}`;
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/jwk/embedded.js



async function EmbeddedJWK(protectedHeader, token) {
    const joseHeader = {
        ...protectedHeader,
        ...token.header
    };
    if (!isObject(joseHeader.jwk)) {
        throw new JWSInvalid('"jwk" (JSON Web Key) Header Parameter must be a JSON object');
    }
    const key = await importJWK({
        ...joseHeader.jwk,
        ext: true
    }, joseHeader.alg, true);
    if (key instanceof Uint8Array || key.type !== "public") {
        throw new JWSInvalid('"jwk" (JSON Web Key) Header Parameter must be a public key');
    }
    return key;
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/jwks/local.js



function getKtyFromAlg(alg) {
    switch(typeof alg === "string" && alg.slice(0, 2)){
        case "RS":
        case "PS":
            return "RSA";
        case "ES":
            return "EC";
        case "Ed":
            return "OKP";
        default:
            throw new JOSENotSupported('Unsupported "alg" value for a JSON Web Key Set');
    }
}
function isJWKSLike(jwks) {
    return jwks && typeof jwks === "object" && Array.isArray(jwks.keys) && jwks.keys.every(isJWKLike);
}
function isJWKLike(key) {
    return isObject(key);
}
function clone(obj) {
    if (typeof structuredClone === "function") {
        return structuredClone(obj);
    }
    return JSON.parse(JSON.stringify(obj));
}
class LocalJWKSet {
    constructor(jwks){
        this._cached = new WeakMap();
        if (!isJWKSLike(jwks)) {
            throw new JWKSInvalid("JSON Web Key Set malformed");
        }
        this._jwks = clone(jwks);
    }
    async getKey(protectedHeader, token) {
        const { alg , kid  } = {
            ...protectedHeader,
            ...token.header
        };
        const kty = getKtyFromAlg(alg);
        const candidates = this._jwks.keys.filter((jwk)=>{
            let candidate = kty === jwk.kty;
            if (candidate && typeof kid === "string") {
                candidate = kid === jwk.kid;
            }
            if (candidate && typeof jwk.alg === "string") {
                candidate = alg === jwk.alg;
            }
            if (candidate && typeof jwk.use === "string") {
                candidate = jwk.use === "sig";
            }
            if (candidate && Array.isArray(jwk.key_ops)) {
                candidate = jwk.key_ops.includes("verify");
            }
            if (candidate && alg === "EdDSA") {
                candidate = jwk.crv === "Ed25519" || jwk.crv === "Ed448";
            }
            if (candidate) {
                switch(alg){
                    case "ES256":
                        candidate = jwk.crv === "P-256";
                        break;
                    case "ES256K":
                        candidate = jwk.crv === "secp256k1";
                        break;
                    case "ES384":
                        candidate = jwk.crv === "P-384";
                        break;
                    case "ES512":
                        candidate = jwk.crv === "P-521";
                        break;
                }
            }
            return candidate;
        });
        const { 0: jwk , length  } = candidates;
        if (length === 0) {
            throw new JWKSNoMatchingKey();
        } else if (length !== 1) {
            throw new JWKSMultipleMatchingKeys();
        }
        const cached = this._cached.get(jwk) || this._cached.set(jwk, {}).get(jwk);
        if (cached[alg] === undefined) {
            const keyObject = await importJWK({
                ...jwk,
                ext: true
            }, alg);
            if (keyObject instanceof Uint8Array || keyObject.type !== "public") {
                throw new JWKSInvalid("JSON Web Key Set members must be public keys");
            }
            cached[alg] = keyObject;
        }
        return cached[alg];
    }
}
function createLocalJWKSet(jwks) {
    return LocalJWKSet.prototype.getKey.bind(new LocalJWKSet(jwks));
}

// EXTERNAL MODULE: external "http"
var external_http_ = __webpack_require__(13685);
// EXTERNAL MODULE: external "https"
var external_https_ = __webpack_require__(95687);
// EXTERNAL MODULE: external "events"
var external_events_ = __webpack_require__(82361);
;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/runtime/fetch_jwks.js





const fetchJwks = async (url, timeout, options)=>{
    let get;
    switch(url.protocol){
        case "https:":
            get = external_https_.get;
            break;
        case "http:":
            get = external_http_.get;
            break;
        default:
            throw new TypeError("Unsupported URL protocol.");
    }
    const { agent , headers  } = options;
    const req = get(url.href, {
        agent,
        timeout,
        headers
    });
    const [response] = await Promise.race([
        (0,external_events_.once)(req, "response"),
        (0,external_events_.once)(req, "timeout")
    ]);
    if (!response) {
        req.destroy();
        throw new JWKSTimeout();
    }
    if (response.statusCode !== 200) {
        throw new JOSEError("Expected 200 OK from the JSON Web Key Set HTTP response");
    }
    const parts = [];
    for await (const part of response){
        parts.push(part);
    }
    try {
        return JSON.parse(decoder.decode(concat(...parts)));
    } catch  {
        throw new JOSEError("Failed to parse the JSON Web Key Set HTTP response as JSON");
    }
};
/* harmony default export */ const fetch_jwks = (fetchJwks);

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/jwks/remote.js




class RemoteJWKSet extends LocalJWKSet {
    constructor(url, options){
        super({
            keys: []
        });
        this._jwks = undefined;
        if (!(url instanceof URL)) {
            throw new TypeError("url must be an instance of URL");
        }
        this._url = new URL(url.href);
        this._options = {
            agent: options === null || options === void 0 ? void 0 : options.agent,
            headers: options === null || options === void 0 ? void 0 : options.headers
        };
        this._timeoutDuration = typeof (options === null || options === void 0 ? void 0 : options.timeoutDuration) === "number" ? options === null || options === void 0 ? void 0 : options.timeoutDuration : 5000;
        this._cooldownDuration = typeof (options === null || options === void 0 ? void 0 : options.cooldownDuration) === "number" ? options === null || options === void 0 ? void 0 : options.cooldownDuration : 30000;
        this._cacheMaxAge = typeof (options === null || options === void 0 ? void 0 : options.cacheMaxAge) === "number" ? options === null || options === void 0 ? void 0 : options.cacheMaxAge : 600000;
    }
    coolingDown() {
        return typeof this._jwksTimestamp === "number" ? Date.now() < this._jwksTimestamp + this._cooldownDuration : false;
    }
    fresh() {
        return typeof this._jwksTimestamp === "number" ? Date.now() < this._jwksTimestamp + this._cacheMaxAge : false;
    }
    async getKey(protectedHeader, token) {
        if (!this._jwks || !this.fresh()) {
            await this.reload();
        }
        try {
            return await super.getKey(protectedHeader, token);
        } catch (err) {
            if (err instanceof JWKSNoMatchingKey) {
                if (this.coolingDown() === false) {
                    await this.reload();
                    return super.getKey(protectedHeader, token);
                }
            }
            throw err;
        }
    }
    async reload() {
        if (this._pendingFetch && isCloudflareWorkers()) {
            return new Promise((resolve)=>{
                const isDone = ()=>{
                    if (this._pendingFetch === undefined) {
                        resolve();
                    } else {
                        setTimeout(isDone, 5);
                    }
                };
                isDone();
            });
        }
        if (!this._pendingFetch) {
            this._pendingFetch = fetch_jwks(this._url, this._timeoutDuration, this._options).then((json)=>{
                if (!isJWKSLike(json)) {
                    throw new JWKSInvalid("JSON Web Key Set malformed");
                }
                this._jwks = {
                    keys: json.keys
                };
                this._jwksTimestamp = Date.now();
                this._pendingFetch = undefined;
            }).catch((err)=>{
                this._pendingFetch = undefined;
                throw err;
            });
        }
        await this._pendingFetch;
    }
}
function createRemoteJWKSet(url, options) {
    return RemoteJWKSet.prototype.getKey.bind(new RemoteJWKSet(url, options));
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/jwt/unsecured.js





class UnsecuredJWT extends ProduceJWT {
    encode() {
        const header = encode(JSON.stringify({
            alg: "none"
        }));
        const payload = encode(JSON.stringify(this._payload));
        return `${header}.${payload}.`;
    }
    static decode(jwt, options) {
        if (typeof jwt !== "string") {
            throw new JWTInvalid("Unsecured JWT must be a string");
        }
        const { 0: encodedHeader , 1: encodedPayload , 2: signature , length  } = jwt.split(".");
        if (length !== 3 || signature !== "") {
            throw new JWTInvalid("Invalid Unsecured JWT");
        }
        let header;
        try {
            header = JSON.parse(decoder.decode(decode(encodedHeader)));
            if (header.alg !== "none") throw new Error();
        } catch  {
            throw new JWTInvalid("Invalid Unsecured JWT");
        }
        const payload = jwt_claims_set(header, decode(encodedPayload), options);
        return {
            payload,
            header
        };
    }
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/util/base64url.js

const base64url_encode = encode;
const base64url_decode = decode;

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/util/decode_protected_header.js



function decodeProtectedHeader(token) {
    let protectedB64u;
    if (typeof token === "string") {
        const parts = token.split(".");
        if (parts.length === 3 || parts.length === 5) {
            ;
            [protectedB64u] = parts;
        }
    } else if (typeof token === "object" && token) {
        if ("protected" in token) {
            protectedB64u = token.protected;
        } else {
            throw new TypeError("Token does not contain a Protected Header");
        }
    }
    try {
        if (typeof protectedB64u !== "string" || !protectedB64u) {
            throw new Error();
        }
        const result = JSON.parse(decoder.decode(base64url_decode(protectedB64u)));
        if (!isObject(result)) {
            throw new Error();
        }
        return result;
    } catch  {
        throw new TypeError("Invalid Token or Protected Header formatting");
    }
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/util/decode_jwt.js




function decodeJwt(jwt) {
    if (typeof jwt !== "string") throw new JWTInvalid("JWTs must use Compact JWS serialization, JWT must be a string");
    const { 1: payload , length  } = jwt.split(".");
    if (length === 5) throw new JWTInvalid("Only JWTs using Compact JWS serialization can be decoded");
    if (length !== 3) throw new JWTInvalid("Invalid JWT");
    if (!payload) throw new JWTInvalid("JWTs must contain a payload");
    let decoded;
    try {
        decoded = base64url_decode(payload);
    } catch  {
        throw new JWTInvalid("Failed to parse the base64url encoded payload");
    }
    let result;
    try {
        result = JSON.parse(decoder.decode(decoded));
    } catch  {
        throw new JWTInvalid("Failed to parse the decoded payload as JSON");
    }
    if (!isObject(result)) throw new JWTInvalid("Invalid JWT Claims Set");
    return result;
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/runtime/generate.js





const generate = (0,external_util_.promisify)(external_crypto_.generateKeyPair);
async function generateSecret(alg, options) {
    let length;
    switch(alg){
        case "HS256":
        case "HS384":
        case "HS512":
        case "A128CBC-HS256":
        case "A192CBC-HS384":
        case "A256CBC-HS512":
            length = parseInt(alg.slice(-3), 10);
            break;
        case "A128KW":
        case "A192KW":
        case "A256KW":
        case "A128GCMKW":
        case "A192GCMKW":
        case "A256GCMKW":
        case "A128GCM":
        case "A192GCM":
        case "A256GCM":
            length = parseInt(alg.slice(1, 4), 10);
            break;
        default:
            throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
    }
    return (0,external_crypto_.createSecretKey)((0,external_crypto_.randomFillSync)(new Uint8Array(length >> 3)));
}
async function generate_generateKeyPair(alg, options) {
    var _a, _b;
    switch(alg){
        case "RS256":
        case "RS384":
        case "RS512":
        case "PS256":
        case "PS384":
        case "PS512":
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
        case "RSA1_5":
            {
                const modulusLength = (_a = options === null || options === void 0 ? void 0 : options.modulusLength) !== null && _a !== void 0 ? _a : 2048;
                if (typeof modulusLength !== "number" || modulusLength < 2048) {
                    throw new JOSENotSupported("Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used");
                }
                const keypair = await generate("rsa", {
                    modulusLength,
                    publicExponent: 0x10001
                });
                setModulusLength(keypair.privateKey, modulusLength);
                setModulusLength(keypair.publicKey, modulusLength);
                return keypair;
            }
        case "ES256":
            return generate("ec", {
                namedCurve: "P-256"
            });
        case "ES256K":
            return generate("ec", {
                namedCurve: "secp256k1"
            });
        case "ES384":
            return generate("ec", {
                namedCurve: "P-384"
            });
        case "ES512":
            return generate("ec", {
                namedCurve: "P-521"
            });
        case "EdDSA":
            {
                switch(options === null || options === void 0 ? void 0 : options.crv){
                    case undefined:
                    case "Ed25519":
                        return generate("ed25519");
                    case "Ed448":
                        return generate("ed448");
                    default:
                        throw new JOSENotSupported("Invalid or unsupported crv option provided, supported values are Ed25519 and Ed448");
                }
            }
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
            const crv = (_b = options === null || options === void 0 ? void 0 : options.crv) !== null && _b !== void 0 ? _b : "P-256";
            switch(crv){
                case undefined:
                case "P-256":
                case "P-384":
                case "P-521":
                    return generate("ec", {
                        namedCurve: crv
                    });
                case "X25519":
                    return generate("x25519");
                case "X448":
                    return generate("x448");
                default:
                    throw new JOSENotSupported("Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448");
            }
        default:
            throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
    }
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/key/generate_key_pair.js

async function generate_key_pair_generateKeyPair(alg, options) {
    return generate_generateKeyPair(alg, options);
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/key/generate_secret.js

async function generate_secret_generateSecret(alg, options) {
    return generateSecret(alg, options);
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/jose@4.11.1/node_modules/jose/dist/node/esm/index.js































/***/ }),

/***/ 65462:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// A linked list to keep track of recently-used-ness
const Yallist = __webpack_require__(63694);
const MAX = Symbol("max");
const LENGTH = Symbol("length");
const LENGTH_CALCULATOR = Symbol("lengthCalculator");
const ALLOW_STALE = Symbol("allowStale");
const MAX_AGE = Symbol("maxAge");
const DISPOSE = Symbol("dispose");
const NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
const LRU_LIST = Symbol("lruList");
const CACHE = Symbol("cache");
const UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
const naiveLength = ()=>1;
// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
class LRUCache {
    constructor(options){
        if (typeof options === "number") options = {
            max: options
        };
        if (!options) options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0)) throw new TypeError("max must be a non-negative number");
        // Kind of weird to have a default max of Infinity, but oh well.
        const max = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number") throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
    }
    // resize the cache when the max changes.
    set max(mL) {
        if (typeof mL !== "number" || mL < 0) throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
    }
    get max() {
        return this[MAX];
    }
    set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
    }
    get allowStale() {
        return this[ALLOW_STALE];
    }
    set maxAge(mA) {
        if (typeof mA !== "number") throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
    }
    get maxAge() {
        return this[MAX_AGE];
    }
    // resize the cache when the lengthCalculator changes.
    set lengthCalculator(lC) {
        if (typeof lC !== "function") lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
            this[LENGTH_CALCULATOR] = lC;
            this[LENGTH] = 0;
            this[LRU_LIST].forEach((hit)=>{
                hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
                this[LENGTH] += hit.length;
            });
        }
        trim(this);
    }
    get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
    }
    get length() {
        return this[LENGTH];
    }
    get itemCount() {
        return this[LRU_LIST].length;
    }
    rforEach(fn, thisp) {
        thisp = thisp || this;
        for(let walker = this[LRU_LIST].tail; walker !== null;){
            const prev = walker.prev;
            forEachStep(this, fn, walker, thisp);
            walker = prev;
        }
    }
    forEach(fn, thisp) {
        thisp = thisp || this;
        for(let walker = this[LRU_LIST].head; walker !== null;){
            const next = walker.next;
            forEachStep(this, fn, walker, thisp);
            walker = next;
        }
    }
    keys() {
        return this[LRU_LIST].toArray().map((k)=>k.key);
    }
    values() {
        return this[LRU_LIST].toArray().map((k)=>k.value);
    }
    reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
            this[LRU_LIST].forEach((hit)=>this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = new Map() // hash of items by key
        ;
        this[LRU_LIST] = new Yallist() // list of items in order of use recency
        ;
        this[LENGTH] = 0 // length of items in the list
        ;
    }
    dump() {
        return this[LRU_LIST].map((hit)=>isStale(this, hit) ? false : {
                k: hit.key,
                v: hit.value,
                e: hit.now + (hit.maxAge || 0)
            }).toArray().filter((h)=>h);
    }
    dumpLru() {
        return this[LRU_LIST];
    }
    set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number") throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
            if (len > this[MAX]) {
                del(this, this[CACHE].get(key));
                return false;
            }
            const node = this[CACHE].get(key);
            const item = node.value;
            // dispose of the old one before overwriting
            // split out into 2 ifs for better coverage tracking
            if (this[DISPOSE]) {
                if (!this[NO_DISPOSE_ON_SET]) this[DISPOSE](key, item.value);
            }
            item.now = now;
            item.maxAge = maxAge;
            item.value = value;
            this[LENGTH] += len - item.length;
            item.length = len;
            this.get(key);
            trim(this);
            return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        // oversized objects fall out of cache automatically.
        if (hit.length > this[MAX]) {
            if (this[DISPOSE]) this[DISPOSE](key, value);
            return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
    }
    has(key) {
        if (!this[CACHE].has(key)) return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
    }
    get(key) {
        return get(this, key, true);
    }
    peek(key) {
        return get(this, key, false);
    }
    pop() {
        const node = this[LRU_LIST].tail;
        if (!node) return null;
        del(this, node);
        return node.value;
    }
    del(key) {
        del(this, this[CACHE].get(key));
    }
    load(arr) {
        // reset the cache
        this.reset();
        const now = Date.now();
        // A previous serialized cache has the most recent items first
        for(let l = arr.length - 1; l >= 0; l--){
            const hit = arr[l];
            const expiresAt = hit.e || 0;
            if (expiresAt === 0) // the item was created without expiration in a non aged cache
            this.set(hit.k, hit.v);
            else {
                const maxAge = expiresAt - now;
                // dont add already expired items
                if (maxAge > 0) {
                    this.set(hit.k, hit.v, maxAge);
                }
            }
        }
    }
    prune() {
        this[CACHE].forEach((value, key)=>get(this, key, false));
    }
}
const get = (self, key, doUse)=>{
    const node = self[CACHE].get(key);
    if (node) {
        const hit = node.value;
        if (isStale(self, hit)) {
            del(self, node);
            if (!self[ALLOW_STALE]) return undefined;
        } else {
            if (doUse) {
                if (self[UPDATE_AGE_ON_GET]) node.value.now = Date.now();
                self[LRU_LIST].unshiftNode(node);
            }
        }
        return hit.value;
    }
};
const isStale = (self, hit)=>{
    if (!hit || !hit.maxAge && !self[MAX_AGE]) return false;
    const diff = Date.now() - hit.now;
    return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
};
const trim = (self)=>{
    if (self[LENGTH] > self[MAX]) {
        for(let walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null;){
            // We know that we're about to delete this one, and also
            // what the next least recently used key will be, so just
            // go ahead and set it now.
            const prev = walker.prev;
            del(self, walker);
            walker = prev;
        }
    }
};
const del = (self, node)=>{
    if (node) {
        const hit = node.value;
        if (self[DISPOSE]) self[DISPOSE](hit.key, hit.value);
        self[LENGTH] -= hit.length;
        self[CACHE].delete(hit.key);
        self[LRU_LIST].removeNode(node);
    }
};
class Entry {
    constructor(key, value, length, now, maxAge){
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
    }
}
const forEachStep = (self, fn, node, thisp)=>{
    let hit = node.value;
    if (isStale(self, hit)) {
        del(self, node);
        if (!self[ALLOW_STALE]) hit = undefined;
    }
    if (hit) fn.call(thisp, hit.value, hit.key, self);
};
module.exports = LRUCache;


/***/ }),

/***/ 46990:
/***/ ((module) => {

"use strict";
/**
 * Helpers.
 */ 
var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */ module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
        return parse(val);
    } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */ function parse(str) {
    str = String(str);
    if (str.length > 100) {
        return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
        return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch(type){
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
            return n * y;
        case "weeks":
        case "week":
        case "w":
            return n * w;
        case "days":
        case "day":
        case "d":
            return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
            return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
            return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
            return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
            return n;
        default:
            return undefined;
    }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
        return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
        return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
        return Math.round(ms / s) + "s";
    }
    return ms + "ms";
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
}
/**
 * Pluralization helper.
 */ function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
}


/***/ }),

/***/ 83426:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _interopRequireDefault = __webpack_require__(11061);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.UnsupportedStrategy = exports.UnknownError = exports.OAuthCallbackError = exports.MissingSecret = exports.MissingAuthorize = exports.MissingAdapterMethods = exports.MissingAdapter = exports.MissingAPIRoute = exports.InvalidCallbackUrl = exports.AccountNotLinkedError = void 0;
exports.adapterErrorHandler = adapterErrorHandler;
exports.capitalize = capitalize;
exports.eventsErrorHandler = eventsErrorHandler;
exports.upperSnake = upperSnake;
var _regenerator = _interopRequireDefault(__webpack_require__(88315));
var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(9746));
var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(91515));
var _defineProperty2 = _interopRequireDefault(__webpack_require__(97054));
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(97614));
var _createClass2 = _interopRequireDefault(__webpack_require__(99304));
var _inherits2 = _interopRequireDefault(__webpack_require__(57697));
var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(99197));
var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(539));
var _wrapNativeSuper2 = _interopRequireDefault(__webpack_require__(46502));
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return (0, _possibleConstructorReturn2.default)(this, result);
    };
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
var UnknownError = function(_Error) {
    (0, _inherits2.default)(UnknownError, _Error);
    var _super = _createSuper(UnknownError);
    function UnknownError(error) {
        var _message;
        var _this;
        (0, _classCallCheck2.default)(this, UnknownError);
        _this = _super.call(this, (_message = error === null || error === void 0 ? void 0 : error.message) !== null && _message !== void 0 ? _message : error);
        _this.name = "UnknownError";
        _this.code = error.code;
        if (error instanceof Error) {
            _this.stack = error.stack;
        }
        return _this;
    }
    (0, _createClass2.default)(UnknownError, [
        {
            key: "toJSON",
            value: function toJSON() {
                return {
                    name: this.name,
                    message: this.message,
                    stack: this.stack
                };
            }
        }
    ]);
    return UnknownError;
}((0, _wrapNativeSuper2.default)(Error));
exports.UnknownError = UnknownError;
var OAuthCallbackError = function(_UnknownError) {
    (0, _inherits2.default)(OAuthCallbackError, _UnknownError);
    var _super2 = _createSuper(OAuthCallbackError);
    function OAuthCallbackError() {
        var _this2;
        (0, _classCallCheck2.default)(this, OAuthCallbackError);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this2 = _super2.call.apply(_super2, [
            this
        ].concat(args));
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this2), "name", "OAuthCallbackError");
        return _this2;
    }
    return (0, _createClass2.default)(OAuthCallbackError);
}(UnknownError);
exports.OAuthCallbackError = OAuthCallbackError;
var AccountNotLinkedError = function(_UnknownError2) {
    (0, _inherits2.default)(AccountNotLinkedError, _UnknownError2);
    var _super3 = _createSuper(AccountNotLinkedError);
    function AccountNotLinkedError() {
        var _this3;
        (0, _classCallCheck2.default)(this, AccountNotLinkedError);
        for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){
            args[_key2] = arguments[_key2];
        }
        _this3 = _super3.call.apply(_super3, [
            this
        ].concat(args));
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this3), "name", "AccountNotLinkedError");
        return _this3;
    }
    return (0, _createClass2.default)(AccountNotLinkedError);
}(UnknownError);
exports.AccountNotLinkedError = AccountNotLinkedError;
var MissingAPIRoute = function(_UnknownError3) {
    (0, _inherits2.default)(MissingAPIRoute, _UnknownError3);
    var _super4 = _createSuper(MissingAPIRoute);
    function MissingAPIRoute() {
        var _this4;
        (0, _classCallCheck2.default)(this, MissingAPIRoute);
        for(var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++){
            args[_key3] = arguments[_key3];
        }
        _this4 = _super4.call.apply(_super4, [
            this
        ].concat(args));
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this4), "name", "MissingAPIRouteError");
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this4), "code", "MISSING_NEXTAUTH_API_ROUTE_ERROR");
        return _this4;
    }
    return (0, _createClass2.default)(MissingAPIRoute);
}(UnknownError);
exports.MissingAPIRoute = MissingAPIRoute;
var MissingSecret = function(_UnknownError4) {
    (0, _inherits2.default)(MissingSecret, _UnknownError4);
    var _super5 = _createSuper(MissingSecret);
    function MissingSecret() {
        var _this5;
        (0, _classCallCheck2.default)(this, MissingSecret);
        for(var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++){
            args[_key4] = arguments[_key4];
        }
        _this5 = _super5.call.apply(_super5, [
            this
        ].concat(args));
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this5), "name", "MissingSecretError");
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this5), "code", "NO_SECRET");
        return _this5;
    }
    return (0, _createClass2.default)(MissingSecret);
}(UnknownError);
exports.MissingSecret = MissingSecret;
var MissingAuthorize = function(_UnknownError5) {
    (0, _inherits2.default)(MissingAuthorize, _UnknownError5);
    var _super6 = _createSuper(MissingAuthorize);
    function MissingAuthorize() {
        var _this6;
        (0, _classCallCheck2.default)(this, MissingAuthorize);
        for(var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++){
            args[_key5] = arguments[_key5];
        }
        _this6 = _super6.call.apply(_super6, [
            this
        ].concat(args));
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this6), "name", "MissingAuthorizeError");
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this6), "code", "CALLBACK_CREDENTIALS_HANDLER_ERROR");
        return _this6;
    }
    return (0, _createClass2.default)(MissingAuthorize);
}(UnknownError);
exports.MissingAuthorize = MissingAuthorize;
var MissingAdapter = function(_UnknownError6) {
    (0, _inherits2.default)(MissingAdapter, _UnknownError6);
    var _super7 = _createSuper(MissingAdapter);
    function MissingAdapter() {
        var _this7;
        (0, _classCallCheck2.default)(this, MissingAdapter);
        for(var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++){
            args[_key6] = arguments[_key6];
        }
        _this7 = _super7.call.apply(_super7, [
            this
        ].concat(args));
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this7), "name", "MissingAdapterError");
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this7), "code", "EMAIL_REQUIRES_ADAPTER_ERROR");
        return _this7;
    }
    return (0, _createClass2.default)(MissingAdapter);
}(UnknownError);
exports.MissingAdapter = MissingAdapter;
var MissingAdapterMethods = function(_UnknownError7) {
    (0, _inherits2.default)(MissingAdapterMethods, _UnknownError7);
    var _super8 = _createSuper(MissingAdapterMethods);
    function MissingAdapterMethods() {
        var _this8;
        (0, _classCallCheck2.default)(this, MissingAdapterMethods);
        for(var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++){
            args[_key7] = arguments[_key7];
        }
        _this8 = _super8.call.apply(_super8, [
            this
        ].concat(args));
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this8), "name", "MissingAdapterMethodsError");
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this8), "code", "MISSING_ADAPTER_METHODS_ERROR");
        return _this8;
    }
    return (0, _createClass2.default)(MissingAdapterMethods);
}(UnknownError);
exports.MissingAdapterMethods = MissingAdapterMethods;
var UnsupportedStrategy = function(_UnknownError8) {
    (0, _inherits2.default)(UnsupportedStrategy, _UnknownError8);
    var _super9 = _createSuper(UnsupportedStrategy);
    function UnsupportedStrategy() {
        var _this9;
        (0, _classCallCheck2.default)(this, UnsupportedStrategy);
        for(var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++){
            args[_key8] = arguments[_key8];
        }
        _this9 = _super9.call.apply(_super9, [
            this
        ].concat(args));
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this9), "name", "UnsupportedStrategyError");
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this9), "code", "CALLBACK_CREDENTIALS_JWT_ERROR");
        return _this9;
    }
    return (0, _createClass2.default)(UnsupportedStrategy);
}(UnknownError);
exports.UnsupportedStrategy = UnsupportedStrategy;
var InvalidCallbackUrl = function(_UnknownError9) {
    (0, _inherits2.default)(InvalidCallbackUrl, _UnknownError9);
    var _super10 = _createSuper(InvalidCallbackUrl);
    function InvalidCallbackUrl() {
        var _this10;
        (0, _classCallCheck2.default)(this, InvalidCallbackUrl);
        for(var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++){
            args[_key9] = arguments[_key9];
        }
        _this10 = _super10.call.apply(_super10, [
            this
        ].concat(args));
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this10), "name", "InvalidCallbackUrl");
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this10), "code", "INVALID_CALLBACK_URL_ERROR");
        return _this10;
    }
    return (0, _createClass2.default)(InvalidCallbackUrl);
}(UnknownError);
exports.InvalidCallbackUrl = InvalidCallbackUrl;
function upperSnake(s) {
    return s.replace(/([A-Z])/g, "_$1").toUpperCase();
}
function capitalize(s) {
    return "".concat(s[0].toUpperCase()).concat(s.slice(1));
}
function eventsErrorHandler(methods, logger) {
    return Object.keys(methods).reduce(function(acc, name) {
        acc[name] = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee() {
            var method, _args = arguments;
            return _regenerator.default.wrap(function _callee$(_context) {
                while(1){
                    switch(_context.prev = _context.next){
                        case 0:
                            _context.prev = 0;
                            method = methods[name];
                            _context.next = 4;
                            return method.apply(void 0, _args);
                        case 4:
                            return _context.abrupt("return", _context.sent);
                        case 7:
                            _context.prev = 7;
                            _context.t0 = _context["catch"](0);
                            logger.error("".concat(upperSnake(name), "_EVENT_ERROR"), _context.t0);
                        case 10:
                        case "end":
                            return _context.stop();
                    }
                }
            }, _callee, null, [
                [
                    0,
                    7
                ]
            ]);
        }));
        return acc;
    }, {});
}
function adapterErrorHandler(adapter, logger) {
    if (!adapter) return;
    return Object.keys(adapter).reduce(function(acc, name) {
        acc[name] = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2() {
            var _len10, args, _key10, method, e, _args2 = arguments;
            return _regenerator.default.wrap(function _callee2$(_context2) {
                while(1){
                    switch(_context2.prev = _context2.next){
                        case 0:
                            _context2.prev = 0;
                            for(_len10 = _args2.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++){
                                args[_key10] = _args2[_key10];
                            }
                            logger.debug("adapter_".concat(name), {
                                args: args
                            });
                            method = adapter[name];
                            _context2.next = 6;
                            return method.apply(void 0, args);
                        case 6:
                            return _context2.abrupt("return", _context2.sent);
                        case 9:
                            _context2.prev = 9;
                            _context2.t0 = _context2["catch"](0);
                            logger.error("adapter_error_".concat(name), _context2.t0);
                            e = new UnknownError(_context2.t0);
                            e.name = "".concat(capitalize(name), "Error");
                            throw e;
                        case 15:
                        case "end":
                            return _context2.stop();
                    }
                }
            }, _callee2, null, [
                [
                    0,
                    9
                ]
            ]);
        }));
        return acc;
    }, {});
}


/***/ }),

/***/ 74603:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _interopRequireDefault = __webpack_require__(11061);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.NextAuthHandler = NextAuthHandler;
var _logger = _interopRequireWildcard(__webpack_require__(51496));
var _detectHost = __webpack_require__(56670);
var routes = _interopRequireWildcard(__webpack_require__(45972));
var _pages = _interopRequireDefault(__webpack_require__(51685));
var _init = __webpack_require__(26809);
var _assert = __webpack_require__(23943);
var _cookie = __webpack_require__(67497);
var _cookie2 = __webpack_require__(3519);
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
async function getBody(req) {
    try {
        return await req.json();
    } catch (_unused) {}
}
async function toInternalRequest(req) {
    if (req instanceof Request) {
        var _req$headers$get, _url$searchParams$get, _headers$xForwarded;
        const url = new URL(req.url);
        const nextauth = url.pathname.split("/").slice(3);
        const headers = Object.fromEntries(req.headers);
        const query = Object.fromEntries(url.searchParams);
        query.nextauth = nextauth;
        return {
            action: nextauth[0],
            method: req.method,
            headers,
            body: await getBody(req),
            cookies: (0, _cookie2.parse)((_req$headers$get = req.headers.get("cookie")) !== null && _req$headers$get !== void 0 ? _req$headers$get : ""),
            providerId: nextauth[1],
            error: (_url$searchParams$get = url.searchParams.get("error")) !== null && _url$searchParams$get !== void 0 ? _url$searchParams$get : nextauth[1],
            host: (0, _detectHost.detectHost)((_headers$xForwarded = headers["x-forwarded-host"]) !== null && _headers$xForwarded !== void 0 ? _headers$xForwarded : headers.host),
            query
        };
    }
    return req;
}
async function NextAuthHandler(params) {
    var _req$body$callbackUrl, _req$body, _req$query2, _req$body2;
    const { options: userOptions , req: incomingRequest  } = params;
    const req = await toInternalRequest(incomingRequest);
    (0, _logger.setLogger)(userOptions.logger, userOptions.debug);
    const assertionResult = (0, _assert.assertConfig)({
        options: userOptions,
        req
    });
    if (Array.isArray(assertionResult)) {
        assertionResult.forEach(_logger.default.warn);
    } else if (assertionResult instanceof Error) {
        var _req$query, _req$query$callbackUr;
        _logger.default.error(assertionResult.code, assertionResult);
        const htmlPages = [
            "signin",
            "signout",
            "error",
            "verify-request"
        ];
        if (!htmlPages.includes(req.action) || req.method !== "GET") {
            const message = `There is a problem with the server configuration. Check the server logs for more information.`;
            return {
                status: 500,
                headers: [
                    {
                        key: "Content-Type",
                        value: "application/json"
                    }
                ],
                body: {
                    message
                }
            };
        }
        const { pages , theme  } = userOptions;
        const authOnErrorPage = (pages === null || pages === void 0 ? void 0 : pages.error) && ((_req$query = req.query) === null || _req$query === void 0 ? void 0 : (_req$query$callbackUr = _req$query.callbackUrl) === null || _req$query$callbackUr === void 0 ? void 0 : _req$query$callbackUr.startsWith(pages.error));
        if (!(pages !== null && pages !== void 0 && pages.error) || authOnErrorPage) {
            if (authOnErrorPage) {
                _logger.default.error("AUTH_ON_ERROR_PAGE_ERROR", new Error(`The error page ${pages === null || pages === void 0 ? void 0 : pages.error} should not require authentication`));
            }
            const render = (0, _pages.default)({
                theme
            });
            return render.error({
                error: "configuration"
            });
        }
        return {
            redirect: `${pages.error}?error=Configuration`
        };
    }
    const { action , providerId , error , method ="GET"  } = req;
    const { options , cookies  } = await (0, _init.init)({
        userOptions,
        action,
        providerId,
        host: req.host,
        callbackUrl: (_req$body$callbackUrl = (_req$body = req.body) === null || _req$body === void 0 ? void 0 : _req$body.callbackUrl) !== null && _req$body$callbackUrl !== void 0 ? _req$body$callbackUrl : (_req$query2 = req.query) === null || _req$query2 === void 0 ? void 0 : _req$query2.callbackUrl,
        csrfToken: (_req$body2 = req.body) === null || _req$body2 === void 0 ? void 0 : _req$body2.csrfToken,
        cookies: req.cookies,
        isPost: method === "POST"
    });
    const sessionStore = new _cookie.SessionStore(options.cookies.sessionToken, req, options.logger);
    if (method === "GET") {
        const render1 = (0, _pages.default)({
            ...options,
            query: req.query,
            cookies
        });
        const { pages: pages1  } = options;
        switch(action){
            case "providers":
                return await routes.providers(options.providers);
            case "session":
                {
                    const session = await routes.session({
                        options,
                        sessionStore
                    });
                    if (session.cookies) cookies.push(...session.cookies);
                    return {
                        ...session,
                        cookies
                    };
                }
            case "csrf":
                return {
                    headers: [
                        {
                            key: "Content-Type",
                            value: "application/json"
                        }
                    ],
                    body: {
                        csrfToken: options.csrfToken
                    },
                    cookies
                };
            case "signin":
                if (pages1.signIn) {
                    let signinUrl = `${pages1.signIn}${pages1.signIn.includes("?") ? "&" : "?"}callbackUrl=${encodeURIComponent(options.callbackUrl)}`;
                    if (error) signinUrl = `${signinUrl}&error=${encodeURIComponent(error)}`;
                    return {
                        redirect: signinUrl,
                        cookies
                    };
                }
                return render1.signin();
            case "signout":
                if (pages1.signOut) return {
                    redirect: pages1.signOut,
                    cookies
                };
                return render1.signout();
            case "callback":
                if (options.provider) {
                    const callback = await routes.callback({
                        body: req.body,
                        query: req.query,
                        headers: req.headers,
                        cookies: req.cookies,
                        method,
                        options,
                        sessionStore
                    });
                    if (callback.cookies) cookies.push(...callback.cookies);
                    return {
                        ...callback,
                        cookies
                    };
                }
                break;
            case "verify-request":
                if (pages1.verifyRequest) {
                    return {
                        redirect: pages1.verifyRequest,
                        cookies
                    };
                }
                return render1.verifyRequest();
            case "error":
                if ([
                    "Signin",
                    "OAuthSignin",
                    "OAuthCallback",
                    "OAuthCreateAccount",
                    "EmailCreateAccount",
                    "Callback",
                    "OAuthAccountNotLinked",
                    "EmailSignin",
                    "CredentialsSignin",
                    "SessionRequired"
                ].includes(error)) {
                    return {
                        redirect: `${options.url}/signin?error=${error}`,
                        cookies
                    };
                }
                if (pages1.error) {
                    return {
                        redirect: `${pages1.error}${pages1.error.includes("?") ? "&" : "?"}error=${error}`,
                        cookies
                    };
                }
                return render1.error({
                    error: error
                });
            default:
        }
    } else if (method === "POST") {
        switch(action){
            case "signin":
                if (options.csrfTokenVerified && options.provider) {
                    const signin = await routes.signin({
                        query: req.query,
                        body: req.body,
                        options
                    });
                    if (signin.cookies) cookies.push(...signin.cookies);
                    return {
                        ...signin,
                        cookies
                    };
                }
                return {
                    redirect: `${options.url}/signin?csrf=true`,
                    cookies
                };
            case "signout":
                if (options.csrfTokenVerified) {
                    const signout = await routes.signout({
                        options,
                        sessionStore
                    });
                    if (signout.cookies) cookies.push(...signout.cookies);
                    return {
                        ...signout,
                        cookies
                    };
                }
                return {
                    redirect: `${options.url}/signout?csrf=true`,
                    cookies
                };
            case "callback":
                if (options.provider) {
                    if (options.provider.type === "credentials" && !options.csrfTokenVerified) {
                        return {
                            redirect: `${options.url}/signin?csrf=true`,
                            cookies
                        };
                    }
                    const callback1 = await routes.callback({
                        body: req.body,
                        query: req.query,
                        headers: req.headers,
                        cookies: req.cookies,
                        method,
                        options,
                        sessionStore
                    });
                    if (callback1.cookies) cookies.push(...callback1.cookies);
                    return {
                        ...callback1,
                        cookies
                    };
                }
                break;
            case "_log":
                if (userOptions.logger) {
                    try {
                        var _req$body3;
                        const { code , level , ...metadata } = (_req$body3 = req.body) !== null && _req$body3 !== void 0 ? _req$body3 : {};
                        _logger.default[level](code, metadata);
                    } catch (error1) {
                        _logger.default.error("LOGGER_ERROR", error1);
                    }
                }
                return {};
            default:
        }
    }
    return {
        status: 400,
        body: `Error: This action with HTTP ${method} is not supported by NextAuth.js`
    };
}


/***/ }),

/***/ 26809:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _interopRequireDefault = __webpack_require__(11061);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.init = init;
var _crypto = __webpack_require__(6113);
var _logger = _interopRequireDefault(__webpack_require__(51496));
var _parseUrl = _interopRequireDefault(__webpack_require__(10558));
var _errors = __webpack_require__(83426);
var _providers = _interopRequireDefault(__webpack_require__(7991));
var _utils = __webpack_require__(86314);
var cookie = _interopRequireWildcard(__webpack_require__(67497));
var jwt = _interopRequireWildcard(__webpack_require__(52543));
var _defaultCallbacks = __webpack_require__(19271);
var _csrfToken = __webpack_require__(15229);
var _callbackUrl = __webpack_require__(61921);
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
async function init({ userOptions , providerId , action , host , cookies: reqCookies , callbackUrl: reqCallbackUrl , csrfToken: reqCsrfToken , isPost  }) {
    var _userOptions$useSecur, _userOptions$events;
    const url = (0, _parseUrl.default)(host);
    const secret = (0, _utils.createSecret)({
        userOptions,
        url
    });
    const { providers , provider  } = (0, _providers.default)({
        providers: userOptions.providers,
        url,
        providerId
    });
    const maxAge = 30 * 24 * 60 * 60;
    const options = {
        debug: false,
        pages: {},
        theme: {
            colorScheme: "auto",
            logo: "",
            brandColor: "",
            buttonText: ""
        },
        ...userOptions,
        url,
        action,
        provider,
        cookies: {
            ...cookie.defaultCookies((_userOptions$useSecur = userOptions.useSecureCookies) !== null && _userOptions$useSecur !== void 0 ? _userOptions$useSecur : url.base.startsWith("https://")),
            ...userOptions.cookies
        },
        secret,
        providers,
        session: {
            strategy: userOptions.adapter ? "database" : "jwt",
            maxAge,
            updateAge: 24 * 60 * 60,
            generateSessionToken: ()=>{
                var _randomUUID;
                return (_randomUUID = _crypto.randomUUID === null || _crypto.randomUUID === void 0 ? void 0 : (0, _crypto.randomUUID)()) !== null && _randomUUID !== void 0 ? _randomUUID : (0, _crypto.randomBytes)(32).toString("hex");
            },
            ...userOptions.session
        },
        jwt: {
            secret,
            maxAge,
            encode: jwt.encode,
            decode: jwt.decode,
            ...userOptions.jwt
        },
        events: (0, _errors.eventsErrorHandler)((_userOptions$events = userOptions.events) !== null && _userOptions$events !== void 0 ? _userOptions$events : {}, _logger.default),
        adapter: (0, _errors.adapterErrorHandler)(userOptions.adapter, _logger.default),
        callbacks: {
            ..._defaultCallbacks.defaultCallbacks,
            ...userOptions.callbacks
        },
        logger: _logger.default,
        callbackUrl: url.origin
    };
    const cookies = [];
    const { csrfToken , cookie: csrfCookie , csrfTokenVerified  } = (0, _csrfToken.createCSRFToken)({
        options,
        cookieValue: reqCookies === null || reqCookies === void 0 ? void 0 : reqCookies[options.cookies.csrfToken.name],
        isPost,
        bodyValue: reqCsrfToken
    });
    options.csrfToken = csrfToken;
    options.csrfTokenVerified = csrfTokenVerified;
    if (csrfCookie) {
        cookies.push({
            name: options.cookies.csrfToken.name,
            value: csrfCookie,
            options: options.cookies.csrfToken.options
        });
    }
    const { callbackUrl , callbackUrlCookie  } = await (0, _callbackUrl.createCallbackUrl)({
        options,
        cookieValue: reqCookies === null || reqCookies === void 0 ? void 0 : reqCookies[options.cookies.callbackUrl.name],
        paramValue: reqCallbackUrl
    });
    options.callbackUrl = callbackUrl;
    if (callbackUrlCookie) {
        cookies.push({
            name: options.cookies.callbackUrl.name,
            value: callbackUrlCookie,
            options: options.cookies.callbackUrl.options
        });
    }
    return {
        options,
        cookies
    };
}


/***/ }),

/***/ 23943:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _interopRequireDefault = __webpack_require__(11061);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.assertConfig = assertConfig;
var _errors = __webpack_require__(83426);
var _parseUrl = _interopRequireDefault(__webpack_require__(10558));
var _cookie = __webpack_require__(67497);
let warned = false;
function isValidHttpUrl(url, baseUrl) {
    try {
        return /^https?:/.test(new URL(url, url.startsWith("/") ? baseUrl : undefined).protocol);
    } catch (_unused) {
        return false;
    }
}
function assertConfig(params) {
    var _req$query, _req$query2, _options$useSecureCoo, _req$cookies, _options$cookies$call, _options$cookies, _options$cookies$call2;
    const { options , req  } = params;
    const warnings = [];
    if (!warned) {
        if (!req.host) warnings.push("NEXTAUTH_URL");
        if (!options.secret && "production" !== "production") {}
        if (options.debug) warnings.push("DEBUG_ENABLED");
    }
    if (!options.secret && "production" === "production") {
        return new _errors.MissingSecret("Please define a `secret` in production.");
    }
    if (!((_req$query = req.query) !== null && _req$query !== void 0 && _req$query.nextauth) && !req.action) {
        return new _errors.MissingAPIRoute("Cannot find [...nextauth].{js,ts} in `/pages/api/auth`. Make sure the filename is written correctly.");
    }
    const callbackUrlParam = (_req$query2 = req.query) === null || _req$query2 === void 0 ? void 0 : _req$query2.callbackUrl;
    const url = (0, _parseUrl.default)(req.host);
    if (callbackUrlParam && !isValidHttpUrl(callbackUrlParam, url.base)) {
        return new _errors.InvalidCallbackUrl(`Invalid callback URL. Received: ${callbackUrlParam}`);
    }
    const { callbackUrl: defaultCallbackUrl  } = (0, _cookie.defaultCookies)((_options$useSecureCoo = options.useSecureCookies) !== null && _options$useSecureCoo !== void 0 ? _options$useSecureCoo : url.base.startsWith("https://"));
    const callbackUrlCookie = (_req$cookies = req.cookies) === null || _req$cookies === void 0 ? void 0 : _req$cookies[(_options$cookies$call = (_options$cookies = options.cookies) === null || _options$cookies === void 0 ? void 0 : (_options$cookies$call2 = _options$cookies.callbackUrl) === null || _options$cookies$call2 === void 0 ? void 0 : _options$cookies$call2.name) !== null && _options$cookies$call !== void 0 ? _options$cookies$call : defaultCallbackUrl.name];
    if (callbackUrlCookie && !isValidHttpUrl(callbackUrlCookie, url.base)) {
        return new _errors.InvalidCallbackUrl(`Invalid callback URL. Received: ${callbackUrlCookie}`);
    }
    let hasCredentials, hasEmail;
    let hasTwitterOAuth2;
    for (const provider of options.providers){
        if (provider.type === "credentials") hasCredentials = true;
        else if (provider.type === "email") hasEmail = true;
        else if (provider.id === "twitter" && provider.version === "2.0") hasTwitterOAuth2 = true;
    }
    if (hasCredentials) {
        var _options$session;
        const dbStrategy = ((_options$session = options.session) === null || _options$session === void 0 ? void 0 : _options$session.strategy) === "database";
        const onlyCredentials = !options.providers.some((p)=>p.type !== "credentials");
        if (dbStrategy && onlyCredentials) {
            return new _errors.UnsupportedStrategy("Signin in with credentials only supported if JWT strategy is enabled");
        }
        const credentialsNoAuthorize = options.providers.some((p)=>p.type === "credentials" && !p.authorize);
        if (credentialsNoAuthorize) {
            return new _errors.MissingAuthorize("Must define an authorize() handler to use credentials authentication provider");
        }
    }
    if (hasEmail) {
        const { adapter  } = options;
        if (!adapter) {
            return new _errors.MissingAdapter("E-mail login requires an adapter.");
        }
        const missingMethods = [
            "createVerificationToken",
            "useVerificationToken",
            "getUserByEmail"
        ].filter((method)=>!adapter[method]);
        if (missingMethods.length) {
            return new _errors.MissingAdapterMethods(`Required adapter methods were missing: ${missingMethods.join(", ")}`);
        }
    }
    if (!warned) {
        if (hasTwitterOAuth2) warnings.push("TWITTER_OAUTH_2_BETA");
        warned = true;
    }
    return warnings;
}


/***/ }),

/***/ 80374:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = callbackHandler;
var _errors = __webpack_require__(83426);
var _utils = __webpack_require__(86314);
async function callbackHandler(params) {
    const { sessionToken , profile: _profile , account , options  } = params;
    if (!(account !== null && account !== void 0 && account.providerAccountId) || !account.type) throw new Error("Missing or invalid provider account");
    if (![
        "email",
        "oauth"
    ].includes(account.type)) throw new Error("Provider not supported");
    const { adapter , jwt , events , session: { strategy: sessionStrategy , generateSessionToken  }  } = options;
    if (!adapter) {
        return {
            user: _profile,
            account
        };
    }
    const profile = _profile;
    const { createUser , updateUser , getUser , getUserByAccount , getUserByEmail , linkAccount , createSession , getSessionAndUser , deleteSession  } = adapter;
    let session = null;
    let user = null;
    let isNewUser = false;
    const useJwtSession = sessionStrategy === "jwt";
    if (sessionToken) {
        if (useJwtSession) {
            try {
                session = await jwt.decode({
                    ...jwt,
                    token: sessionToken
                });
                if (session && "sub" in session && session.sub) {
                    user = await getUser(session.sub);
                }
            } catch (_unused) {}
        } else {
            const userAndSession = await getSessionAndUser(sessionToken);
            if (userAndSession) {
                session = userAndSession.session;
                user = userAndSession.user;
            }
        }
    }
    if (account.type === "email") {
        const userByEmail = await getUserByEmail(profile.email);
        if (userByEmail) {
            var _user, _events$updateUser;
            if (((_user = user) === null || _user === void 0 ? void 0 : _user.id) !== userByEmail.id && !useJwtSession && sessionToken) {
                await deleteSession(sessionToken);
            }
            user = await updateUser({
                id: userByEmail.id,
                emailVerified: new Date()
            });
            await ((_events$updateUser = events.updateUser) === null || _events$updateUser === void 0 ? void 0 : _events$updateUser.call(events, {
                user
            }));
        } else {
            var _events$createUser;
            const { id: _ , ...newUser } = {
                ...profile,
                emailVerified: new Date()
            };
            user = await createUser(newUser);
            await ((_events$createUser = events.createUser) === null || _events$createUser === void 0 ? void 0 : _events$createUser.call(events, {
                user
            }));
            isNewUser = true;
        }
        session = useJwtSession ? {} : await createSession({
            sessionToken: generateSessionToken(),
            userId: user.id,
            expires: (0, _utils.fromDate)(options.session.maxAge)
        });
        return {
            session,
            user,
            isNewUser
        };
    } else if (account.type === "oauth") {
        const userByAccount = await getUserByAccount({
            providerAccountId: account.providerAccountId,
            provider: account.provider
        });
        if (userByAccount) {
            if (user) {
                if (userByAccount.id === user.id) {
                    return {
                        session,
                        user,
                        isNewUser
                    };
                }
                throw new _errors.AccountNotLinkedError("The account is already associated with another user");
            }
            session = useJwtSession ? {} : await createSession({
                sessionToken: generateSessionToken(),
                userId: userByAccount.id,
                expires: (0, _utils.fromDate)(options.session.maxAge)
            });
            return {
                session,
                user: userByAccount,
                isNewUser
            };
        } else {
            var _events$createUser2, _events$linkAccount2;
            if (user) {
                var _events$linkAccount;
                await linkAccount({
                    ...account,
                    userId: user.id
                });
                await ((_events$linkAccount = events.linkAccount) === null || _events$linkAccount === void 0 ? void 0 : _events$linkAccount.call(events, {
                    user,
                    account,
                    profile
                }));
                return {
                    session,
                    user,
                    isNewUser
                };
            }
            const userByEmail1 = profile.email ? await getUserByEmail(profile.email) : null;
            if (userByEmail1) {
                const provider = options.provider;
                if (provider !== null && provider !== void 0 && provider.allowDangerousEmailAccountLinking) {
                    user = userByEmail1;
                } else {
                    throw new _errors.AccountNotLinkedError("Another account already exists with the same e-mail address");
                }
            } else {
                const { id: _1 , ...newUser1 } = {
                    ...profile,
                    emailVerified: null
                };
                user = await createUser(newUser1);
            }
            await ((_events$createUser2 = events.createUser) === null || _events$createUser2 === void 0 ? void 0 : _events$createUser2.call(events, {
                user
            }));
            await linkAccount({
                ...account,
                userId: user.id
            });
            await ((_events$linkAccount2 = events.linkAccount) === null || _events$linkAccount2 === void 0 ? void 0 : _events$linkAccount2.call(events, {
                user,
                account,
                profile
            }));
            session = useJwtSession ? {} : await createSession({
                sessionToken: generateSessionToken(),
                userId: user.id,
                expires: (0, _utils.fromDate)(options.session.maxAge)
            });
            return {
                session,
                user,
                isNewUser: true
            };
        }
    }
    throw new Error("Unsupported account type");
}


/***/ }),

/***/ 61921:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.createCallbackUrl = createCallbackUrl;
async function createCallbackUrl({ options , paramValue , cookieValue  }) {
    const { url , callbacks  } = options;
    let callbackUrl = url.origin;
    if (paramValue) {
        callbackUrl = await callbacks.redirect({
            url: paramValue,
            baseUrl: url.origin
        });
    } else if (cookieValue) {
        callbackUrl = await callbacks.redirect({
            url: cookieValue,
            baseUrl: url.origin
        });
    }
    return {
        callbackUrl,
        callbackUrlCookie: callbackUrl !== cookieValue ? callbackUrl : undefined
    };
}


/***/ }),

/***/ 67497:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _interopRequireDefault = __webpack_require__(11061);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.SessionStore = void 0;
exports.defaultCookies = defaultCookies;
var _classPrivateFieldGet3 = _interopRequireDefault(__webpack_require__(18987));
var _classPrivateFieldSet2 = _interopRequireDefault(__webpack_require__(27961));
function _classPrivateMethodInitSpec(obj, privateSet) {
    _checkPrivateRedeclaration(obj, privateSet);
    privateSet.add(obj);
}
function _classPrivateFieldInitSpec(obj, privateMap, value) {
    _checkPrivateRedeclaration(obj, privateMap);
    privateMap.set(obj, value);
}
function _checkPrivateRedeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _classPrivateMethodGet(receiver, privateSet, fn) {
    if (!privateSet.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return fn;
}
const ALLOWED_COOKIE_SIZE = 4096;
const ESTIMATED_EMPTY_COOKIE_SIZE = 163;
const CHUNK_SIZE = ALLOWED_COOKIE_SIZE - ESTIMATED_EMPTY_COOKIE_SIZE;
function defaultCookies(useSecureCookies) {
    const cookiePrefix = useSecureCookies ? "__Secure-" : "";
    return {
        sessionToken: {
            name: `${cookiePrefix}next-auth.session-token`,
            options: {
                httpOnly: true,
                sameSite: "lax",
                path: "/",
                secure: useSecureCookies
            }
        },
        callbackUrl: {
            name: `${cookiePrefix}next-auth.callback-url`,
            options: {
                httpOnly: true,
                sameSite: "lax",
                path: "/",
                secure: useSecureCookies
            }
        },
        csrfToken: {
            name: `${useSecureCookies ? "__Host-" : ""}next-auth.csrf-token`,
            options: {
                httpOnly: true,
                sameSite: "lax",
                path: "/",
                secure: useSecureCookies
            }
        },
        pkceCodeVerifier: {
            name: `${cookiePrefix}next-auth.pkce.code_verifier`,
            options: {
                httpOnly: true,
                sameSite: "lax",
                path: "/",
                secure: useSecureCookies
            }
        },
        state: {
            name: `${cookiePrefix}next-auth.state`,
            options: {
                httpOnly: true,
                sameSite: "lax",
                path: "/",
                secure: useSecureCookies
            }
        },
        nonce: {
            name: `${cookiePrefix}next-auth.nonce`,
            options: {
                httpOnly: true,
                sameSite: "lax",
                path: "/",
                secure: useSecureCookies
            }
        }
    };
}
var _chunks = new WeakMap();
var _option = new WeakMap();
var _logger = new WeakMap();
var _chunk = new WeakSet();
var _clean = new WeakSet();
class SessionStore {
    constructor(option, req, logger){
        _classPrivateMethodInitSpec(this, _clean);
        _classPrivateMethodInitSpec(this, _chunk);
        _classPrivateFieldInitSpec(this, _chunks, {
            writable: true,
            value: {}
        });
        _classPrivateFieldInitSpec(this, _option, {
            writable: true,
            value: void 0
        });
        _classPrivateFieldInitSpec(this, _logger, {
            writable: true,
            value: void 0
        });
        (0, _classPrivateFieldSet2.default)(this, _logger, logger);
        (0, _classPrivateFieldSet2.default)(this, _option, option);
        const { cookies: _cookies  } = req;
        const { name: cookieName  } = option;
        if (typeof (_cookies === null || _cookies === void 0 ? void 0 : _cookies.getAll) === "function") {
            for (const { name , value  } of _cookies.getAll()){
                if (name.startsWith(cookieName)) {
                    (0, _classPrivateFieldGet3.default)(this, _chunks)[name] = value;
                }
            }
        } else if (_cookies instanceof Map) {
            for (const name1 of _cookies.keys()){
                if (name1.startsWith(cookieName)) (0, _classPrivateFieldGet3.default)(this, _chunks)[name1] = _cookies.get(name1);
            }
        } else {
            for(const name2 in _cookies){
                if (name2.startsWith(cookieName)) (0, _classPrivateFieldGet3.default)(this, _chunks)[name2] = _cookies[name2];
            }
        }
    }
    get value() {
        var _Object$values;
        return (_Object$values = Object.values((0, _classPrivateFieldGet3.default)(this, _chunks))) === null || _Object$values === void 0 ? void 0 : _Object$values.join("");
    }
    chunk(value, options) {
        const cookies = _classPrivateMethodGet(this, _clean, _clean2).call(this);
        const chunked = _classPrivateMethodGet(this, _chunk, _chunk2).call(this, {
            name: (0, _classPrivateFieldGet3.default)(this, _option).name,
            value,
            options: {
                ...(0, _classPrivateFieldGet3.default)(this, _option).options,
                ...options
            }
        });
        for (const chunk of chunked){
            cookies[chunk.name] = chunk;
        }
        return Object.values(cookies);
    }
    clean() {
        return Object.values(_classPrivateMethodGet(this, _clean, _clean2).call(this));
    }
}
exports.SessionStore = SessionStore;
function _chunk2(cookie) {
    const chunkCount = Math.ceil(cookie.value.length / CHUNK_SIZE);
    if (chunkCount === 1) {
        (0, _classPrivateFieldGet3.default)(this, _chunks)[cookie.name] = cookie.value;
        return [
            cookie
        ];
    }
    const cookies = [];
    for(let i = 0; i < chunkCount; i++){
        const name = `${cookie.name}.${i}`;
        const value = cookie.value.substr(i * CHUNK_SIZE, CHUNK_SIZE);
        cookies.push({
            ...cookie,
            name,
            value
        });
        (0, _classPrivateFieldGet3.default)(this, _chunks)[name] = value;
    }
    (0, _classPrivateFieldGet3.default)(this, _logger).debug("CHUNKING_SESSION_COOKIE", {
        message: `Session cookie exceeds allowed ${ALLOWED_COOKIE_SIZE} bytes.`,
        emptyCookieSize: ESTIMATED_EMPTY_COOKIE_SIZE,
        valueSize: cookie.value.length,
        chunks: cookies.map((c)=>c.value.length + ESTIMATED_EMPTY_COOKIE_SIZE)
    });
    return cookies;
}
function _clean2() {
    const cleanedChunks = {};
    for(const name in (0, _classPrivateFieldGet3.default)(this, _chunks)){
        var _classPrivateFieldGet2;
        (_classPrivateFieldGet2 = (0, _classPrivateFieldGet3.default)(this, _chunks)) === null || _classPrivateFieldGet2 === void 0 ? true : delete _classPrivateFieldGet2[name];
        cleanedChunks[name] = {
            name,
            value: "",
            options: {
                ...(0, _classPrivateFieldGet3.default)(this, _option).options,
                maxAge: 0
            }
        };
    }
    return cleanedChunks;
}


/***/ }),

/***/ 15229:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.createCSRFToken = createCSRFToken;
var _crypto = __webpack_require__(6113);
function createCSRFToken({ options , cookieValue , isPost , bodyValue  }) {
    if (cookieValue) {
        const [csrfToken, csrfTokenHash] = cookieValue.split("|");
        const expectedCsrfTokenHash = (0, _crypto.createHash)("sha256").update(`${csrfToken}${options.secret}`).digest("hex");
        if (csrfTokenHash === expectedCsrfTokenHash) {
            const csrfTokenVerified = isPost && csrfToken === bodyValue;
            return {
                csrfTokenVerified,
                csrfToken
            };
        }
    }
    const csrfToken1 = (0, _crypto.randomBytes)(32).toString("hex");
    const csrfTokenHash1 = (0, _crypto.createHash)("sha256").update(`${csrfToken1}${options.secret}`).digest("hex");
    const cookie = `${csrfToken1}|${csrfTokenHash1}`;
    return {
        cookie,
        csrfToken: csrfToken1
    };
}


/***/ }),

/***/ 19271:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.defaultCallbacks = void 0;
const defaultCallbacks = {
    signIn () {
        return true;
    },
    redirect ({ url , baseUrl  }) {
        if (url.startsWith("/")) return `${baseUrl}${url}`;
        else if (new URL(url).origin === baseUrl) return url;
        return baseUrl;
    },
    session ({ session  }) {
        return session;
    },
    jwt ({ token  }) {
        return token;
    }
};
exports.defaultCallbacks = defaultCallbacks;


/***/ }),

/***/ 82740:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = getAdapterUserFromEmail;
async function getAdapterUserFromEmail({ email , adapter  }) {
    const { getUserByEmail  } = adapter;
    const adapterUser = email ? await getUserByEmail(email) : null;
    if (adapterUser) return adapterUser;
    return {
        id: email,
        email,
        emailVerified: null
    };
}


/***/ }),

/***/ 69966:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = email;
var _crypto = __webpack_require__(6113);
var _utils = __webpack_require__(86314);
async function email(identifier, options) {
    var _await$provider$gener, _provider$generateVer, _provider$maxAge;
    const { url , adapter , provider , callbackUrl , theme  } = options;
    const token = (_await$provider$gener = await ((_provider$generateVer = provider.generateVerificationToken) === null || _provider$generateVer === void 0 ? void 0 : _provider$generateVer.call(provider))) !== null && _await$provider$gener !== void 0 ? _await$provider$gener : (0, _crypto.randomBytes)(32).toString("hex");
    const ONE_DAY_IN_SECONDS = 86400;
    const expires = new Date(Date.now() + ((_provider$maxAge = provider.maxAge) !== null && _provider$maxAge !== void 0 ? _provider$maxAge : ONE_DAY_IN_SECONDS) * 1000);
    const params = new URLSearchParams({
        callbackUrl,
        token,
        email: identifier
    });
    const _url = `${url}/callback/${provider.id}?${params}`;
    await Promise.all([
        provider.sendVerificationRequest({
            identifier,
            token,
            expires,
            url: _url,
            provider,
            theme
        }),
        adapter.createVerificationToken({
            identifier,
            token: (0, _utils.hashToken)(token, options),
            expires
        })
    ]);
    return `${url}/verify-request?${new URLSearchParams({
        provider: provider.id,
        type: provider.type
    })}`;
}


/***/ }),

/***/ 17376:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = getAuthorizationUrl;
var _client = __webpack_require__(99652);
var _clientLegacy = __webpack_require__(50273);
var _stateHandler = __webpack_require__(98304);
var _nonceHandler = __webpack_require__(24087);
var _pkceHandler = __webpack_require__(21993);
async function getAuthorizationUrl({ options , query  }) {
    var _provider$version;
    const { logger , provider  } = options;
    let params = {};
    if (typeof provider.authorization === "string") {
        const parsedUrl = new URL(provider.authorization);
        const parsedParams = Object.fromEntries(parsedUrl.searchParams);
        params = {
            ...params,
            ...parsedParams
        };
    } else {
        var _provider$authorizati;
        params = {
            ...params,
            ...(_provider$authorizati = provider.authorization) === null || _provider$authorizati === void 0 ? void 0 : _provider$authorizati.params
        };
    }
    params = {
        ...params,
        ...query
    };
    if ((_provider$version = provider.version) !== null && _provider$version !== void 0 && _provider$version.startsWith("1.")) {
        var _provider$authorizati2;
        const client = (0, _clientLegacy.oAuth1Client)(options);
        const tokens = await client.getOAuthRequestToken(params);
        const url = `${(_provider$authorizati2 = provider.authorization) === null || _provider$authorizati2 === void 0 ? void 0 : _provider$authorizati2.url}?${new URLSearchParams({
            oauth_token: tokens.oauth_token,
            oauth_token_secret: tokens.oauth_token_secret,
            ...tokens.params
        })}`;
        logger.debug("GET_AUTHORIZATION_URL", {
            url,
            provider
        });
        return {
            redirect: url
        };
    }
    const client1 = await (0, _client.openidClient)(options);
    const authorizationParams = params;
    const cookies = [];
    const state = await (0, _stateHandler.createState)(options);
    if (state) {
        authorizationParams.state = state.value;
        cookies.push(state.cookie);
    }
    const nonce = await (0, _nonceHandler.createNonce)(options);
    if (nonce) {
        authorizationParams.nonce = nonce.value;
        cookies.push(nonce.cookie);
    }
    const pkce = await (0, _pkceHandler.createPKCE)(options);
    if (pkce) {
        authorizationParams.code_challenge = pkce.code_challenge;
        authorizationParams.code_challenge_method = pkce.code_challenge_method;
        cookies.push(pkce.cookie);
    }
    const url1 = client1.authorizationUrl(authorizationParams);
    logger.debug("GET_AUTHORIZATION_URL", {
        url: url1,
        cookies,
        provider
    });
    return {
        redirect: url1,
        cookies
    };
}


/***/ }),

/***/ 80418:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = oAuthCallback;
var _openidClient = __webpack_require__(87584);
var _client = __webpack_require__(99652);
var _clientLegacy = __webpack_require__(50273);
var _stateHandler = __webpack_require__(98304);
var _pkceHandler = __webpack_require__(21993);
var _nonceHandler = __webpack_require__(24087);
var _errors = __webpack_require__(83426);
async function oAuthCallback(params) {
    var _body$error, _provider$version;
    const { options , query , body , method , cookies  } = params;
    const { logger , provider  } = options;
    const errorMessage = (_body$error = body === null || body === void 0 ? void 0 : body.error) !== null && _body$error !== void 0 ? _body$error : query === null || query === void 0 ? void 0 : query.error;
    if (errorMessage) {
        const error = new Error(errorMessage);
        logger.error("OAUTH_CALLBACK_HANDLER_ERROR", {
            error,
            error_description: query === null || query === void 0 ? void 0 : query.error_description,
            providerId: provider.id
        });
        logger.debug("OAUTH_CALLBACK_HANDLER_ERROR", {
            body
        });
        throw error;
    }
    if ((_provider$version = provider.version) !== null && _provider$version !== void 0 && _provider$version.startsWith("1.")) {
        try {
            const client = await (0, _clientLegacy.oAuth1Client)(options);
            const { oauth_token , oauth_verifier  } = query !== null && query !== void 0 ? query : {};
            const tokens = await client.getOAuthAccessToken(oauth_token, null, oauth_verifier);
            let profile = await client.get(provider.profileUrl, tokens.oauth_token, tokens.oauth_token_secret);
            if (typeof profile === "string") {
                profile = JSON.parse(profile);
            }
            const newProfile = await getProfile({
                profile,
                tokens,
                provider,
                logger
            });
            return {
                ...newProfile,
                cookies: []
            };
        } catch (error1) {
            logger.error("OAUTH_V1_GET_ACCESS_TOKEN_ERROR", error1);
            throw error1;
        }
    }
    try {
        var _provider$token, _provider$token2, _provider$userinfo;
        const client1 = await (0, _client.openidClient)(options);
        let tokens1;
        const checks = {};
        const resCookies = [];
        const state = await (0, _stateHandler.useState)(cookies === null || cookies === void 0 ? void 0 : cookies[options.cookies.state.name], options);
        if (state) {
            checks.state = state.value;
            resCookies.push(state.cookie);
        }
        const nonce = await (0, _nonceHandler.useNonce)(cookies === null || cookies === void 0 ? void 0 : cookies[options.cookies.nonce.name], options);
        if (nonce && provider.idToken) {
            ;
            checks.nonce = nonce.value;
            resCookies.push(nonce.cookie);
        }
        const codeVerifier = cookies === null || cookies === void 0 ? void 0 : cookies[options.cookies.pkceCodeVerifier.name];
        const pkce = await (0, _pkceHandler.usePKCECodeVerifier)(codeVerifier, options);
        if (pkce) {
            checks.code_verifier = pkce.codeVerifier;
            resCookies.push(pkce.cookie);
        }
        const params1 = {
            ...client1.callbackParams({
                url: `http://n?${new URLSearchParams(query)}`,
                body,
                method
            }),
            ...(_provider$token = provider.token) === null || _provider$token === void 0 ? void 0 : _provider$token.params
        };
        if ((_provider$token2 = provider.token) !== null && _provider$token2 !== void 0 && _provider$token2.request) {
            const response = await provider.token.request({
                provider,
                params: params1,
                checks,
                client: client1
            });
            tokens1 = new _openidClient.TokenSet(response.tokens);
        } else if (provider.idToken) {
            tokens1 = await client1.callback(provider.callbackUrl, params1, checks);
        } else {
            tokens1 = await client1.oauthCallback(provider.callbackUrl, params1, checks);
        }
        if (Array.isArray(tokens1.scope)) {
            tokens1.scope = tokens1.scope.join(" ");
        }
        let profile1;
        if ((_provider$userinfo = provider.userinfo) !== null && _provider$userinfo !== void 0 && _provider$userinfo.request) {
            profile1 = await provider.userinfo.request({
                provider,
                tokens: tokens1,
                client: client1
            });
        } else if (provider.idToken) {
            profile1 = tokens1.claims();
        } else {
            var _provider$userinfo2;
            profile1 = await client1.userinfo(tokens1, {
                params: (_provider$userinfo2 = provider.userinfo) === null || _provider$userinfo2 === void 0 ? void 0 : _provider$userinfo2.params
            });
        }
        const profileResult = await getProfile({
            profile: profile1,
            provider,
            tokens: tokens1,
            logger
        });
        return {
            ...profileResult,
            cookies: resCookies
        };
    } catch (error2) {
        throw new _errors.OAuthCallbackError(error2);
    }
}
async function getProfile({ profile: OAuthProfile , tokens , provider , logger  }) {
    try {
        var _profile$email;
        logger.debug("PROFILE_DATA", {
            OAuthProfile
        });
        const profile = await provider.profile(OAuthProfile, tokens);
        profile.email = (_profile$email = profile.email) === null || _profile$email === void 0 ? void 0 : _profile$email.toLowerCase();
        if (!profile.id) throw new TypeError(`Profile id is missing in ${provider.name} OAuth profile response`);
        return {
            profile,
            account: {
                provider: provider.id,
                type: provider.type,
                providerAccountId: profile.id.toString(),
                ...tokens
            },
            OAuthProfile
        };
    } catch (error) {
        logger.error("OAUTH_PARSE_PROFILE_ERROR", {
            error: error,
            OAuthProfile
        });
    }
}


/***/ }),

/***/ 50273:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.oAuth1Client = oAuth1Client;
var _oauth = __webpack_require__(1279);
function oAuth1Client(options) {
    var _provider$version, _provider$encoding;
    const provider = options.provider;
    const oauth1Client = new _oauth.OAuth(provider.requestTokenUrl, provider.accessTokenUrl, provider.clientId, provider.clientSecret, (_provider$version = provider.version) !== null && _provider$version !== void 0 ? _provider$version : "1.0", provider.callbackUrl, (_provider$encoding = provider.encoding) !== null && _provider$encoding !== void 0 ? _provider$encoding : "HMAC-SHA1");
    const originalGet = oauth1Client.get.bind(oauth1Client);
    oauth1Client.get = async (...args)=>{
        return await new Promise((resolve, reject)=>{
            originalGet(...args, (error, result)=>{
                if (error) {
                    return reject(error);
                }
                resolve(result);
            });
        });
    };
    const originalGetOAuth1AccessToken = oauth1Client.getOAuthAccessToken.bind(oauth1Client);
    oauth1Client.getOAuthAccessToken = async (...args)=>{
        return await new Promise((resolve, reject)=>{
            originalGetOAuth1AccessToken(...args, (error, oauth_token, oauth_token_secret)=>{
                if (error) {
                    return reject(error);
                }
                resolve({
                    oauth_token,
                    oauth_token_secret
                });
            });
        });
    };
    const originalGetOAuthRequestToken = oauth1Client.getOAuthRequestToken.bind(oauth1Client);
    oauth1Client.getOAuthRequestToken = async (params = {})=>{
        return await new Promise((resolve, reject)=>{
            originalGetOAuthRequestToken(params, (error, oauth_token, oauth_token_secret, params)=>{
                if (error) {
                    return reject(error);
                }
                resolve({
                    oauth_token,
                    oauth_token_secret,
                    params
                });
            });
        });
    };
    return oauth1Client;
}


/***/ }),

/***/ 99652:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.openidClient = openidClient;
var _openidClient = __webpack_require__(87584);
async function openidClient(options) {
    const provider = options.provider;
    if (provider.httpOptions) _openidClient.custom.setHttpOptionsDefaults(provider.httpOptions);
    let issuer;
    if (provider.wellKnown) {
        issuer = await _openidClient.Issuer.discover(provider.wellKnown);
    } else {
        var _provider$authorizati, _provider$token, _provider$userinfo;
        issuer = new _openidClient.Issuer({
            issuer: provider.issuer,
            authorization_endpoint: (_provider$authorizati = provider.authorization) === null || _provider$authorizati === void 0 ? void 0 : _provider$authorizati.url,
            token_endpoint: (_provider$token = provider.token) === null || _provider$token === void 0 ? void 0 : _provider$token.url,
            userinfo_endpoint: (_provider$userinfo = provider.userinfo) === null || _provider$userinfo === void 0 ? void 0 : _provider$userinfo.url
        });
    }
    const client = new issuer.Client({
        client_id: provider.clientId,
        client_secret: provider.clientSecret,
        redirect_uris: [
            provider.callbackUrl
        ],
        ...provider.client
    }, provider.jwks);
    client[_openidClient.custom.clock_tolerance] = 10;
    return client;
}


/***/ }),

/***/ 24087:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.createNonce = createNonce;
exports.useNonce = useNonce;
var jwt = _interopRequireWildcard(__webpack_require__(52543));
var _openidClient = __webpack_require__(87584);
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const NONCE_MAX_AGE = 60 * 15;
async function createNonce(options) {
    var _provider$checks;
    const { cookies , logger , provider  } = options;
    if (!((_provider$checks = provider.checks) !== null && _provider$checks !== void 0 && _provider$checks.includes("nonce"))) {
        return;
    }
    const nonce = _openidClient.generators.nonce();
    const expires = new Date();
    expires.setTime(expires.getTime() + NONCE_MAX_AGE * 1000);
    const encryptedNonce = await jwt.encode({
        ...options.jwt,
        maxAge: NONCE_MAX_AGE,
        token: {
            nonce
        }
    });
    logger.debug("CREATE_ENCRYPTED_NONCE", {
        nonce,
        maxAge: NONCE_MAX_AGE
    });
    return {
        cookie: {
            name: cookies.nonce.name,
            value: encryptedNonce,
            options: {
                ...cookies.nonce.options,
                expires
            }
        },
        value: nonce
    };
}
async function useNonce(nonce, options) {
    var _provider$checks2, _value$nonce;
    const { cookies , provider  } = options;
    if (!(provider !== null && provider !== void 0 && (_provider$checks2 = provider.checks) !== null && _provider$checks2 !== void 0 && _provider$checks2.includes("nonce")) || !nonce) {
        return;
    }
    const value = await jwt.decode({
        ...options.jwt,
        token: nonce
    });
    return {
        value: (_value$nonce = value === null || value === void 0 ? void 0 : value.nonce) !== null && _value$nonce !== void 0 ? _value$nonce : undefined,
        cookie: {
            name: cookies.nonce.name,
            value: "",
            options: {
                ...cookies.nonce.options,
                maxAge: 0
            }
        }
    };
}


/***/ }),

/***/ 21993:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.createPKCE = createPKCE;
exports.usePKCECodeVerifier = usePKCECodeVerifier;
var jwt = _interopRequireWildcard(__webpack_require__(52543));
var _openidClient = __webpack_require__(87584);
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const PKCE_CODE_CHALLENGE_METHOD = "S256";
const PKCE_MAX_AGE = 60 * 15;
async function createPKCE(options) {
    var _provider$checks;
    const { cookies , logger , provider  } = options;
    if (!((_provider$checks = provider.checks) !== null && _provider$checks !== void 0 && _provider$checks.includes("pkce"))) {
        return;
    }
    const code_verifier = _openidClient.generators.codeVerifier();
    const code_challenge = _openidClient.generators.codeChallenge(code_verifier);
    const expires = new Date();
    expires.setTime(expires.getTime() + PKCE_MAX_AGE * 1000);
    const encryptedCodeVerifier = await jwt.encode({
        ...options.jwt,
        maxAge: PKCE_MAX_AGE,
        token: {
            code_verifier
        }
    });
    logger.debug("CREATE_PKCE_CHALLENGE_VERIFIER", {
        code_challenge,
        code_challenge_method: PKCE_CODE_CHALLENGE_METHOD,
        code_verifier,
        PKCE_MAX_AGE
    });
    return {
        code_challenge,
        code_challenge_method: PKCE_CODE_CHALLENGE_METHOD,
        cookie: {
            name: cookies.pkceCodeVerifier.name,
            value: encryptedCodeVerifier,
            options: {
                ...cookies.pkceCodeVerifier.options,
                expires
            }
        }
    };
}
async function usePKCECodeVerifier(codeVerifier, options) {
    var _provider$checks2, _pkce$code_verifier;
    const { cookies , provider  } = options;
    if (!(provider !== null && provider !== void 0 && (_provider$checks2 = provider.checks) !== null && _provider$checks2 !== void 0 && _provider$checks2.includes("pkce")) || !codeVerifier) {
        return;
    }
    const pkce = await jwt.decode({
        ...options.jwt,
        token: codeVerifier
    });
    return {
        codeVerifier: (_pkce$code_verifier = pkce === null || pkce === void 0 ? void 0 : pkce.code_verifier) !== null && _pkce$code_verifier !== void 0 ? _pkce$code_verifier : undefined,
        cookie: {
            name: cookies.pkceCodeVerifier.name,
            value: "",
            options: {
                ...cookies.pkceCodeVerifier.options,
                maxAge: 0
            }
        }
    };
}


/***/ }),

/***/ 98304:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.createState = createState;
exports.useState = useState;
var _openidClient = __webpack_require__(87584);
const STATE_MAX_AGE = 60 * 15;
async function createState(options) {
    var _provider$checks;
    const { logger , provider , jwt , cookies  } = options;
    if (!((_provider$checks = provider.checks) !== null && _provider$checks !== void 0 && _provider$checks.includes("state"))) {
        return;
    }
    const state = _openidClient.generators.state();
    const encodedState = await jwt.encode({
        ...jwt,
        maxAge: STATE_MAX_AGE,
        token: {
            state
        }
    });
    logger.debug("CREATE_STATE", {
        state,
        maxAge: STATE_MAX_AGE
    });
    const expires = new Date();
    expires.setTime(expires.getTime() + STATE_MAX_AGE * 1000);
    return {
        value: state,
        cookie: {
            name: cookies.state.name,
            value: encodedState,
            options: {
                ...cookies.state.options,
                expires
            }
        }
    };
}
async function useState(state, options) {
    var _provider$checks2, _value$state;
    const { cookies , provider , jwt  } = options;
    if (!((_provider$checks2 = provider.checks) !== null && _provider$checks2 !== void 0 && _provider$checks2.includes("state")) || !state) return;
    const value = await jwt.decode({
        ...options.jwt,
        token: state
    });
    return {
        value: (_value$state = value === null || value === void 0 ? void 0 : value.state) !== null && _value$state !== void 0 ? _value$state : undefined,
        cookie: {
            name: cookies.state.name,
            value: "",
            options: {
                ...cookies.pkceCodeVerifier.options,
                maxAge: 0
            }
        }
    };
}


/***/ }),

/***/ 7991:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = parseProviders;
var _merge = __webpack_require__(93283);
function parseProviders(params) {
    const { url , providerId  } = params;
    const providers = params.providers.map(({ options: userOptions , ...rest })=>{
        var _ref;
        if (rest.type === "oauth") {
            var _normalizedUserOption;
            const normalizedOptions = normalizeOAuthOptions(rest);
            const normalizedUserOptions = normalizeOAuthOptions(userOptions, true);
            const id = (_normalizedUserOption = normalizedUserOptions === null || normalizedUserOptions === void 0 ? void 0 : normalizedUserOptions.id) !== null && _normalizedUserOption !== void 0 ? _normalizedUserOption : rest.id;
            return (0, _merge.merge)(normalizedOptions, {
                ...normalizedUserOptions,
                signinUrl: `${url}/signin/${id}`,
                callbackUrl: `${url}/callback/${id}`
            });
        }
        const id1 = (_ref = userOptions === null || userOptions === void 0 ? void 0 : userOptions.id) !== null && _ref !== void 0 ? _ref : rest.id;
        return (0, _merge.merge)(rest, {
            ...userOptions,
            signinUrl: `${url}/signin/${id1}`,
            callbackUrl: `${url}/callback/${id1}`
        });
    });
    return {
        providers,
        provider: providers.find(({ id  })=>id === providerId)
    };
}
function normalizeOAuthOptions(oauthOptions, isUserOptions = false) {
    var _normalized$version;
    if (!oauthOptions) return;
    const normalized = Object.entries(oauthOptions).reduce((acc, [key, value])=>{
        if ([
            "authorization",
            "token",
            "userinfo"
        ].includes(key) && typeof value === "string") {
            var _url$searchParams;
            const url = new URL(value);
            acc[key] = {
                url: `${url.origin}${url.pathname}`,
                params: Object.fromEntries((_url$searchParams = url.searchParams) !== null && _url$searchParams !== void 0 ? _url$searchParams : [])
            };
        } else {
            acc[key] = value;
        }
        return acc;
    }, {});
    if (!isUserOptions && !((_normalized$version = normalized.version) !== null && _normalized$version !== void 0 && _normalized$version.startsWith("1."))) {
        var _ref2, _normalized$idToken, _normalized$wellKnown, _normalized$authoriza, _normalized$authoriza2, _normalized$authoriza3;
        normalized.idToken = Boolean((_ref2 = (_normalized$idToken = normalized.idToken) !== null && _normalized$idToken !== void 0 ? _normalized$idToken : (_normalized$wellKnown = normalized.wellKnown) === null || _normalized$wellKnown === void 0 ? void 0 : _normalized$wellKnown.includes("openid-configuration")) !== null && _ref2 !== void 0 ? _ref2 : (_normalized$authoriza = normalized.authorization) === null || _normalized$authoriza === void 0 ? void 0 : (_normalized$authoriza2 = _normalized$authoriza.params) === null || _normalized$authoriza2 === void 0 ? void 0 : (_normalized$authoriza3 = _normalized$authoriza2.scope) === null || _normalized$authoriza3 === void 0 ? void 0 : _normalized$authoriza3.includes("openid"));
        if (!normalized.checks) normalized.checks = [
            "state"
        ];
    }
    return normalized;
}


/***/ }),

/***/ 86314:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.createSecret = createSecret;
exports.fromDate = fromDate;
exports.hashToken = hashToken;
var _crypto = __webpack_require__(6113);
function fromDate(time, date = Date.now()) {
    return new Date(date + time * 1000);
}
function hashToken(token, options) {
    var _provider$secret;
    const { provider , secret  } = options;
    return (0, _crypto.createHash)("sha256").update(`${token}${(_provider$secret = provider.secret) !== null && _provider$secret !== void 0 ? _provider$secret : secret}`).digest("hex");
}
function createSecret(params) {
    var _userOptions$secret;
    const { userOptions , url  } = params;
    return (_userOptions$secret = userOptions.secret) !== null && _userOptions$secret !== void 0 ? _userOptions$secret : (0, _crypto.createHash)("sha256").update(JSON.stringify({
        ...url,
        ...userOptions
    })).digest("hex");
}


/***/ }),

/***/ 15792:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = ErrorPage;
var _preact = __webpack_require__(30066);
function ErrorPage(props) {
    var _errors$error$toLower;
    const { url , error ="default" , theme  } = props;
    const signinPageUrl = `${url}/signin`;
    const errors = {
        default: {
            status: 200,
            heading: "Error",
            message: (0, _preact.h)("p", null, (0, _preact.h)("a", {
                className: "site",
                href: url === null || url === void 0 ? void 0 : url.origin
            }, url === null || url === void 0 ? void 0 : url.host))
        },
        configuration: {
            status: 500,
            heading: "Server error",
            message: (0, _preact.h)("div", null, (0, _preact.h)("p", null, "There is a problem with the server configuration."), (0, _preact.h)("p", null, "Check the server logs for more information."))
        },
        accessdenied: {
            status: 403,
            heading: "Access Denied",
            message: (0, _preact.h)("div", null, (0, _preact.h)("p", null, "You do not have permission to sign in."), (0, _preact.h)("p", null, (0, _preact.h)("a", {
                className: "button",
                href: signinPageUrl
            }, "Sign in")))
        },
        verification: {
            status: 403,
            heading: "Unable to sign in",
            message: (0, _preact.h)("div", null, (0, _preact.h)("p", null, "The sign in link is no longer valid."), (0, _preact.h)("p", null, "It may have been used already or it may have expired.")),
            signin: (0, _preact.h)("p", null, (0, _preact.h)("a", {
                className: "button",
                href: signinPageUrl
            }, "Sign in"))
        }
    };
    const { status , heading , message , signin  } = (_errors$error$toLower = errors[error.toLowerCase()]) !== null && _errors$error$toLower !== void 0 ? _errors$error$toLower : errors.default;
    return {
        status,
        html: (0, _preact.h)("div", {
            className: "error"
        }, (theme === null || theme === void 0 ? void 0 : theme.brandColor) && (0, _preact.h)("style", {
            dangerouslySetInnerHTML: {
                __html: `
        :root {
          --brand-color: ${theme === null || theme === void 0 ? void 0 : theme.brandColor}
        }
      `
            }
        }), (theme === null || theme === void 0 ? void 0 : theme.logo) && (0, _preact.h)("img", {
            src: theme.logo,
            alt: "Logo",
            className: "logo"
        }), (0, _preact.h)("div", {
            className: "card"
        }, (0, _preact.h)("h1", null, heading), (0, _preact.h)("div", {
            className: "message"
        }, message), signin))
    };
}


/***/ }),

/***/ 51685:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _interopRequireDefault = __webpack_require__(11061);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = renderPage;
var _preactRenderToString = _interopRequireDefault(__webpack_require__(63093));
var _signin = _interopRequireDefault(__webpack_require__(72126));
var _signout = _interopRequireDefault(__webpack_require__(8041));
var _verifyRequest = _interopRequireDefault(__webpack_require__(82608));
var _error = _interopRequireDefault(__webpack_require__(15792));
var _css = _interopRequireDefault(__webpack_require__(22944));
function renderPage(params) {
    const { url , theme , query , cookies  } = params;
    function send({ html , title , status  }) {
        var _theme$colorScheme;
        return {
            cookies,
            status,
            headers: [
                {
                    key: "Content-Type",
                    value: "text/html"
                }
            ],
            body: `<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><style>${(0, _css.default)()}</style><title>${title}</title></head><body class="__next-auth-theme-${(_theme$colorScheme = theme === null || theme === void 0 ? void 0 : theme.colorScheme) !== null && _theme$colorScheme !== void 0 ? _theme$colorScheme : "auto"}"><div class="page">${(0, _preactRenderToString.default)(html)}</div></body></html>`
        };
    }
    return {
        signin (props) {
            return send({
                html: (0, _signin.default)({
                    csrfToken: params.csrfToken,
                    providers: params.providers,
                    callbackUrl: params.callbackUrl,
                    theme,
                    ...query,
                    ...props
                }),
                title: "Sign In"
            });
        },
        signout (props) {
            return send({
                html: (0, _signout.default)({
                    csrfToken: params.csrfToken,
                    url,
                    theme,
                    ...props
                }),
                title: "Sign Out"
            });
        },
        verifyRequest (props) {
            return send({
                html: (0, _verifyRequest.default)({
                    url,
                    theme,
                    ...props
                }),
                title: "Verify Request"
            });
        },
        error (props) {
            return send({
                ...(0, _error.default)({
                    url,
                    theme,
                    ...props
                }),
                title: "Error"
            });
        }
    };
}


/***/ }),

/***/ 72126:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _interopRequireDefault = __webpack_require__(11061);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = SigninPage;
var _preact = __webpack_require__(30066);
var _extends2 = _interopRequireDefault(__webpack_require__(81370));
function SigninPage(props) {
    var _errors$errorType;
    const { csrfToken , providers , callbackUrl , theme , email , error: errorType  } = props;
    const providersToRender = providers.filter((provider)=>{
        if (provider.type === "oauth" || provider.type === "email") {
            return true;
        } else if (provider.type === "credentials" && provider.credentials) {
            return true;
        }
        return false;
    });
    if (typeof document !== "undefined" && theme.brandColor) {
        document.documentElement.style.setProperty("--brand-color", theme.brandColor);
    }
    const errors = {
        Signin: "Try signing in with a different account.",
        OAuthSignin: "Try signing in with a different account.",
        OAuthCallback: "Try signing in with a different account.",
        OAuthCreateAccount: "Try signing in with a different account.",
        EmailCreateAccount: "Try signing in with a different account.",
        Callback: "Try signing in with a different account.",
        OAuthAccountNotLinked: "To confirm your identity, sign in with the same account you used originally.",
        EmailSignin: "The e-mail could not be sent.",
        CredentialsSignin: "Sign in failed. Check the details you provided are correct.",
        SessionRequired: "Please sign in to access this page.",
        default: "Unable to sign in."
    };
    const error = errorType && ((_errors$errorType = errors[errorType]) !== null && _errors$errorType !== void 0 ? _errors$errorType : errors.default);
    return (0, _preact.h)("div", {
        className: "signin"
    }, theme.brandColor && (0, _preact.h)("style", {
        dangerouslySetInnerHTML: {
            __html: `
        :root {
          --brand-color: ${theme.brandColor}
        }
      `
        }
    }), theme.logo && (0, _preact.h)("img", {
        src: theme.logo,
        alt: "Logo",
        className: "logo"
    }), (0, _preact.h)("div", {
        className: "card"
    }, error && (0, _preact.h)("div", {
        className: "error"
    }, (0, _preact.h)("p", null, error)), providersToRender.map((provider, i)=>{
        var _provider$style$bg, _provider$style, _provider$style$bgDar, _provider$style2, _provider$style$text, _provider$style3, _provider$style$textD, _provider$style4, _provider$style5, _provider$style6;
        return (0, _preact.h)("div", {
            key: provider.id,
            className: "provider"
        }, provider.type === "oauth" && (0, _preact.h)("form", {
            action: provider.signinUrl,
            method: "POST"
        }, (0, _preact.h)("input", {
            type: "hidden",
            name: "csrfToken",
            value: csrfToken
        }), callbackUrl && (0, _preact.h)("input", {
            type: "hidden",
            name: "callbackUrl",
            value: callbackUrl
        }), (0, _preact.h)("button", {
            type: "submit",
            className: "button",
            style: {
                "--provider-bg": (_provider$style$bg = (_provider$style = provider.style) === null || _provider$style === void 0 ? void 0 : _provider$style.bg) !== null && _provider$style$bg !== void 0 ? _provider$style$bg : "",
                "--provider-dark-bg": (_provider$style$bgDar = (_provider$style2 = provider.style) === null || _provider$style2 === void 0 ? void 0 : _provider$style2.bgDark) !== null && _provider$style$bgDar !== void 0 ? _provider$style$bgDar : "",
                "--provider-color": (_provider$style$text = (_provider$style3 = provider.style) === null || _provider$style3 === void 0 ? void 0 : _provider$style3.text) !== null && _provider$style$text !== void 0 ? _provider$style$text : "",
                "--provider-dark-color": (_provider$style$textD = (_provider$style4 = provider.style) === null || _provider$style4 === void 0 ? void 0 : _provider$style4.textDark) !== null && _provider$style$textD !== void 0 ? _provider$style$textD : ""
            }
        }, ((_provider$style5 = provider.style) === null || _provider$style5 === void 0 ? void 0 : _provider$style5.logo) && (0, _preact.h)("img", {
            id: "provider-logo",
            src: provider.style.logo
        }), ((_provider$style6 = provider.style) === null || _provider$style6 === void 0 ? void 0 : _provider$style6.logoDark) && (0, _preact.h)("img", {
            id: "provider-logo-dark",
            src: provider.style.logoDark
        }), (0, _preact.h)("span", null, "Sign in with ", provider.name))), (provider.type === "email" || provider.type === "credentials") && i > 0 && providersToRender[i - 1].type !== "email" && providersToRender[i - 1].type !== "credentials" && (0, _preact.h)("hr", null), provider.type === "email" && (0, _preact.h)("form", {
            action: provider.signinUrl,
            method: "POST"
        }, (0, _preact.h)("input", {
            type: "hidden",
            name: "csrfToken",
            value: csrfToken
        }), (0, _preact.h)("label", {
            className: "section-header",
            htmlFor: `input-email-for-${provider.id}-provider`
        }, "Email"), (0, _preact.h)("input", {
            id: `input-email-for-${provider.id}-provider`,
            autoFocus: true,
            type: "email",
            name: "email",
            value: email,
            placeholder: "email@example.com",
            required: true
        }), (0, _preact.h)("button", {
            type: "submit"
        }, "Sign in with ", provider.name)), provider.type === "credentials" && (0, _preact.h)("form", {
            action: provider.callbackUrl,
            method: "POST"
        }, (0, _preact.h)("input", {
            type: "hidden",
            name: "csrfToken",
            value: csrfToken
        }), Object.keys(provider.credentials).map((credential)=>{
            var _provider$credentials, _provider$credentials2, _provider$credentials3;
            return (0, _preact.h)("div", {
                key: `input-group-${provider.id}`
            }, (0, _preact.h)("label", {
                className: "section-header",
                htmlFor: `input-${credential}-for-${provider.id}-provider`
            }, (_provider$credentials = provider.credentials[credential].label) !== null && _provider$credentials !== void 0 ? _provider$credentials : credential), (0, _preact.h)("input", (0, _extends2.default)({
                name: credential,
                id: `input-${credential}-for-${provider.id}-provider`,
                type: (_provider$credentials2 = provider.credentials[credential].type) !== null && _provider$credentials2 !== void 0 ? _provider$credentials2 : "text",
                placeholder: (_provider$credentials3 = provider.credentials[credential].placeholder) !== null && _provider$credentials3 !== void 0 ? _provider$credentials3 : ""
            }, provider.credentials[credential])));
        }), (0, _preact.h)("button", {
            type: "submit"
        }, "Sign in with ", provider.name)), (provider.type === "email" || provider.type === "credentials") && i + 1 < providersToRender.length && (0, _preact.h)("hr", null));
    })));
}


/***/ }),

/***/ 8041:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = SignoutPage;
var _preact = __webpack_require__(30066);
function SignoutPage(props) {
    const { url , csrfToken , theme  } = props;
    return (0, _preact.h)("div", {
        className: "signout"
    }, theme.brandColor && (0, _preact.h)("style", {
        dangerouslySetInnerHTML: {
            __html: `
        :root {
          --brand-color: ${theme.brandColor}
        }
      `
        }
    }), theme.logo && (0, _preact.h)("img", {
        src: theme.logo,
        alt: "Logo",
        className: "logo"
    }), (0, _preact.h)("div", {
        className: "card"
    }, (0, _preact.h)("h1", null, "Signout"), (0, _preact.h)("p", null, "Are you sure you want to sign out?"), (0, _preact.h)("form", {
        action: `${url}/signout`,
        method: "POST"
    }, (0, _preact.h)("input", {
        type: "hidden",
        name: "csrfToken",
        value: csrfToken
    }), (0, _preact.h)("button", {
        type: "submit"
    }, "Sign out"))));
}


/***/ }),

/***/ 82608:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = VerifyRequestPage;
var _preact = __webpack_require__(30066);
function VerifyRequestPage(props) {
    const { url , theme  } = props;
    return (0, _preact.h)("div", {
        className: "verify-request"
    }, theme.brandColor && (0, _preact.h)("style", {
        dangerouslySetInnerHTML: {
            __html: `
        :root {
          --brand-color: ${theme.brandColor}
        }
      `
        }
    }), theme.logo && (0, _preact.h)("img", {
        src: theme.logo,
        alt: "Logo",
        className: "logo"
    }), (0, _preact.h)("div", {
        className: "card"
    }, (0, _preact.h)("h1", null, "Check your email"), (0, _preact.h)("p", null, "A sign in link has been sent to your email address."), (0, _preact.h)("p", null, (0, _preact.h)("a", {
        className: "site",
        href: url.origin
    }, url.host))));
}


/***/ }),

/***/ 87609:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _interopRequireDefault = __webpack_require__(11061);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = callback;
var _callback = _interopRequireDefault(__webpack_require__(80418));
var _callbackHandler = _interopRequireDefault(__webpack_require__(80374));
var _utils = __webpack_require__(86314);
var _getUserFromEmail = _interopRequireDefault(__webpack_require__(82740));
async function callback(params) {
    const { options , query , body , method , headers , sessionStore  } = params;
    const { provider , adapter , url , callbackUrl , pages , jwt , events , callbacks , session: { strategy: sessionStrategy , maxAge: sessionMaxAge  } , logger  } = options;
    const cookies = [];
    const useJwtSession = sessionStrategy === "jwt";
    if (provider.type === "oauth") {
        try {
            const { profile , account , OAuthProfile , cookies: oauthCookies  } = await (0, _callback.default)({
                query,
                body,
                method,
                options,
                cookies: params.cookies
            });
            if (oauthCookies.length) cookies.push(...oauthCookies);
            try {
                var _events$signIn;
                logger.debug("OAUTH_CALLBACK_RESPONSE", {
                    profile,
                    account,
                    OAuthProfile
                });
                if (!profile || !account || !OAuthProfile) {
                    return {
                        redirect: `${url}/signin`,
                        cookies
                    };
                }
                let userOrProfile = profile;
                if (adapter) {
                    const { getUserByAccount  } = adapter;
                    const userByAccount = await getUserByAccount({
                        providerAccountId: account.providerAccountId,
                        provider: provider.id
                    });
                    if (userByAccount) userOrProfile = userByAccount;
                }
                try {
                    const isAllowed = await callbacks.signIn({
                        user: userOrProfile,
                        account,
                        profile: OAuthProfile
                    });
                    if (!isAllowed) {
                        return {
                            redirect: `${url}/error?error=AccessDenied`,
                            cookies
                        };
                    } else if (typeof isAllowed === "string") {
                        return {
                            redirect: isAllowed,
                            cookies
                        };
                    }
                } catch (error) {
                    return {
                        redirect: `${url}/error?error=${encodeURIComponent(error.message)}`,
                        cookies
                    };
                }
                const { user , session , isNewUser  } = await (0, _callbackHandler.default)({
                    sessionToken: sessionStore.value,
                    profile,
                    account,
                    options
                });
                if (useJwtSession) {
                    var _user$id;
                    const defaultToken = {
                        name: user.name,
                        email: user.email,
                        picture: user.image,
                        sub: (_user$id = user.id) === null || _user$id === void 0 ? void 0 : _user$id.toString()
                    };
                    const token = await callbacks.jwt({
                        token: defaultToken,
                        user,
                        account,
                        profile: OAuthProfile,
                        isNewUser
                    });
                    const newToken = await jwt.encode({
                        ...jwt,
                        token
                    });
                    const cookieExpires = new Date();
                    cookieExpires.setTime(cookieExpires.getTime() + sessionMaxAge * 1000);
                    const sessionCookies = sessionStore.chunk(newToken, {
                        expires: cookieExpires
                    });
                    cookies.push(...sessionCookies);
                } else {
                    cookies.push({
                        name: options.cookies.sessionToken.name,
                        value: session.sessionToken,
                        options: {
                            ...options.cookies.sessionToken.options,
                            expires: session.expires
                        }
                    });
                }
                await ((_events$signIn = events.signIn) === null || _events$signIn === void 0 ? void 0 : _events$signIn.call(events, {
                    user,
                    account,
                    profile,
                    isNewUser
                }));
                if (isNewUser && pages.newUser) {
                    return {
                        redirect: `${pages.newUser}${pages.newUser.includes("?") ? "&" : "?"}callbackUrl=${encodeURIComponent(callbackUrl)}`,
                        cookies
                    };
                }
                return {
                    redirect: callbackUrl,
                    cookies
                };
            } catch (error1) {
                if (error1.name === "AccountNotLinkedError") {
                    return {
                        redirect: `${url}/error?error=OAuthAccountNotLinked`,
                        cookies
                    };
                } else if (error1.name === "CreateUserError") {
                    return {
                        redirect: `${url}/error?error=OAuthCreateAccount`,
                        cookies
                    };
                }
                logger.error("OAUTH_CALLBACK_HANDLER_ERROR", error1);
                return {
                    redirect: `${url}/error?error=Callback`,
                    cookies
                };
            }
        } catch (error2) {
            if (error2.name === "OAuthCallbackError") {
                logger.error("OAUTH_CALLBACK_ERROR", {
                    error: error2,
                    providerId: provider.id
                });
                return {
                    redirect: `${url}/error?error=OAuthCallback`,
                    cookies
                };
            }
            logger.error("OAUTH_CALLBACK_ERROR", error2);
            return {
                redirect: `${url}/error?error=Callback`,
                cookies
            };
        }
    } else if (provider.type === "email") {
        try {
            var _events$signIn2;
            const token1 = query === null || query === void 0 ? void 0 : query.token;
            const identifier = query === null || query === void 0 ? void 0 : query.email;
            if (!token1 || !identifier) {
                return {
                    redirect: `${url}/error?error=configuration`,
                    cookies
                };
            }
            const invite = await adapter.useVerificationToken({
                identifier,
                token: (0, _utils.hashToken)(token1, options)
            });
            const invalidInvite = !invite || invite.expires.valueOf() < Date.now();
            if (invalidInvite) {
                return {
                    redirect: `${url}/error?error=Verification`,
                    cookies
                };
            }
            const profile1 = await (0, _getUserFromEmail.default)({
                email: identifier,
                adapter
            });
            const account1 = {
                providerAccountId: profile1.email,
                type: "email",
                provider: provider.id
            };
            try {
                const signInCallbackResponse = await callbacks.signIn({
                    user: profile1,
                    account: account1
                });
                if (!signInCallbackResponse) {
                    return {
                        redirect: `${url}/error?error=AccessDenied`,
                        cookies
                    };
                } else if (typeof signInCallbackResponse === "string") {
                    return {
                        redirect: signInCallbackResponse,
                        cookies
                    };
                }
            } catch (error3) {
                return {
                    redirect: `${url}/error?error=${encodeURIComponent(error3.message)}`,
                    cookies
                };
            }
            const { user: user1 , session: session1 , isNewUser: isNewUser1  } = await (0, _callbackHandler.default)({
                sessionToken: sessionStore.value,
                profile: profile1,
                account: account1,
                options
            });
            if (useJwtSession) {
                var _user$id2;
                const defaultToken1 = {
                    name: user1.name,
                    email: user1.email,
                    picture: user1.image,
                    sub: (_user$id2 = user1.id) === null || _user$id2 === void 0 ? void 0 : _user$id2.toString()
                };
                const token2 = await callbacks.jwt({
                    token: defaultToken1,
                    user: user1,
                    account: account1,
                    isNewUser: isNewUser1
                });
                const newToken1 = await jwt.encode({
                    ...jwt,
                    token: token2
                });
                const cookieExpires1 = new Date();
                cookieExpires1.setTime(cookieExpires1.getTime() + sessionMaxAge * 1000);
                const sessionCookies1 = sessionStore.chunk(newToken1, {
                    expires: cookieExpires1
                });
                cookies.push(...sessionCookies1);
            } else {
                cookies.push({
                    name: options.cookies.sessionToken.name,
                    value: session1.sessionToken,
                    options: {
                        ...options.cookies.sessionToken.options,
                        expires: session1.expires
                    }
                });
            }
            await ((_events$signIn2 = events.signIn) === null || _events$signIn2 === void 0 ? void 0 : _events$signIn2.call(events, {
                user: user1,
                account: account1,
                isNewUser: isNewUser1
            }));
            if (isNewUser1 && pages.newUser) {
                return {
                    redirect: `${pages.newUser}${pages.newUser.includes("?") ? "&" : "?"}callbackUrl=${encodeURIComponent(callbackUrl)}`,
                    cookies
                };
            }
            return {
                redirect: callbackUrl,
                cookies
            };
        } catch (error4) {
            if (error4.name === "CreateUserError") {
                return {
                    redirect: `${url}/error?error=EmailCreateAccount`,
                    cookies
                };
            }
            logger.error("CALLBACK_EMAIL_ERROR", error4);
            return {
                redirect: `${url}/error?error=Callback`,
                cookies
            };
        }
    } else if (provider.type === "credentials" && method === "POST") {
        var _user$id3, _events$signIn3;
        const credentials = body;
        let user2;
        try {
            user2 = await provider.authorize(credentials, {
                query,
                body,
                headers,
                method
            });
            if (!user2) {
                return {
                    status: 401,
                    redirect: `${url}/error?${new URLSearchParams({
                        error: "CredentialsSignin",
                        provider: provider.id
                    })}`,
                    cookies
                };
            }
        } catch (error5) {
            return {
                status: 401,
                redirect: `${url}/error?error=${encodeURIComponent(error5.message)}`,
                cookies
            };
        }
        const account2 = {
            providerAccountId: user2.id,
            type: "credentials",
            provider: provider.id
        };
        try {
            const isAllowed1 = await callbacks.signIn({
                user: user2,
                account: account2,
                credentials
            });
            if (!isAllowed1) {
                return {
                    status: 403,
                    redirect: `${url}/error?error=AccessDenied`,
                    cookies
                };
            } else if (typeof isAllowed1 === "string") {
                return {
                    redirect: isAllowed1,
                    cookies
                };
            }
        } catch (error6) {
            return {
                redirect: `${url}/error?error=${encodeURIComponent(error6.message)}`,
                cookies
            };
        }
        const defaultToken2 = {
            name: user2.name,
            email: user2.email,
            picture: user2.image,
            sub: (_user$id3 = user2.id) === null || _user$id3 === void 0 ? void 0 : _user$id3.toString()
        };
        const token3 = await callbacks.jwt({
            token: defaultToken2,
            user: user2,
            account: account2,
            isNewUser: false
        });
        const newToken2 = await jwt.encode({
            ...jwt,
            token: token3
        });
        const cookieExpires2 = new Date();
        cookieExpires2.setTime(cookieExpires2.getTime() + sessionMaxAge * 1000);
        const sessionCookies2 = sessionStore.chunk(newToken2, {
            expires: cookieExpires2
        });
        cookies.push(...sessionCookies2);
        await ((_events$signIn3 = events.signIn) === null || _events$signIn3 === void 0 ? void 0 : _events$signIn3.call(events, {
            user: user2,
            account: account2
        }));
        return {
            redirect: callbackUrl,
            cookies
        };
    }
    return {
        status: 500,
        body: `Error: Callback for provider type ${provider.type} not supported`,
        cookies
    };
}


/***/ }),

/***/ 45972:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _interopRequireDefault = __webpack_require__(11061);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "callback", ({
    enumerable: true,
    get: function() {
        return _callback.default;
    }
}));
Object.defineProperty(exports, "providers", ({
    enumerable: true,
    get: function() {
        return _providers.default;
    }
}));
Object.defineProperty(exports, "session", ({
    enumerable: true,
    get: function() {
        return _session.default;
    }
}));
Object.defineProperty(exports, "signin", ({
    enumerable: true,
    get: function() {
        return _signin.default;
    }
}));
Object.defineProperty(exports, "signout", ({
    enumerable: true,
    get: function() {
        return _signout.default;
    }
}));
var _callback = _interopRequireDefault(__webpack_require__(87609));
var _signin = _interopRequireDefault(__webpack_require__(35162));
var _signout = _interopRequireDefault(__webpack_require__(48288));
var _session = _interopRequireDefault(__webpack_require__(32295));
var _providers = _interopRequireDefault(__webpack_require__(44037));


/***/ }),

/***/ 44037:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = providers;
function providers(providers) {
    return {
        headers: [
            {
                key: "Content-Type",
                value: "application/json"
            }
        ],
        body: providers.reduce((acc, { id , name , type , signinUrl , callbackUrl  })=>{
            acc[id] = {
                id,
                name,
                type,
                signinUrl,
                callbackUrl
            };
            return acc;
        }, {})
    };
}


/***/ }),

/***/ 32295:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = session;
var _utils = __webpack_require__(86314);
async function session(params) {
    const { options , sessionStore  } = params;
    const { adapter , jwt , events , callbacks , logger , session: { strategy: sessionStrategy , maxAge: sessionMaxAge  }  } = options;
    const response = {
        body: {},
        headers: [
            {
                key: "Content-Type",
                value: "application/json"
            }
        ],
        cookies: []
    };
    const sessionToken = sessionStore.value;
    if (!sessionToken) return response;
    if (sessionStrategy === "jwt") {
        try {
            var _response$cookies, _events$session;
            const decodedToken = await jwt.decode({
                ...jwt,
                token: sessionToken
            });
            const newExpires = (0, _utils.fromDate)(sessionMaxAge);
            const session = {
                user: {
                    name: decodedToken === null || decodedToken === void 0 ? void 0 : decodedToken.name,
                    email: decodedToken === null || decodedToken === void 0 ? void 0 : decodedToken.email,
                    image: decodedToken === null || decodedToken === void 0 ? void 0 : decodedToken.picture
                },
                expires: newExpires.toISOString()
            };
            const token = await callbacks.jwt({
                token: decodedToken
            });
            const newSession = await callbacks.session({
                session,
                token
            });
            response.body = newSession;
            const newToken = await jwt.encode({
                ...jwt,
                token,
                maxAge: options.session.maxAge
            });
            const sessionCookies = sessionStore.chunk(newToken, {
                expires: newExpires
            });
            (_response$cookies = response.cookies) === null || _response$cookies === void 0 ? void 0 : _response$cookies.push(...sessionCookies);
            await ((_events$session = events.session) === null || _events$session === void 0 ? void 0 : _events$session.call(events, {
                session: newSession,
                token
            }));
        } catch (error) {
            var _response$cookies2;
            logger.error("JWT_SESSION_ERROR", error);
            (_response$cookies2 = response.cookies) === null || _response$cookies2 === void 0 ? void 0 : _response$cookies2.push(...sessionStore.clean());
        }
    } else {
        try {
            const { getSessionAndUser , deleteSession , updateSession  } = adapter;
            let userAndSession = await getSessionAndUser(sessionToken);
            if (userAndSession && userAndSession.session.expires.valueOf() < Date.now()) {
                await deleteSession(sessionToken);
                userAndSession = null;
            }
            if (userAndSession) {
                var _response$cookies3, _events$session2;
                const { user , session: session1  } = userAndSession;
                const sessionUpdateAge = options.session.updateAge;
                const sessionIsDueToBeUpdatedDate = session1.expires.valueOf() - sessionMaxAge * 1000 + sessionUpdateAge * 1000;
                const newExpires1 = (0, _utils.fromDate)(sessionMaxAge);
                if (sessionIsDueToBeUpdatedDate <= Date.now()) {
                    await updateSession({
                        sessionToken,
                        expires: newExpires1
                    });
                }
                const sessionPayload = await callbacks.session({
                    session: {
                        user: {
                            name: user.name,
                            email: user.email,
                            image: user.image
                        },
                        expires: session1.expires.toISOString()
                    },
                    user
                });
                response.body = sessionPayload;
                (_response$cookies3 = response.cookies) === null || _response$cookies3 === void 0 ? void 0 : _response$cookies3.push({
                    name: options.cookies.sessionToken.name,
                    value: sessionToken,
                    options: {
                        ...options.cookies.sessionToken.options,
                        expires: newExpires1
                    }
                });
                await ((_events$session2 = events.session) === null || _events$session2 === void 0 ? void 0 : _events$session2.call(events, {
                    session: sessionPayload
                }));
            } else if (sessionToken) {
                var _response$cookies4;
                (_response$cookies4 = response.cookies) === null || _response$cookies4 === void 0 ? void 0 : _response$cookies4.push(...sessionStore.clean());
            }
        } catch (error1) {
            logger.error("SESSION_ERROR", error1);
        }
    }
    return response;
}


/***/ }),

/***/ 35162:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _interopRequireDefault = __webpack_require__(11061);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = signin;
var _authorizationUrl = _interopRequireDefault(__webpack_require__(17376));
var _signin = _interopRequireDefault(__webpack_require__(69966));
var _getUserFromEmail = _interopRequireDefault(__webpack_require__(82740));
async function signin(params) {
    const { options , query , body  } = params;
    const { url , callbacks , logger , provider  } = options;
    if (!provider.type) {
        return {
            status: 500,
            text: `Error: Type not specified for ${provider.name}`
        };
    }
    if (provider.type === "oauth") {
        try {
            const response = await (0, _authorizationUrl.default)({
                options,
                query
            });
            return response;
        } catch (error) {
            logger.error("SIGNIN_OAUTH_ERROR", {
                error: error,
                providerId: provider.id
            });
            return {
                redirect: `${url}/error?error=OAuthSignin`
            };
        }
    } else if (provider.type === "email") {
        var _provider$normalizeId;
        let email = body === null || body === void 0 ? void 0 : body.email;
        if (!email) return {
            redirect: `${url}/error?error=EmailSignin`
        };
        const normalizer = (_provider$normalizeId = provider.normalizeIdentifier) !== null && _provider$normalizeId !== void 0 ? _provider$normalizeId : (identifier)=>{
            let [local, domain] = identifier.toLowerCase().trim().split("@");
            domain = domain.split(",")[0];
            return `${local}@${domain}`;
        };
        try {
            email = normalizer(body === null || body === void 0 ? void 0 : body.email);
        } catch (error1) {
            logger.error("SIGNIN_EMAIL_ERROR", {
                error: error1,
                providerId: provider.id
            });
            return {
                redirect: `${url}/error?error=EmailSignin`
            };
        }
        const user = await (0, _getUserFromEmail.default)({
            email,
            adapter: options.adapter
        });
        const account = {
            providerAccountId: email,
            userId: email,
            type: "email",
            provider: provider.id
        };
        try {
            const signInCallbackResponse = await callbacks.signIn({
                user,
                account,
                email: {
                    verificationRequest: true
                }
            });
            if (!signInCallbackResponse) {
                return {
                    redirect: `${url}/error?error=AccessDenied`
                };
            } else if (typeof signInCallbackResponse === "string") {
                return {
                    redirect: signInCallbackResponse
                };
            }
        } catch (error2) {
            return {
                redirect: `${url}/error?${new URLSearchParams({
                    error: error2
                })}`
            };
        }
        try {
            const redirect = await (0, _signin.default)(email, options);
            return {
                redirect
            };
        } catch (error3) {
            logger.error("SIGNIN_EMAIL_ERROR", {
                error: error3,
                providerId: provider.id
            });
            return {
                redirect: `${url}/error?error=EmailSignin`
            };
        }
    }
    return {
        redirect: `${url}/signin`
    };
}


/***/ }),

/***/ 48288:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = signout;
async function signout(params) {
    const { options , sessionStore  } = params;
    const { adapter , events , jwt , callbackUrl , logger , session  } = options;
    const sessionToken = sessionStore === null || sessionStore === void 0 ? void 0 : sessionStore.value;
    if (!sessionToken) {
        return {
            redirect: callbackUrl
        };
    }
    if (session.strategy === "jwt") {
        try {
            var _events$signOut;
            const decodedJwt = await jwt.decode({
                ...jwt,
                token: sessionToken
            });
            await ((_events$signOut = events.signOut) === null || _events$signOut === void 0 ? void 0 : _events$signOut.call(events, {
                token: decodedJwt
            }));
        } catch (error) {
            logger.error("SIGNOUT_ERROR", error);
        }
    } else {
        try {
            var _events$signOut2;
            const session1 = await adapter.deleteSession(sessionToken);
            await ((_events$signOut2 = events.signOut) === null || _events$signOut2 === void 0 ? void 0 : _events$signOut2.call(events, {
                session: session1
            }));
        } catch (error1) {
            logger.error("SIGNOUT_ERROR", error1);
        }
    }
    const sessionCookies = sessionStore.clean();
    return {
        redirect: callbackUrl,
        cookies: sessionCookies
    };
}


/***/ }),

/***/ 22944:
/***/ ((module) => {

"use strict";

module.exports = function() {
    return ':root{--border-width:1px;--border-radius:0.5rem;--color-error:#c94b4b;--color-info:#157efb;--color-info-text:#fff}.__next-auth-theme-auto,.__next-auth-theme-light{--color-background:#fff;--color-text:#000;--color-primary:#444;--color-control-border:#bbb;--color-button-active-background:#f9f9f9;--color-button-active-border:#aaa;--color-seperator:#ccc}.__next-auth-theme-dark{--color-background:#000;--color-text:#fff;--color-primary:#ccc;--color-control-border:#555;--color-button-active-background:#060606;--color-button-active-border:#666;--color-seperator:#444}@media (prefers-color-scheme:dark){.__next-auth-theme-auto{--color-background:#000;--color-text:#fff;--color-primary:#ccc;--color-control-border:#555;--color-button-active-background:#060606;--color-button-active-border:#666;--color-seperator:#444}}body{background-color:var(--color-background);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;margin:0;padding:0}h1{font-weight:400;margin-bottom:1.5rem;padding:0 1rem}h1,p{color:var(--color-text)}form{margin:0;padding:0}label{font-weight:500;margin-bottom:.25rem;text-align:left}input[type],label{color:var(--color-text);display:block}input[type]{background:var(--color-background);border:var(--border-width) solid var(--color-control-border);border-radius:var(--border-radius);box-shadow:inset 0 .1rem .2rem rgba(0,0,0,.2);box-sizing:border-box;font-size:1rem;padding:.5rem 1rem;width:100%}input[type]:focus{box-shadow:none}p{font-size:1.1rem;line-height:2rem;margin:0 0 1.5rem;padding:0 1rem}a.button{line-height:1rem;text-decoration:none}a.button:link,a.button:visited{background-color:var(--color-background);color:var(--color-primary)}a.button,button{align-items:center;background-color:var(--provider-bg,var(--color-background));border-color:rgba(0,0,0,.1);border-radius:var(--border-radius);box-shadow:0 0 0 0 #000,0 0 0 0 #000,0 10px 15px -3px rgba(0,0,0,.2),0 4px 6px -4px rgba(0,0,0,.1);color:var(--provider-color,var(--color-primary));display:flex;font-size:1.1rem;font-weight:500;justify-content:center;margin:0 0 .75rem;min-height:62px;padding:.75rem 1rem;position:relative;transition:all .1s ease-in-out}a.button:has(img),button:has(img){justify-content:unset}a.button:has(img) span,button:has(img) span{flex-grow:1}a.button:hover,button:hover{cursor:pointer}a.button:active,button:active{box-shadow:0 .15rem .3rem rgba(0,0,0,.15),inset 0 .1rem .2rem var(--color-background),inset 0 -.1rem .1rem rgba(0,0,0,.1);cursor:pointer}a.button #provider-logo,button #provider-logo{display:block}a.button #provider-logo-dark,button #provider-logo-dark{display:none}@media (prefers-color-scheme:dark){a.button,button{background-color:var(--provider-dark-bg,var(--color-background));border:1px solid #0d0d0d;box-shadow:0 0 0 0 #000,0 0 0 0 #ccc,0 5px 5px -3px hsla(0,0%,100%,.01),0 4px 6px -4px hsla(0,0%,100%,.05);color:var(--provider-dark-color,var(--color-primary))}#provider-logo{display:none!important}#provider-logo-dark{display:block!important}}a.site{color:var(--color-primary);font-size:1rem;line-height:2rem;text-decoration:none}a.site:hover{text-decoration:underline}.page{display:grid;height:100%;margin:0;padding:0;place-items:center;position:absolute;width:100%}.page>div{padding:.5rem;text-align:center}.error a.button{display:inline-block;margin-top:.5rem;padding-left:2rem;padding-right:2rem}.error .message{margin-bottom:1.5rem}.signin input[type=text]{display:block;margin-left:auto;margin-right:auto}.signin hr{border:0;border-top:1px solid var(--color-seperator);display:block;margin:1.5em auto 0;overflow:visible}.signin hr:before{background:var(--color-background);color:#888;content:"or";padding:0 .4rem;position:relative;top:-.6rem}.signin .error{background:#f5f5f5;background:var(--color-info);border-radius:.3rem;font-weight:500}.signin .error p{color:var(--color-info-text);font-size:.9rem;line-height:1.2rem;padding:.5rem 1rem;text-align:left}.signin form,.signin>div{display:block}.signin form input[type],.signin>div input[type]{margin-bottom:.5rem}.signin form button,.signin>div button{width:100%}.signin form,.signin>div{max-width:300px}.signout .message{margin-bottom:1.5rem}.logo{display:inline-block;margin-top:100px;max-height:150px;max-width:300px}.card{border:1px solid var(--color-control-border);border-radius:5px;margin:50px auto;max-width:-webkit-max-content;max-width:-moz-max-content;max-width:max-content;padding:20px 50px}.card .header{color:var(--color-primary)}.section-header{color:var(--brand-color,var(--color-text))}';
};


/***/ }),

/***/ 52543:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _interopRequireDefault = __webpack_require__(11061);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _exportNames = {
    encode: true,
    decode: true,
    getToken: true
};
exports.decode = decode;
exports.encode = encode;
exports.getToken = getToken;
var _jose = __webpack_require__(89723);
var _hkdf = _interopRequireDefault(__webpack_require__(37291));
var _uuid = __webpack_require__(31932);
var _cookie = __webpack_require__(67497);
var _types = __webpack_require__(20586);
Object.keys(_types).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _types[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _types[key];
        }
    });
});
const DEFAULT_MAX_AGE = 30 * 24 * 60 * 60;
const now = ()=>Date.now() / 1000 | 0;
async function encode(params) {
    const { token ={} , secret , maxAge =DEFAULT_MAX_AGE  } = params;
    const encryptionSecret = await getDerivedEncryptionKey(secret);
    return await new _jose.EncryptJWT(token).setProtectedHeader({
        alg: "dir",
        enc: "A256GCM"
    }).setIssuedAt().setExpirationTime(now() + maxAge).setJti((0, _uuid.v4)()).encrypt(encryptionSecret);
}
async function decode(params) {
    const { token , secret  } = params;
    if (!token) return null;
    const encryptionSecret = await getDerivedEncryptionKey(secret);
    const { payload  } = await (0, _jose.jwtDecrypt)(token, encryptionSecret, {
        clockTolerance: 15
    });
    return payload;
}
async function getToken(params) {
    var _process$env$NEXTAUTH, _process$env$NEXTAUTH2;
    const { req , secureCookie =(_process$env$NEXTAUTH = (_process$env$NEXTAUTH2 = process.env.NEXTAUTH_URL) === null || _process$env$NEXTAUTH2 === void 0 ? void 0 : _process$env$NEXTAUTH2.startsWith("https://")) !== null && _process$env$NEXTAUTH !== void 0 ? _process$env$NEXTAUTH : !!process.env.VERCEL , cookieName =secureCookie ? "__Secure-next-auth.session-token" : "next-auth.session-token" , raw , decode: _decode = decode , logger =console , secret =process.env.NEXTAUTH_SECRET  } = params;
    if (!req) throw new Error("Must pass `req` to JWT getToken()");
    const sessionStore = new _cookie.SessionStore({
        name: cookieName,
        options: {
            secure: secureCookie
        }
    }, {
        cookies: req.cookies,
        headers: req.headers
    }, logger);
    let token = sessionStore.value;
    const authorizationHeader = req.headers instanceof Headers ? req.headers.get("authorization") : req.headers.authorization;
    if (!token && (authorizationHeader === null || authorizationHeader === void 0 ? void 0 : authorizationHeader.split(" ")[0]) === "Bearer") {
        const urlEncodedToken = authorizationHeader.split(" ")[1];
        token = decodeURIComponent(urlEncodedToken);
    }
    if (!token) return null;
    if (raw) return token;
    try {
        return await _decode({
            token,
            secret
        });
    } catch (_unused) {
        return null;
    }
}
async function getDerivedEncryptionKey(secret) {
    return await (0, _hkdf.default)("sha256", secret, "", "NextAuth.js Generated Encryption Key", 32);
}


/***/ }),

/***/ 20586:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 62660:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({
    value: true
});
__webpack_unused_export__ = void 0;
exports.NP = unstable_getServerSession;
var _core = __webpack_require__(74603);
var _detectHost = __webpack_require__(56670);
var _utils = __webpack_require__(51476);
async function NextAuthNextHandler(req, res, options) {
    var _ref, _options$secret, _options$jwt, _ref2, _handler$status, _handler$cookies, _handler$headers;
    const { nextauth , ...query } = req.query;
    options.secret = (_ref = (_options$secret = options.secret) !== null && _options$secret !== void 0 ? _options$secret : (_options$jwt = options.jwt) === null || _options$jwt === void 0 ? void 0 : _options$jwt.secret) !== null && _ref !== void 0 ? _ref : process.env.NEXTAUTH_SECRET;
    const handler = await (0, _core.NextAuthHandler)({
        req: {
            host: (0, _detectHost.detectHost)(req.headers["x-forwarded-host"]),
            body: req.body,
            query,
            cookies: req.cookies,
            headers: req.headers,
            method: req.method,
            action: nextauth === null || nextauth === void 0 ? void 0 : nextauth[0],
            providerId: nextauth === null || nextauth === void 0 ? void 0 : nextauth[1],
            error: (_ref2 = req.query.error) !== null && _ref2 !== void 0 ? _ref2 : nextauth === null || nextauth === void 0 ? void 0 : nextauth[1]
        },
        options
    });
    res.status((_handler$status = handler.status) !== null && _handler$status !== void 0 ? _handler$status : 200);
    (_handler$cookies = handler.cookies) === null || _handler$cookies === void 0 ? void 0 : _handler$cookies.forEach((cookie)=>(0, _utils.setCookie)(res, cookie));
    (_handler$headers = handler.headers) === null || _handler$headers === void 0 ? void 0 : _handler$headers.forEach((h)=>res.setHeader(h.key, h.value));
    if (handler.redirect) {
        var _req$body;
        if (((_req$body = req.body) === null || _req$body === void 0 ? void 0 : _req$body.json) !== "true") {
            res.status(302).setHeader("Location", handler.redirect);
            return res.end();
        }
        return res.json({
            url: handler.redirect
        });
    }
    return res.send(handler.body);
}
function NextAuth(...args) {
    if (args.length === 1) {
        return async (req, res)=>await NextAuthNextHandler(req, res, args[0]);
    }
    return NextAuthNextHandler(args[0], args[1], args[2]);
}
var _default = NextAuth;
__webpack_unused_export__ = _default;
let experimentalWarningShown = false;
let experimentalRSCWarningShown = false;
async function unstable_getServerSession(...args) {
    var _options$secret2;
    if (!experimentalWarningShown && "production" !== "production") {}
    const isRSC = args.length === 0 || args.length === 1;
    if (!experimentalRSCWarningShown && isRSC && "production" !== "production") {}
    let req, res, options;
    if (isRSC) {
        var _args$;
        options = (_args$ = args[0]) !== null && _args$ !== void 0 ? _args$ : {
            providers: []
        };
        const { headers , cookies  } = __webpack_require__(39183);
        req = {
            headers: Object.fromEntries(headers()),
            cookies: Object.fromEntries(cookies().getAll().map((c)=>[
                    c.name,
                    c.value
                ]))
        };
        res = {
            getHeader () {},
            setCookie () {},
            setHeader () {}
        };
    } else {
        req = args[0];
        res = args[1];
        options = args[2];
    }
    options.secret = (_options$secret2 = options.secret) !== null && _options$secret2 !== void 0 ? _options$secret2 : process.env.NEXTAUTH_SECRET;
    const session = await (0, _core.NextAuthHandler)({
        options,
        req: {
            host: (0, _detectHost.detectHost)(req.headers["x-forwarded-host"]),
            action: "session",
            method: "GET",
            cookies: req.cookies,
            headers: req.headers
        }
    });
    const { body , cookies: cookies1 , status =200  } = session;
    cookies1 === null || cookies1 === void 0 ? void 0 : cookies1.forEach((cookie)=>(0, _utils.setCookie)(res, cookie));
    if (body && typeof body !== "string" && Object.keys(body).length) {
        if (status === 200) {
            if (isRSC) delete body.expires;
            return body;
        }
        throw new Error(body.message);
    }
    return null;
}


/***/ }),

/***/ 51476:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.setCookie = setCookie;
var _cookie = __webpack_require__(3519);
function setCookie(res, cookie) {
    var _res$getHeader;
    let setCookieHeader = (_res$getHeader = res.getHeader("Set-Cookie")) !== null && _res$getHeader !== void 0 ? _res$getHeader : [];
    if (!Array.isArray(setCookieHeader)) {
        setCookieHeader = [
            setCookieHeader
        ];
    }
    const { name , value , options  } = cookie;
    const cookieHeader = (0, _cookie.serialize)(name, value, options);
    setCookieHeader.push(cookieHeader);
    res.setHeader("Set-Cookie", setCookieHeader);
}


/***/ }),

/***/ 9097:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({
    value: true
});
exports.Z = Email;
var _nodemailer = __webpack_require__(87795);
function Email(options) {
    return {
        id: "email",
        type: "email",
        name: "Email",
        server: {
            host: "localhost",
            port: 25,
            auth: {
                user: "",
                pass: ""
            }
        },
        from: "NextAuth <no-reply@example.com>",
        maxAge: 24 * 60 * 60,
        async sendVerificationRequest (params) {
            const { identifier , url , provider , theme  } = params;
            const { host  } = new URL(url);
            const transport = (0, _nodemailer.createTransport)(provider.server);
            const result = await transport.sendMail({
                to: identifier,
                from: provider.from,
                subject: `Sign in to ${host}`,
                text: text({
                    url,
                    host
                }),
                html: html({
                    url,
                    host,
                    theme
                })
            });
            const failed = result.rejected.concat(result.pending).filter(Boolean);
            if (failed.length) {
                throw new Error(`Email (${failed.join(", ")}) could not be sent`);
            }
        },
        options
    };
}
function html(params) {
    const { url , host , theme  } = params;
    const escapedHost = host.replace(/\./g, "&#8203;.");
    const brandColor = theme.brandColor || "#346df1";
    const buttonText = theme.buttonText || "#fff";
    const color = {
        background: "#f9f9f9",
        text: "#444",
        mainBackground: "#fff",
        buttonBackground: brandColor,
        buttonBorder: brandColor,
        buttonText
    };
    return `
<body style="background: ${color.background};">
  <table width="100%" border="0" cellspacing="20" cellpadding="0"
    style="background: ${color.mainBackground}; max-width: 600px; margin: auto; border-radius: 10px;">
    <tr>
      <td align="center"
        style="padding: 10px 0px; font-size: 22px; font-family: Helvetica, Arial, sans-serif; color: ${color.text};">
        Sign in to <strong>${escapedHost}</strong>
      </td>
    </tr>
    <tr>
      <td align="center" style="padding: 20px 0;">
        <table border="0" cellspacing="0" cellpadding="0">
          <tr>
            <td align="center" style="border-radius: 5px;" bgcolor="${color.buttonBackground}"><a href="${url}"
                target="_blank"
                style="font-size: 18px; font-family: Helvetica, Arial, sans-serif; color: ${color.buttonText}; text-decoration: none; border-radius: 5px; padding: 10px 20px; border: 1px solid ${color.buttonBorder}; display: inline-block; font-weight: bold;">Sign
                in</a></td>
          </tr>
        </table>
      </td>
    </tr>
    <tr>
      <td align="center"
        style="padding: 0px 0px 10px 0px; font-size: 16px; line-height: 22px; font-family: Helvetica, Arial, sans-serif; color: ${color.text};">
        If you did not request this email you can safely ignore it.
      </td>
    </tr>
  </table>
</body>
`;
}
function text({ url , host  }) {
    return `Sign in to ${host}\n${url}\n\n`;
}


/***/ }),

/***/ 82327:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({
    value: true
});
exports.Z = Github;
function Github(options) {
    return {
        id: "github",
        name: "GitHub",
        type: "oauth",
        authorization: {
            url: "https://github.com/login/oauth/authorize",
            params: {
                scope: "read:user user:email"
            }
        },
        token: "https://github.com/login/oauth/access_token",
        userinfo: {
            url: "https://api.github.com/user",
            async request ({ client , tokens  }) {
                const profile = await client.userinfo(tokens.access_token);
                if (!profile.email) {
                    const res = await fetch("https://api.github.com/user/emails", {
                        headers: {
                            Authorization: `token ${tokens.access_token}`
                        }
                    });
                    if (res.ok) {
                        var _emails$find;
                        const emails = await res.json();
                        profile.email = ((_emails$find = emails.find((e)=>e.primary)) !== null && _emails$find !== void 0 ? _emails$find : emails[0]).email;
                    }
                }
                return profile;
            }
        },
        profile (profile) {
            var _profile$name;
            return {
                id: profile.id.toString(),
                name: (_profile$name = profile.name) !== null && _profile$name !== void 0 ? _profile$name : profile.login,
                email: profile.email,
                image: profile.avatar_url
            };
        },
        style: {
            logo: "https://raw.githubusercontent.com/nextauthjs/next-auth/main/packages/next-auth/provider-logos/github.svg",
            logoDark: "https://raw.githubusercontent.com/nextauthjs/next-auth/main/packages/next-auth/provider-logos/github-dark.svg",
            bg: "#fff",
            bgDark: "#000",
            text: "#000",
            textDark: "#fff"
        },
        options
    };
}


/***/ }),

/***/ 56670:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.detectHost = detectHost;
function detectHost(forwardedHost) {
    var _process$env$VERCEL;
    if ((_process$env$VERCEL = process.env.VERCEL) !== null && _process$env$VERCEL !== void 0 ? _process$env$VERCEL : process.env.AUTH_TRUST_HOST) return forwardedHost;
    return process.env.NEXTAUTH_URL;
}


/***/ }),

/***/ 51496:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _interopRequireDefault = __webpack_require__(11061);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
exports.proxyLogger = proxyLogger;
exports.setLogger = setLogger;
var _defineProperty2 = _interopRequireDefault(__webpack_require__(97054));
var _errors = __webpack_require__(83426);
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
            (0, _defineProperty2.default)(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function formatError(o) {
    if (o instanceof Error && !(o instanceof _errors.UnknownError)) {
        return {
            message: o.message,
            stack: o.stack,
            name: o.name
        };
    }
    if (hasErrorProperty(o)) {
        var _o$message;
        o.error = formatError(o.error);
        o.message = (_o$message = o.message) !== null && _o$message !== void 0 ? _o$message : o.error.message;
    }
    return o;
}
function hasErrorProperty(x) {
    return !!(x !== null && x !== void 0 && x.error);
}
var _logger = {
    error: function error(code, metadata) {
        metadata = formatError(metadata);
        console.error("[next-auth][error][".concat(code, "]"), "\nhttps://next-auth.js.org/errors#".concat(code.toLowerCase()), metadata.message, metadata);
    },
    warn: function warn(code) {
        console.warn("[next-auth][warn][".concat(code, "]"), "\nhttps://next-auth.js.org/warnings#".concat(code.toLowerCase()));
    },
    debug: function debug(code, metadata) {
        console.log("[next-auth][debug][".concat(code, "]"), metadata);
    }
};
function setLogger() {
    var newLogger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var debug = arguments.length > 1 ? arguments[1] : undefined;
    if (!debug) _logger.debug = function() {};
    if (newLogger.error) _logger.error = newLogger.error;
    if (newLogger.warn) _logger.warn = newLogger.warn;
    if (newLogger.debug) _logger.debug = newLogger.debug;
}
var _default = _logger;
exports["default"] = _default;
function proxyLogger() {
    var logger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _logger;
    var basePath = arguments.length > 1 ? arguments[1] : undefined;
    try {
        if (true) {
            return logger;
        }
        var clientLogger = {};
        var _loop = function _loop(level) {
            clientLogger[level] = function(code, metadata) {
                _logger[level](code, metadata);
                if (level === "error") {
                    metadata = formatError(metadata);
                }
                ;
                metadata.client = true;
                var url = "".concat(basePath, "/_log");
                var body = new URLSearchParams(_objectSpread({
                    level: level,
                    code: code
                }, metadata));
                if (navigator.sendBeacon) {
                    return navigator.sendBeacon(url, body);
                }
                return fetch(url, {
                    method: "POST",
                    body: body,
                    keepalive: true
                });
            };
        };
        for(var level in logger){
            _loop(level);
        }
        return clientLogger;
    } catch (_unused) {
        return _logger;
    }
}


/***/ }),

/***/ 93283:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.merge = merge;
function isObject(item) {
    return item && typeof item === "object" && !Array.isArray(item);
}
function merge(target, ...sources) {
    if (!sources.length) return target;
    const source = sources.shift();
    if (isObject(target) && isObject(source)) {
        for(const key in source){
            if (isObject(source[key])) {
                if (!target[key]) Object.assign(target, {
                    [key]: {}
                });
                merge(target[key], source[key]);
            } else {
                Object.assign(target, {
                    [key]: source[key]
                });
            }
        }
    }
    return merge(target, ...sources);
}


/***/ }),

/***/ 10558:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = parseUrl;
function parseUrl(url) {
    var _url2;
    const defaultUrl = new URL("http://localhost:3000/api/auth");
    if (url && !url.startsWith("http")) {
        url = `https://${url}`;
    }
    const _url = new URL((_url2 = url) !== null && _url2 !== void 0 ? _url2 : defaultUrl);
    const path = (_url.pathname === "/" ? defaultUrl.pathname : _url.pathname).replace(/\/$/, "");
    const base = `${_url.origin}${path}`;
    return {
        origin: _url.origin,
        host: _url.host,
        path,
        base,
        toString: ()=>base
    };
}


/***/ }),

/***/ 51932:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.headers = headers;
exports.previewData = previewData;
exports.cookies = cookies;
var _requestAsyncStorage = __webpack_require__(14427);
var _staticGenerationBailout = __webpack_require__(342);
function headers() {
    (0, _staticGenerationBailout).staticGenerationBailout("headers");
    const requestStore = _requestAsyncStorage.requestAsyncStorage && "getStore" in _requestAsyncStorage.requestAsyncStorage ? _requestAsyncStorage.requestAsyncStorage.getStore() : _requestAsyncStorage.requestAsyncStorage;
    return requestStore.headers;
}
function previewData() {
    (0, _staticGenerationBailout).staticGenerationBailout("previewData");
    const requestStore = _requestAsyncStorage.requestAsyncStorage && "getStore" in _requestAsyncStorage.requestAsyncStorage ? _requestAsyncStorage.requestAsyncStorage.getStore() : _requestAsyncStorage.requestAsyncStorage;
    return requestStore.previewData;
}
function cookies() {
    (0, _staticGenerationBailout).staticGenerationBailout("cookies");
    const requestStore = _requestAsyncStorage.requestAsyncStorage && "getStore" in _requestAsyncStorage.requestAsyncStorage ? _requestAsyncStorage.requestAsyncStorage.getStore() : _requestAsyncStorage.requestAsyncStorage;
    return requestStore.cookies;
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=headers.js.map


/***/ }),

/***/ 39183:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = __webpack_require__(51932);


/***/ }),

/***/ 53287:
/***/ ((module) => {

"use strict";

/**
 * Converts tokens for a single address into an address object
 *
 * @param {Array} tokens Tokens object
 * @return {Object} Address object
 */ function _handleAddress(tokens) {
    let token;
    let isGroup = false;
    let state = "text";
    let address;
    let addresses = [];
    let data = {
        address: [],
        comment: [],
        group: [],
        text: []
    };
    let i;
    let len;
    // Filter out <addresses>, (comments) and regular text
    for(i = 0, len = tokens.length; i < len; i++){
        token = tokens[i];
        if (token.type === "operator") {
            switch(token.value){
                case "<":
                    state = "address";
                    break;
                case "(":
                    state = "comment";
                    break;
                case ":":
                    state = "group";
                    isGroup = true;
                    break;
                default:
                    state = "text";
            }
        } else if (token.value) {
            if (state === "address") {
                // handle use case where unquoted name includes a "<"
                // Apple Mail truncates everything between an unexpected < and an address
                // and so will we
                token.value = token.value.replace(/^[^<]*<\s*/, "");
            }
            data[state].push(token.value);
        }
    }
    // If there is no text but a comment, replace the two
    if (!data.text.length && data.comment.length) {
        data.text = data.comment;
        data.comment = [];
    }
    if (isGroup) {
        // http://tools.ietf.org/html/rfc2822#appendix-A.1.3
        data.text = data.text.join(" ");
        addresses.push({
            name: data.text || address && address.name,
            group: data.group.length ? addressparser(data.group.join(",")) : []
        });
    } else {
        // If no address was found, try to detect one from regular text
        if (!data.address.length && data.text.length) {
            for(i = data.text.length - 1; i >= 0; i--){
                if (data.text[i].match(/^[^@\s]+@[^@\s]+$/)) {
                    data.address = data.text.splice(i, 1);
                    break;
                }
            }
            let _regexHandler = function(address) {
                if (!data.address.length) {
                    data.address = [
                        address.trim()
                    ];
                    return " ";
                } else {
                    return address;
                }
            };
            // still no address
            if (!data.address.length) {
                for(i = data.text.length - 1; i >= 0; i--){
                    // fixed the regex to parse email address correctly when email address has more than one @
                    data.text[i] = data.text[i].replace(/\s*\b[^@\s]+@[^\s]+\b\s*/, _regexHandler).trim();
                    if (data.address.length) {
                        break;
                    }
                }
            }
        }
        // If there's still is no text but a comment exixts, replace the two
        if (!data.text.length && data.comment.length) {
            data.text = data.comment;
            data.comment = [];
        }
        // Keep only the first address occurence, push others to regular text
        if (data.address.length > 1) {
            data.text = data.text.concat(data.address.splice(1));
        }
        // Join values with spaces
        data.text = data.text.join(" ");
        data.address = data.address.join(" ");
        if (!data.address && isGroup) {
            return [];
        } else {
            address = {
                address: data.address || data.text || "",
                name: data.text || data.address || ""
            };
            if (address.address === address.name) {
                if ((address.address || "").match(/@/)) {
                    address.name = "";
                } else {
                    address.address = "";
                }
            }
            addresses.push(address);
        }
    }
    return addresses;
}
/**
 * Creates a Tokenizer object for tokenizing address field strings
 *
 * @constructor
 * @param {String} str Address field string
 */ class Tokenizer {
    constructor(str){
        this.str = (str || "").toString();
        this.operatorCurrent = "";
        this.operatorExpecting = "";
        this.node = null;
        this.escaped = false;
        this.list = [];
        /**
         * Operator tokens and which tokens are expected to end the sequence
         */ this.operators = {
            '"': '"',
            "(": ")",
            "<": ">",
            ",": "",
            ":": ";",
            // Semicolons are not a legal delimiter per the RFC2822 grammar other
            // than for terminating a group, but they are also not valid for any
            // other use in this context.  Given that some mail clients have
            // historically allowed the semicolon as a delimiter equivalent to the
            // comma in their UI, it makes sense to treat them the same as a comma
            // when used outside of a group.
            ";": ""
        };
    }
    /**
     * Tokenizes the original input string
     *
     * @return {Array} An array of operator|text tokens
     */ tokenize() {
        let chr, list = [];
        for(let i = 0, len = this.str.length; i < len; i++){
            chr = this.str.charAt(i);
            this.checkChar(chr);
        }
        this.list.forEach((node)=>{
            node.value = (node.value || "").toString().trim();
            if (node.value) {
                list.push(node);
            }
        });
        return list;
    }
    /**
     * Checks if a character is an operator or text and acts accordingly
     *
     * @param {String} chr Character from the address field
     */ checkChar(chr) {
        if (this.escaped) {
        // ignore next condition blocks
        } else if (chr === this.operatorExpecting) {
            this.node = {
                type: "operator",
                value: chr
            };
            this.list.push(this.node);
            this.node = null;
            this.operatorExpecting = "";
            this.escaped = false;
            return;
        } else if (!this.operatorExpecting && chr in this.operators) {
            this.node = {
                type: "operator",
                value: chr
            };
            this.list.push(this.node);
            this.node = null;
            this.operatorExpecting = this.operators[chr];
            this.escaped = false;
            return;
        } else if ([
            '"',
            "'"
        ].includes(this.operatorExpecting) && chr === "\\") {
            this.escaped = true;
            return;
        }
        if (!this.node) {
            this.node = {
                type: "text",
                value: ""
            };
            this.list.push(this.node);
        }
        if (chr === "\n") {
            // Convert newlines to spaces. Carriage return is ignored as \r and \n usually
            // go together anyway and there already is a WS for \n. Lone \r means something is fishy.
            chr = " ";
        }
        if (chr.charCodeAt(0) >= 0x21 || [
            " ",
            "	"
        ].includes(chr)) {
            // skip command bytes
            this.node.value += chr;
        }
        this.escaped = false;
    }
}
/**
 * Parses structured e-mail addresses from an address field
 *
 * Example:
 *
 *    'Name <address@domain>'
 *
 * will be converted to
 *
 *     [{name: 'Name', address: 'address@domain'}]
 *
 * @param {String} str Address field
 * @return {Array} An array of address objects
 */ function addressparser(str, options) {
    options = options || {};
    let tokenizer = new Tokenizer(str);
    let tokens = tokenizer.tokenize();
    let addresses = [];
    let address = [];
    let parsedAddresses = [];
    tokens.forEach((token)=>{
        if (token.type === "operator" && (token.value === "," || token.value === ";")) {
            if (address.length) {
                addresses.push(address);
            }
            address = [];
        } else {
            address.push(token);
        }
    });
    if (address.length) {
        addresses.push(address);
    }
    addresses.forEach((address)=>{
        address = _handleAddress(address);
        if (address.length) {
            parsedAddresses = parsedAddresses.concat(address);
        }
    });
    if (options.flatten) {
        let addresses1 = [];
        let walkAddressList = (list)=>{
            list.forEach((address)=>{
                if (address.group) {
                    return walkAddressList(address.group);
                } else {
                    addresses1.push(address);
                }
            });
        };
        walkAddressList(parsedAddresses);
        return addresses1;
    }
    return parsedAddresses;
}
// expose to the world
module.exports = addressparser;


/***/ }),

/***/ 60038:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const Transform = (__webpack_require__(12781).Transform);
/**
 * Encodes a Buffer into a base64 encoded string
 *
 * @param {Buffer} buffer Buffer to convert
 * @returns {String} base64 encoded string
 */ function encode(buffer) {
    if (typeof buffer === "string") {
        buffer = Buffer.from(buffer, "utf-8");
    }
    return buffer.toString("base64");
}
/**
 * Adds soft line breaks to a base64 string
 *
 * @param {String} str base64 encoded string that might need line wrapping
 * @param {Number} [lineLength=76] Maximum allowed length for a line
 * @returns {String} Soft-wrapped base64 encoded string
 */ function wrap(str, lineLength) {
    str = (str || "").toString();
    lineLength = lineLength || 76;
    if (str.length <= lineLength) {
        return str;
    }
    let result = [];
    let pos = 0;
    let chunkLength = lineLength * 1024;
    while(pos < str.length){
        let wrappedLines = str.substr(pos, chunkLength).replace(new RegExp(".{" + lineLength + "}", "g"), "$&\r\n").trim();
        result.push(wrappedLines);
        pos += chunkLength;
    }
    return result.join("\r\n").trim();
}
/**
 * Creates a transform stream for encoding data to base64 encoding
 *
 * @constructor
 * @param {Object} options Stream options
 * @param {Number} [options.lineLength=76] Maximum length for lines, set to false to disable wrapping
 */ class Encoder extends Transform {
    constructor(options){
        super();
        // init Transform
        this.options = options || {};
        if (this.options.lineLength !== false) {
            this.options.lineLength = this.options.lineLength || 76;
        }
        this._curLine = "";
        this._remainingBytes = false;
        this.inputBytes = 0;
        this.outputBytes = 0;
    }
    _transform(chunk, encoding, done) {
        if (encoding !== "buffer") {
            chunk = Buffer.from(chunk, encoding);
        }
        if (!chunk || !chunk.length) {
            return setImmediate(done);
        }
        this.inputBytes += chunk.length;
        if (this._remainingBytes && this._remainingBytes.length) {
            chunk = Buffer.concat([
                this._remainingBytes,
                chunk
            ], this._remainingBytes.length + chunk.length);
            this._remainingBytes = false;
        }
        if (chunk.length % 3) {
            this._remainingBytes = chunk.slice(chunk.length - chunk.length % 3);
            chunk = chunk.slice(0, chunk.length - chunk.length % 3);
        } else {
            this._remainingBytes = false;
        }
        let b64 = this._curLine + encode(chunk);
        if (this.options.lineLength) {
            b64 = wrap(b64, this.options.lineLength);
            // remove last line as it is still most probably incomplete
            let lastLF = b64.lastIndexOf("\n");
            if (lastLF < 0) {
                this._curLine = b64;
                b64 = "";
            } else if (lastLF === b64.length - 1) {
                this._curLine = "";
            } else {
                this._curLine = b64.substr(lastLF + 1);
                b64 = b64.substr(0, lastLF + 1);
            }
        }
        if (b64) {
            this.outputBytes += b64.length;
            this.push(Buffer.from(b64, "ascii"));
        }
        setImmediate(done);
    }
    _flush(done) {
        if (this._remainingBytes && this._remainingBytes.length) {
            this._curLine += encode(this._remainingBytes);
        }
        if (this._curLine) {
            this._curLine = wrap(this._curLine, this.options.lineLength);
            this.outputBytes += this._curLine.length;
            this.push(this._curLine, "ascii");
            this._curLine = "";
        }
        done();
    }
}
// expose to the world
module.exports = {
    encode,
    wrap,
    Encoder
};


/***/ }),

/***/ 40358:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// FIXME:
// replace this Transform mess with a method that pipes input argument to output argument
const MessageParser = __webpack_require__(248);
const RelaxedBody = __webpack_require__(54248);
const sign = __webpack_require__(10837);
const PassThrough = (__webpack_require__(12781).PassThrough);
const fs = __webpack_require__(57147);
const path = __webpack_require__(71017);
const crypto = __webpack_require__(6113);
const DKIM_ALGO = "sha256";
const MAX_MESSAGE_SIZE = 128 * 1024; // buffer messages larger than this to disk
/*
// Usage:

let dkim = new DKIM({
    domainName: 'example.com',
    keySelector: 'key-selector',
    privateKey,
    cacheDir: '/tmp'
});
dkim.sign(input).pipe(process.stdout);

// Where inputStream is a rfc822 message (either a stream, string or Buffer)
// and outputStream is a DKIM signed rfc822 message
*/ class DKIMSigner {
    constructor(options, keys, input, output){
        this.options = options || {};
        this.keys = keys;
        this.cacheTreshold = Number(this.options.cacheTreshold) || MAX_MESSAGE_SIZE;
        this.hashAlgo = this.options.hashAlgo || DKIM_ALGO;
        this.cacheDir = this.options.cacheDir || false;
        this.chunks = [];
        this.chunklen = 0;
        this.readPos = 0;
        this.cachePath = this.cacheDir ? path.join(this.cacheDir, "message." + Date.now() + "-" + crypto.randomBytes(14).toString("hex")) : false;
        this.cache = false;
        this.headers = false;
        this.bodyHash = false;
        this.parser = false;
        this.relaxedBody = false;
        this.input = input;
        this.output = output;
        this.output.usingCache = false;
        this.hasErrored = false;
        this.input.on("error", (err)=>{
            this.hasErrored = true;
            this.cleanup();
            output.emit("error", err);
        });
    }
    cleanup() {
        if (!this.cache || !this.cachePath) {
            return;
        }
        fs.unlink(this.cachePath, ()=>false);
    }
    createReadCache() {
        // pipe remainings to cache file
        this.cache = fs.createReadStream(this.cachePath);
        this.cache.once("error", (err)=>{
            this.cleanup();
            this.output.emit("error", err);
        });
        this.cache.once("close", ()=>{
            this.cleanup();
        });
        this.cache.pipe(this.output);
    }
    sendNextChunk() {
        if (this.hasErrored) {
            return;
        }
        if (this.readPos >= this.chunks.length) {
            if (!this.cache) {
                return this.output.end();
            }
            return this.createReadCache();
        }
        let chunk = this.chunks[this.readPos++];
        if (this.output.write(chunk) === false) {
            return this.output.once("drain", ()=>{
                this.sendNextChunk();
            });
        }
        setImmediate(()=>this.sendNextChunk());
    }
    sendSignedOutput() {
        let keyPos = 0;
        let signNextKey = ()=>{
            if (keyPos >= this.keys.length) {
                this.output.write(this.parser.rawHeaders);
                return setImmediate(()=>this.sendNextChunk());
            }
            let key = this.keys[keyPos++];
            let dkimField = sign(this.headers, this.hashAlgo, this.bodyHash, {
                domainName: key.domainName,
                keySelector: key.keySelector,
                privateKey: key.privateKey,
                headerFieldNames: this.options.headerFieldNames,
                skipFields: this.options.skipFields
            });
            if (dkimField) {
                this.output.write(Buffer.from(dkimField + "\r\n"));
            }
            return setImmediate(signNextKey);
        };
        if (this.bodyHash && this.headers) {
            return signNextKey();
        }
        this.output.write(this.parser.rawHeaders);
        this.sendNextChunk();
    }
    createWriteCache() {
        this.output.usingCache = true;
        // pipe remainings to cache file
        this.cache = fs.createWriteStream(this.cachePath);
        this.cache.once("error", (err)=>{
            this.cleanup();
            // drain input
            this.relaxedBody.unpipe(this.cache);
            this.relaxedBody.on("readable", ()=>{
                while(this.relaxedBody.read() !== null){
                // do nothing
                }
            });
            this.hasErrored = true;
            // emit error
            this.output.emit("error", err);
        });
        this.cache.once("close", ()=>{
            this.sendSignedOutput();
        });
        this.relaxedBody.removeAllListeners("readable");
        this.relaxedBody.pipe(this.cache);
    }
    signStream() {
        this.parser = new MessageParser();
        this.relaxedBody = new RelaxedBody({
            hashAlgo: this.hashAlgo
        });
        this.parser.on("headers", (value)=>{
            this.headers = value;
        });
        this.relaxedBody.on("hash", (value)=>{
            this.bodyHash = value;
        });
        this.relaxedBody.on("readable", ()=>{
            let chunk;
            if (this.cache) {
                return;
            }
            while((chunk = this.relaxedBody.read()) !== null){
                this.chunks.push(chunk);
                this.chunklen += chunk.length;
                if (this.chunklen >= this.cacheTreshold && this.cachePath) {
                    return this.createWriteCache();
                }
            }
        });
        this.relaxedBody.on("end", ()=>{
            if (this.cache) {
                return;
            }
            this.sendSignedOutput();
        });
        this.parser.pipe(this.relaxedBody);
        setImmediate(()=>this.input.pipe(this.parser));
    }
}
class DKIM {
    constructor(options){
        this.options = options || {};
        this.keys = [].concat(this.options.keys || {
            domainName: options.domainName,
            keySelector: options.keySelector,
            privateKey: options.privateKey
        });
    }
    sign(input, extraOptions) {
        let output = new PassThrough();
        let inputStream = input;
        let writeValue = false;
        if (Buffer.isBuffer(input)) {
            writeValue = input;
            inputStream = new PassThrough();
        } else if (typeof input === "string") {
            writeValue = Buffer.from(input);
            inputStream = new PassThrough();
        }
        let options = this.options;
        if (extraOptions && Object.keys(extraOptions).length) {
            options = {};
            Object.keys(this.options || {}).forEach((key)=>{
                options[key] = this.options[key];
            });
            Object.keys(extraOptions || {}).forEach((key)=>{
                if (!(key in options)) {
                    options[key] = extraOptions[key];
                }
            });
        }
        let signer = new DKIMSigner(options, this.keys, inputStream, output);
        setImmediate(()=>{
            signer.signStream();
            if (writeValue) {
                setImmediate(()=>{
                    inputStream.end(writeValue);
                });
            }
        });
        return output;
    }
}
module.exports = DKIM;


/***/ }),

/***/ 248:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const Transform = (__webpack_require__(12781).Transform);
/**
 * MessageParser instance is a transform stream that separates message headers
 * from the rest of the body. Headers are emitted with the 'headers' event. Message
 * body is passed on as the resulting stream.
 */ class MessageParser extends Transform {
    constructor(options){
        super(options);
        this.lastBytes = Buffer.alloc(4);
        this.headersParsed = false;
        this.headerBytes = 0;
        this.headerChunks = [];
        this.rawHeaders = false;
        this.bodySize = 0;
    }
    /**
     * Keeps count of the last 4 bytes in order to detect line breaks on chunk boundaries
     *
     * @param {Buffer} data Next data chunk from the stream
     */ updateLastBytes(data) {
        let lblen = this.lastBytes.length;
        let nblen = Math.min(data.length, lblen);
        // shift existing bytes
        for(let i = 0, len = lblen - nblen; i < len; i++){
            this.lastBytes[i] = this.lastBytes[i + nblen];
        }
        // add new bytes
        for(let i1 = 1; i1 <= nblen; i1++){
            this.lastBytes[lblen - i1] = data[data.length - i1];
        }
    }
    /**
     * Finds and removes message headers from the remaining body. We want to keep
     * headers separated until final delivery to be able to modify these
     *
     * @param {Buffer} data Next chunk of data
     * @return {Boolean} Returns true if headers are already found or false otherwise
     */ checkHeaders(data) {
        if (this.headersParsed) {
            return true;
        }
        let lblen = this.lastBytes.length;
        let headerPos = 0;
        this.curLinePos = 0;
        for(let i = 0, len = this.lastBytes.length + data.length; i < len; i++){
            let chr;
            if (i < lblen) {
                chr = this.lastBytes[i];
            } else {
                chr = data[i - lblen];
            }
            if (chr === 0x0a && i) {
                let pr1 = i - 1 < lblen ? this.lastBytes[i - 1] : data[i - 1 - lblen];
                let pr2 = i > 1 ? i - 2 < lblen ? this.lastBytes[i - 2] : data[i - 2 - lblen] : false;
                if (pr1 === 0x0a) {
                    this.headersParsed = true;
                    headerPos = i - lblen + 1;
                    this.headerBytes += headerPos;
                    break;
                } else if (pr1 === 0x0d && pr2 === 0x0a) {
                    this.headersParsed = true;
                    headerPos = i - lblen + 1;
                    this.headerBytes += headerPos;
                    break;
                }
            }
        }
        if (this.headersParsed) {
            this.headerChunks.push(data.slice(0, headerPos));
            this.rawHeaders = Buffer.concat(this.headerChunks, this.headerBytes);
            this.headerChunks = null;
            this.emit("headers", this.parseHeaders());
            if (data.length - 1 > headerPos) {
                let chunk = data.slice(headerPos);
                this.bodySize += chunk.length;
                // this would be the first chunk of data sent downstream
                setImmediate(()=>this.push(chunk));
            }
            return false;
        } else {
            this.headerBytes += data.length;
            this.headerChunks.push(data);
        }
        // store last 4 bytes to catch header break
        this.updateLastBytes(data);
        return false;
    }
    _transform(chunk, encoding, callback) {
        if (!chunk || !chunk.length) {
            return callback();
        }
        if (typeof chunk === "string") {
            chunk = Buffer.from(chunk, encoding);
        }
        let headersFound;
        try {
            headersFound = this.checkHeaders(chunk);
        } catch (E) {
            return callback(E);
        }
        if (headersFound) {
            this.bodySize += chunk.length;
            this.push(chunk);
        }
        setImmediate(callback);
    }
    _flush(callback) {
        if (this.headerChunks) {
            let chunk = Buffer.concat(this.headerChunks, this.headerBytes);
            this.bodySize += chunk.length;
            this.push(chunk);
            this.headerChunks = null;
        }
        callback();
    }
    parseHeaders() {
        let lines = (this.rawHeaders || "").toString().split(/\r?\n/);
        for(let i = lines.length - 1; i > 0; i--){
            if (/^\s/.test(lines[i])) {
                lines[i - 1] += "\n" + lines[i];
                lines.splice(i, 1);
            }
        }
        return lines.filter((line)=>line.trim()).map((line)=>({
                key: line.substr(0, line.indexOf(":")).trim().toLowerCase(),
                line
            }));
    }
}
module.exports = MessageParser;


/***/ }),

/***/ 54248:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// streams through a message body and calculates relaxed body hash
const Transform = (__webpack_require__(12781).Transform);
const crypto = __webpack_require__(6113);
class RelaxedBody extends Transform {
    constructor(options){
        super();
        options = options || {};
        this.chunkBuffer = [];
        this.chunkBufferLen = 0;
        this.bodyHash = crypto.createHash(options.hashAlgo || "sha1");
        this.remainder = "";
        this.byteLength = 0;
        this.debug = options.debug;
        this._debugBody = options.debug ? [] : false;
    }
    updateHash(chunk) {
        let bodyStr;
        // find next remainder
        let nextRemainder = "";
        // This crux finds and removes the spaces from the last line and the newline characters after the last non-empty line
        // If we get another chunk that does not match this description then we can restore the previously processed data
        let state = "file";
        for(let i = chunk.length - 1; i >= 0; i--){
            let c = chunk[i];
            if (state === "file" && (c === 0x0a || c === 0x0d)) {
            // do nothing, found \n or \r at the end of chunk, stil end of file
            } else if (state === "file" && (c === 0x09 || c === 0x20)) {
                // switch to line ending mode, this is the last non-empty line
                state = "line";
            } else if (state === "line" && (c === 0x09 || c === 0x20)) {
            // do nothing, found ' ' or \t at the end of line, keep processing the last non-empty line
            } else if (state === "file" || state === "line") {
                // non line/file ending character found, switch to body mode
                state = "body";
                if (i === chunk.length - 1) {
                    break;
                }
            }
            if (i === 0) {
                // reached to the beginning of the chunk, check if it is still about the ending
                // and if the remainder also matches
                if (state === "file" && (!this.remainder || /[\r\n]$/.test(this.remainder)) || state === "line" && (!this.remainder || /[ \t]$/.test(this.remainder))) {
                    // keep everything
                    this.remainder += chunk.toString("binary");
                    return;
                } else if (state === "line" || state === "file") {
                    // process existing remainder as normal line but store the current chunk
                    nextRemainder = chunk.toString("binary");
                    chunk = false;
                    break;
                }
            }
            if (state !== "body") {
                continue;
            }
            // reached first non ending byte
            nextRemainder = chunk.slice(i + 1).toString("binary");
            chunk = chunk.slice(0, i + 1);
            break;
        }
        let needsFixing = !!this.remainder;
        if (chunk && !needsFixing) {
            // check if we even need to change anything
            for(let i1 = 0, len = chunk.length; i1 < len; i1++){
                if (i1 && chunk[i1] === 0x0a && chunk[i1 - 1] !== 0x0d) {
                    // missing \r before \n
                    needsFixing = true;
                    break;
                } else if (i1 && chunk[i1] === 0x0d && chunk[i1 - 1] === 0x20) {
                    // trailing WSP found
                    needsFixing = true;
                    break;
                } else if (i1 && chunk[i1] === 0x20 && chunk[i1 - 1] === 0x20) {
                    // multiple spaces found, needs to be replaced with just one
                    needsFixing = true;
                    break;
                } else if (chunk[i1] === 0x09) {
                    // TAB found, needs to be replaced with a space
                    needsFixing = true;
                    break;
                }
            }
        }
        if (needsFixing) {
            bodyStr = this.remainder + (chunk ? chunk.toString("binary") : "");
            this.remainder = nextRemainder;
            bodyStr = bodyStr.replace(/\r?\n/g, "\n") // use js line endings
            .replace(/[ \t]*$/gm, "") // remove line endings, rtrim
            .replace(/[ \t]+/gm, " ") // single spaces
            .replace(/\n/g, "\r\n"); // restore rfc822 line endings
            chunk = Buffer.from(bodyStr, "binary");
        } else if (nextRemainder) {
            this.remainder = nextRemainder;
        }
        if (this.debug) {
            this._debugBody.push(chunk);
        }
        this.bodyHash.update(chunk);
    }
    _transform(chunk, encoding, callback) {
        if (!chunk || !chunk.length) {
            return callback();
        }
        if (typeof chunk === "string") {
            chunk = Buffer.from(chunk, encoding);
        }
        this.updateHash(chunk);
        this.byteLength += chunk.length;
        this.push(chunk);
        callback();
    }
    _flush(callback) {
        // generate final hash and emit it
        if (/[\r\n]$/.test(this.remainder) && this.byteLength > 2) {
            // add terminating line end
            this.bodyHash.update(Buffer.from("\r\n"));
        }
        if (!this.byteLength) {
            // emit empty line buffer to keep the stream flowing
            this.push(Buffer.from("\r\n"));
        // this.bodyHash.update(Buffer.from('\r\n'));
        }
        this.emit("hash", this.bodyHash.digest("base64"), this.debug ? Buffer.concat(this._debugBody) : false);
        callback();
    }
}
module.exports = RelaxedBody;


/***/ }),

/***/ 10837:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const punycode = __webpack_require__(85477);
const mimeFuncs = __webpack_require__(96658);
const crypto = __webpack_require__(6113);
/**
 * Returns DKIM signature header line
 *
 * @param {Object} headers Parsed headers object from MessageParser
 * @param {String} bodyHash Base64 encoded hash of the message
 * @param {Object} options DKIM options
 * @param {String} options.domainName Domain name to be signed for
 * @param {String} options.keySelector DKIM key selector to use
 * @param {String} options.privateKey DKIM private key to use
 * @return {String} Complete header line
 */ module.exports = (headers, hashAlgo, bodyHash, options)=>{
    options = options || {};
    // all listed fields from RFC4871 #5.5
    let defaultFieldNames = "From:Sender:Reply-To:Subject:Date:Message-ID:To:" + "Cc:MIME-Version:Content-Type:Content-Transfer-Encoding:Content-ID:" + "Content-Description:Resent-Date:Resent-From:Resent-Sender:" + "Resent-To:Resent-Cc:Resent-Message-ID:In-Reply-To:References:" + "List-Id:List-Help:List-Unsubscribe:List-Subscribe:List-Post:" + "List-Owner:List-Archive";
    let fieldNames = options.headerFieldNames || defaultFieldNames;
    let canonicalizedHeaderData = relaxedHeaders(headers, fieldNames, options.skipFields);
    let dkimHeader = generateDKIMHeader(options.domainName, options.keySelector, canonicalizedHeaderData.fieldNames, hashAlgo, bodyHash);
    let signer, signature;
    canonicalizedHeaderData.headers += "dkim-signature:" + relaxedHeaderLine(dkimHeader);
    signer = crypto.createSign(("rsa-" + hashAlgo).toUpperCase());
    signer.update(canonicalizedHeaderData.headers);
    try {
        signature = signer.sign(options.privateKey, "base64");
    } catch (E) {
        return false;
    }
    return dkimHeader + signature.replace(/(^.{73}|.{75}(?!\r?\n|\r))/g, "$&\r\n ").trim();
};
module.exports.relaxedHeaders = relaxedHeaders;
function generateDKIMHeader(domainName, keySelector, fieldNames, hashAlgo, bodyHash) {
    let dkim = [
        "v=1",
        "a=rsa-" + hashAlgo,
        "c=relaxed/relaxed",
        "d=" + punycode.toASCII(domainName),
        "q=dns/txt",
        "s=" + keySelector,
        "bh=" + bodyHash,
        "h=" + fieldNames
    ].join("; ");
    return mimeFuncs.foldLines("DKIM-Signature: " + dkim, 76) + ";\r\n b=";
}
function relaxedHeaders(headers, fieldNames, skipFields) {
    let includedFields = new Set();
    let skip = new Set();
    let headerFields = new Map();
    (skipFields || "").toLowerCase().split(":").forEach((field)=>{
        skip.add(field.trim());
    });
    (fieldNames || "").toLowerCase().split(":").filter((field)=>!skip.has(field.trim())).forEach((field)=>{
        includedFields.add(field.trim());
    });
    for(let i = headers.length - 1; i >= 0; i--){
        let line = headers[i];
        // only include the first value from bottom to top
        if (includedFields.has(line.key) && !headerFields.has(line.key)) {
            headerFields.set(line.key, relaxedHeaderLine(line.line));
        }
    }
    let headersList = [];
    let fields = [];
    includedFields.forEach((field)=>{
        if (headerFields.has(field)) {
            fields.push(field);
            headersList.push(field + ":" + headerFields.get(field));
        }
    });
    return {
        headers: headersList.join("\r\n") + "\r\n",
        fieldNames: fields.join(":")
    };
}
function relaxedHeaderLine(line) {
    return line.substr(line.indexOf(":") + 1).replace(/\r?\n/g, "").replace(/\s+/g, " ").trim();
}


/***/ }),

/***/ 65078:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// module to handle cookies
const urllib = __webpack_require__(57310);
const SESSION_TIMEOUT = 1800; // 30 min
/**
 * Creates a biskviit cookie jar for managing cookie values in memory
 *
 * @constructor
 * @param {Object} [options] Optional options object
 */ class Cookies {
    constructor(options){
        this.options = options || {};
        this.cookies = [];
    }
    /**
     * Stores a cookie string to the cookie storage
     *
     * @param {String} cookieStr Value from the 'Set-Cookie:' header
     * @param {String} url Current URL
     */ set(cookieStr, url) {
        let urlparts = urllib.parse(url || "");
        let cookie = this.parse(cookieStr);
        let domain;
        if (cookie.domain) {
            domain = cookie.domain.replace(/^\./, "");
            // do not allow cross origin cookies
            if (// can't be valid if the requested domain is shorter than current hostname
            urlparts.hostname.length < domain.length || // prefix domains with dot to be sure that partial matches are not used
            ("." + urlparts.hostname).substr(-domain.length + 1) !== "." + domain) {
                cookie.domain = urlparts.hostname;
            }
        } else {
            cookie.domain = urlparts.hostname;
        }
        if (!cookie.path) {
            cookie.path = this.getPath(urlparts.pathname);
        }
        // if no expire date, then use sessionTimeout value
        if (!cookie.expires) {
            cookie.expires = new Date(Date.now() + (Number(this.options.sessionTimeout || SESSION_TIMEOUT) || SESSION_TIMEOUT) * 1000);
        }
        return this.add(cookie);
    }
    /**
     * Returns cookie string for the 'Cookie:' header.
     *
     * @param {String} url URL to check for
     * @returns {String} Cookie header or empty string if no matches were found
     */ get(url) {
        return this.list(url).map((cookie)=>cookie.name + "=" + cookie.value).join("; ");
    }
    /**
     * Lists all valied cookie objects for the specified URL
     *
     * @param {String} url URL to check for
     * @returns {Array} An array of cookie objects
     */ list(url) {
        let result = [];
        let i;
        let cookie;
        for(i = this.cookies.length - 1; i >= 0; i--){
            cookie = this.cookies[i];
            if (this.isExpired(cookie)) {
                this.cookies.splice(i, i);
                continue;
            }
            if (this.match(cookie, url)) {
                result.unshift(cookie);
            }
        }
        return result;
    }
    /**
     * Parses cookie string from the 'Set-Cookie:' header
     *
     * @param {String} cookieStr String from the 'Set-Cookie:' header
     * @returns {Object} Cookie object
     */ parse(cookieStr) {
        let cookie = {};
        (cookieStr || "").toString().split(";").forEach((cookiePart)=>{
            let valueParts = cookiePart.split("=");
            let key = valueParts.shift().trim().toLowerCase();
            let value = valueParts.join("=").trim();
            let domain;
            if (!key) {
                // skip empty parts
                return;
            }
            switch(key){
                case "expires":
                    value = new Date(value);
                    // ignore date if can not parse it
                    if (value.toString() !== "Invalid Date") {
                        cookie.expires = value;
                    }
                    break;
                case "path":
                    cookie.path = value;
                    break;
                case "domain":
                    domain = value.toLowerCase();
                    if (domain.length && domain.charAt(0) !== ".") {
                        domain = "." + domain; // ensure preceeding dot for user set domains
                    }
                    cookie.domain = domain;
                    break;
                case "max-age":
                    cookie.expires = new Date(Date.now() + (Number(value) || 0) * 1000);
                    break;
                case "secure":
                    cookie.secure = true;
                    break;
                case "httponly":
                    cookie.httponly = true;
                    break;
                default:
                    if (!cookie.name) {
                        cookie.name = key;
                        cookie.value = value;
                    }
            }
        });
        return cookie;
    }
    /**
     * Checks if a cookie object is valid for a specified URL
     *
     * @param {Object} cookie Cookie object
     * @param {String} url URL to check for
     * @returns {Boolean} true if cookie is valid for specifiec URL
     */ match(cookie, url) {
        let urlparts = urllib.parse(url || "");
        // check if hostname matches
        // .foo.com also matches subdomains, foo.com does not
        if (urlparts.hostname !== cookie.domain && (cookie.domain.charAt(0) !== "." || ("." + urlparts.hostname).substr(-cookie.domain.length) !== cookie.domain)) {
            return false;
        }
        // check if path matches
        let path = this.getPath(urlparts.pathname);
        if (path.substr(0, cookie.path.length) !== cookie.path) {
            return false;
        }
        // check secure argument
        if (cookie.secure && urlparts.protocol !== "https:") {
            return false;
        }
        return true;
    }
    /**
     * Adds (or updates/removes if needed) a cookie object to the cookie storage
     *
     * @param {Object} cookie Cookie value to be stored
     */ add(cookie) {
        let i;
        let len;
        // nothing to do here
        if (!cookie || !cookie.name) {
            return false;
        }
        // overwrite if has same params
        for(i = 0, len = this.cookies.length; i < len; i++){
            if (this.compare(this.cookies[i], cookie)) {
                // check if the cookie needs to be removed instead
                if (this.isExpired(cookie)) {
                    this.cookies.splice(i, 1); // remove expired/unset cookie
                    return false;
                }
                this.cookies[i] = cookie;
                return true;
            }
        }
        // add as new if not already expired
        if (!this.isExpired(cookie)) {
            this.cookies.push(cookie);
        }
        return true;
    }
    /**
     * Checks if two cookie objects are the same
     *
     * @param {Object} a Cookie to check against
     * @param {Object} b Cookie to check against
     * @returns {Boolean} True, if the cookies are the same
     */ compare(a, b) {
        return a.name === b.name && a.path === b.path && a.domain === b.domain && a.secure === b.secure && a.httponly === a.httponly;
    }
    /**
     * Checks if a cookie is expired
     *
     * @param {Object} cookie Cookie object to check against
     * @returns {Boolean} True, if the cookie is expired
     */ isExpired(cookie) {
        return cookie.expires && cookie.expires < new Date() || !cookie.value;
    }
    /**
     * Returns normalized cookie path for an URL path argument
     *
     * @param {String} pathname
     * @returns {String} Normalized path
     */ getPath(pathname) {
        let path = (pathname || "/").split("/");
        path.pop(); // remove filename part
        path = path.join("/").trim();
        // ensure path prefix /
        if (path.charAt(0) !== "/") {
            path = "/" + path;
        }
        // ensure path suffix /
        if (path.substr(-1) !== "/") {
            path += "/";
        }
        return path;
    }
}
module.exports = Cookies;


/***/ }),

/***/ 23872:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const http = __webpack_require__(13685);
const https = __webpack_require__(95687);
const urllib = __webpack_require__(57310);
const zlib = __webpack_require__(59796);
const PassThrough = (__webpack_require__(12781).PassThrough);
const Cookies = __webpack_require__(65078);
const packageData = __webpack_require__(98350);
const MAX_REDIRECTS = 5;
module.exports = function(url, options) {
    return nmfetch(url, options);
};
module.exports.Cookies = Cookies;
function nmfetch(url, options) {
    options = options || {};
    options.fetchRes = options.fetchRes || new PassThrough();
    options.cookies = options.cookies || new Cookies();
    options.redirects = options.redirects || 0;
    options.maxRedirects = isNaN(options.maxRedirects) ? MAX_REDIRECTS : options.maxRedirects;
    if (options.cookie) {
        [].concat(options.cookie || []).forEach((cookie)=>{
            options.cookies.set(cookie, url);
        });
        options.cookie = false;
    }
    let fetchRes = options.fetchRes;
    let parsed = urllib.parse(url);
    let method = (options.method || "").toString().trim().toUpperCase() || "GET";
    let finished = false;
    let cookies;
    let body;
    let handler = parsed.protocol === "https:" ? https : http;
    let headers = {
        "accept-encoding": "gzip,deflate",
        "user-agent": "nodemailer/" + packageData.version
    };
    Object.keys(options.headers || {}).forEach((key)=>{
        headers[key.toLowerCase().trim()] = options.headers[key];
    });
    if (options.userAgent) {
        headers["user-agent"] = options.userAgent;
    }
    if (parsed.auth) {
        headers.Authorization = "Basic " + Buffer.from(parsed.auth).toString("base64");
    }
    if (cookies = options.cookies.get(url)) {
        headers.cookie = cookies;
    }
    if (options.body) {
        if (options.contentType !== false) {
            headers["Content-Type"] = options.contentType || "application/x-www-form-urlencoded";
        }
        if (typeof options.body.pipe === "function") {
            // it's a stream
            headers["Transfer-Encoding"] = "chunked";
            body = options.body;
            body.on("error", (err)=>{
                if (finished) {
                    return;
                }
                finished = true;
                err.type = "FETCH";
                err.sourceUrl = url;
                fetchRes.emit("error", err);
            });
        } else {
            if (options.body instanceof Buffer) {
                body = options.body;
            } else if (typeof options.body === "object") {
                try {
                    // encodeURIComponent can fail on invalid input (partial emoji etc.)
                    body = Buffer.from(Object.keys(options.body).map((key)=>{
                        let value = options.body[key].toString().trim();
                        return encodeURIComponent(key) + "=" + encodeURIComponent(value);
                    }).join("&"));
                } catch (E) {
                    if (finished) {
                        return;
                    }
                    finished = true;
                    E.type = "FETCH";
                    E.sourceUrl = url;
                    fetchRes.emit("error", E);
                    return;
                }
            } else {
                body = Buffer.from(options.body.toString().trim());
            }
            headers["Content-Type"] = options.contentType || "application/x-www-form-urlencoded";
            headers["Content-Length"] = body.length;
        }
        // if method is not provided, use POST instead of GET
        method = (options.method || "").toString().trim().toUpperCase() || "POST";
    }
    let req;
    let reqOptions = {
        method,
        host: parsed.hostname,
        path: parsed.path,
        port: parsed.port ? parsed.port : parsed.protocol === "https:" ? 443 : 80,
        headers,
        rejectUnauthorized: false,
        agent: false
    };
    if (options.tls) {
        Object.keys(options.tls).forEach((key)=>{
            reqOptions[key] = options.tls[key];
        });
    }
    try {
        req = handler.request(reqOptions);
    } catch (E1) {
        finished = true;
        setImmediate(()=>{
            E1.type = "FETCH";
            E1.sourceUrl = url;
            fetchRes.emit("error", E1);
        });
        return fetchRes;
    }
    if (options.timeout) {
        req.setTimeout(options.timeout, ()=>{
            if (finished) {
                return;
            }
            finished = true;
            req.abort();
            let err = new Error("Request Timeout");
            err.type = "FETCH";
            err.sourceUrl = url;
            fetchRes.emit("error", err);
        });
    }
    req.on("error", (err)=>{
        if (finished) {
            return;
        }
        finished = true;
        err.type = "FETCH";
        err.sourceUrl = url;
        fetchRes.emit("error", err);
    });
    req.on("response", (res)=>{
        let inflate;
        if (finished) {
            return;
        }
        switch(res.headers["content-encoding"]){
            case "gzip":
            case "deflate":
                inflate = zlib.createUnzip();
                break;
        }
        if (res.headers["set-cookie"]) {
            [].concat(res.headers["set-cookie"] || []).forEach((cookie)=>{
                options.cookies.set(cookie, url);
            });
        }
        if ([
            301,
            302,
            303,
            307,
            308
        ].includes(res.statusCode) && res.headers.location) {
            // redirect
            options.redirects++;
            if (options.redirects > options.maxRedirects) {
                finished = true;
                let err = new Error("Maximum redirect count exceeded");
                err.type = "FETCH";
                err.sourceUrl = url;
                fetchRes.emit("error", err);
                req.abort();
                return;
            }
            // redirect does not include POST body
            options.method = "GET";
            options.body = false;
            return nmfetch(urllib.resolve(url, res.headers.location), options);
        }
        fetchRes.statusCode = res.statusCode;
        fetchRes.headers = res.headers;
        if (res.statusCode >= 300 && !options.allowErrorResponse) {
            finished = true;
            let err1 = new Error("Invalid status code " + res.statusCode);
            err1.type = "FETCH";
            err1.sourceUrl = url;
            fetchRes.emit("error", err1);
            req.abort();
            return;
        }
        res.on("error", (err)=>{
            if (finished) {
                return;
            }
            finished = true;
            err.type = "FETCH";
            err.sourceUrl = url;
            fetchRes.emit("error", err);
            req.abort();
        });
        if (inflate) {
            res.pipe(inflate).pipe(fetchRes);
            inflate.on("error", (err)=>{
                if (finished) {
                    return;
                }
                finished = true;
                err.type = "FETCH";
                err.sourceUrl = url;
                fetchRes.emit("error", err);
                req.abort();
            });
        } else {
            res.pipe(fetchRes);
        }
    });
    setImmediate(()=>{
        if (body) {
            try {
                if (typeof body.pipe === "function") {
                    return body.pipe(req);
                } else {
                    req.write(body);
                }
            } catch (err) {
                finished = true;
                err.type = "FETCH";
                err.sourceUrl = url;
                fetchRes.emit("error", err);
                return;
            }
        }
        req.end();
    });
    return fetchRes;
}


/***/ }),

/***/ 48261:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const packageData = __webpack_require__(98350);
const shared = __webpack_require__(74741);
/**
 * Generates a Transport object to generate JSON output
 *
 * @constructor
 * @param {Object} optional config parameter
 */ class JSONTransport {
    constructor(options){
        options = options || {};
        this.options = options || {};
        this.name = "JSONTransport";
        this.version = packageData.version;
        this.logger = shared.getLogger(this.options, {
            component: this.options.component || "json-transport"
        });
    }
    /**
     * <p>Compiles a mailcomposer message and forwards it to handler that sends it.</p>
     *
     * @param {Object} emailMessage MailComposer object
     * @param {Function} callback Callback function to run when the sending is completed
     */ send(mail, done) {
        // Sendmail strips this header line by itself
        mail.message.keepBcc = true;
        let envelope = mail.data.envelope || mail.message.getEnvelope();
        let messageId = mail.message.messageId();
        let recipients = [].concat(envelope.to || []);
        if (recipients.length > 3) {
            recipients.push("...and " + recipients.splice(2).length + " more");
        }
        this.logger.info({
            tnx: "send",
            messageId
        }, "Composing JSON structure of %s to <%s>", messageId, recipients.join(", "));
        setImmediate(()=>{
            mail.normalize((err, data)=>{
                if (err) {
                    this.logger.error({
                        err,
                        tnx: "send",
                        messageId
                    }, "Failed building JSON structure for %s. %s", messageId, err.message);
                    return done(err);
                }
                delete data.envelope;
                delete data.normalizedHeaders;
                return done(null, {
                    envelope,
                    messageId,
                    message: this.options.skipEncoding ? data : JSON.stringify(data)
                });
            });
        });
    }
}
module.exports = JSONTransport;


/***/ }),

/***/ 188:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-undefined: 0 */ 
const MimeNode = __webpack_require__(56312);
const mimeFuncs = __webpack_require__(96658);
/**
 * Creates the object for composing a MimeNode instance out from the mail options
 *
 * @constructor
 * @param {Object} mail Mail options
 */ class MailComposer {
    constructor(mail){
        this.mail = mail || {};
        this.message = false;
    }
    /**
     * Builds MimeNode instance
     */ compile() {
        this._alternatives = this.getAlternatives();
        this._htmlNode = this._alternatives.filter((alternative)=>/^text\/html\b/i.test(alternative.contentType)).pop();
        this._attachments = this.getAttachments(!!this._htmlNode);
        this._useRelated = !!(this._htmlNode && this._attachments.related.length);
        this._useAlternative = this._alternatives.length > 1;
        this._useMixed = this._attachments.attached.length > 1 || this._alternatives.length && this._attachments.attached.length === 1;
        // Compose MIME tree
        if (this.mail.raw) {
            this.message = new MimeNode("message/rfc822", {
                newline: this.mail.newline
            }).setRaw(this.mail.raw);
        } else if (this._useMixed) {
            this.message = this._createMixed();
        } else if (this._useAlternative) {
            this.message = this._createAlternative();
        } else if (this._useRelated) {
            this.message = this._createRelated();
        } else {
            this.message = this._createContentNode(false, [].concat(this._alternatives || []).concat(this._attachments.attached || []).shift() || {
                contentType: "text/plain",
                content: ""
            });
        }
        // Add custom headers
        if (this.mail.headers) {
            this.message.addHeader(this.mail.headers);
        }
        // Add headers to the root node, always overrides custom headers
        [
            "from",
            "sender",
            "to",
            "cc",
            "bcc",
            "reply-to",
            "in-reply-to",
            "references",
            "subject",
            "message-id",
            "date"
        ].forEach((header)=>{
            let key = header.replace(/-(\w)/g, (o, c)=>c.toUpperCase());
            if (this.mail[key]) {
                this.message.setHeader(header, this.mail[key]);
            }
        });
        // Sets custom envelope
        if (this.mail.envelope) {
            this.message.setEnvelope(this.mail.envelope);
        }
        // ensure Message-Id value
        this.message.messageId();
        return this.message;
    }
    /**
     * List all attachments. Resulting attachment objects can be used as input for MimeNode nodes
     *
     * @param {Boolean} findRelated If true separate related attachments from attached ones
     * @returns {Object} An object of arrays (`related` and `attached`)
     */ getAttachments(findRelated) {
        let icalEvent, eventObject;
        let attachments = [].concat(this.mail.attachments || []).map((attachment, i)=>{
            let data;
            let isMessageNode = /^message\//i.test(attachment.contentType);
            if (/^data:/i.test(attachment.path || attachment.href)) {
                attachment = this._processDataUrl(attachment);
            }
            data = {
                contentType: attachment.contentType || mimeFuncs.detectMimeType(attachment.filename || attachment.path || attachment.href || "bin"),
                contentDisposition: attachment.contentDisposition || (isMessageNode ? "inline" : "attachment"),
                contentTransferEncoding: "contentTransferEncoding" in attachment ? attachment.contentTransferEncoding : "base64"
            };
            if (attachment.filename) {
                data.filename = attachment.filename;
            } else if (!isMessageNode && attachment.filename !== false) {
                data.filename = (attachment.path || attachment.href || "").split("/").pop().split("?").shift() || "attachment-" + (i + 1);
                if (data.filename.indexOf(".") < 0) {
                    data.filename += "." + mimeFuncs.detectExtension(data.contentType);
                }
            }
            if (/^https?:\/\//i.test(attachment.path)) {
                attachment.href = attachment.path;
                attachment.path = undefined;
            }
            if (attachment.cid) {
                data.cid = attachment.cid;
            }
            if (attachment.raw) {
                data.raw = attachment.raw;
            } else if (attachment.path) {
                data.content = {
                    path: attachment.path
                };
            } else if (attachment.href) {
                data.content = {
                    href: attachment.href,
                    httpHeaders: attachment.httpHeaders
                };
            } else {
                data.content = attachment.content || "";
            }
            if (attachment.encoding) {
                data.encoding = attachment.encoding;
            }
            if (attachment.headers) {
                data.headers = attachment.headers;
            }
            return data;
        });
        if (this.mail.icalEvent) {
            if (typeof this.mail.icalEvent === "object" && (this.mail.icalEvent.content || this.mail.icalEvent.path || this.mail.icalEvent.href || this.mail.icalEvent.raw)) {
                icalEvent = this.mail.icalEvent;
            } else {
                icalEvent = {
                    content: this.mail.icalEvent
                };
            }
            eventObject = {};
            Object.keys(icalEvent).forEach((key)=>{
                eventObject[key] = icalEvent[key];
            });
            eventObject.contentType = "application/ics";
            if (!eventObject.headers) {
                eventObject.headers = {};
            }
            eventObject.filename = eventObject.filename || "invite.ics";
            eventObject.headers["Content-Disposition"] = "attachment";
            eventObject.headers["Content-Transfer-Encoding"] = "base64";
        }
        if (!findRelated) {
            return {
                attached: attachments.concat(eventObject || []),
                related: []
            };
        } else {
            return {
                attached: attachments.filter((attachment)=>!attachment.cid).concat(eventObject || []),
                related: attachments.filter((attachment)=>!!attachment.cid)
            };
        }
    }
    /**
     * List alternatives. Resulting objects can be used as input for MimeNode nodes
     *
     * @returns {Array} An array of alternative elements. Includes the `text` and `html` values as well
     */ getAlternatives() {
        let alternatives = [], text, html, watchHtml, amp, icalEvent, eventObject;
        if (this.mail.text) {
            if (typeof this.mail.text === "object" && (this.mail.text.content || this.mail.text.path || this.mail.text.href || this.mail.text.raw)) {
                text = this.mail.text;
            } else {
                text = {
                    content: this.mail.text
                };
            }
            text.contentType = "text/plain; charset=utf-8";
        }
        if (this.mail.watchHtml) {
            if (typeof this.mail.watchHtml === "object" && (this.mail.watchHtml.content || this.mail.watchHtml.path || this.mail.watchHtml.href || this.mail.watchHtml.raw)) {
                watchHtml = this.mail.watchHtml;
            } else {
                watchHtml = {
                    content: this.mail.watchHtml
                };
            }
            watchHtml.contentType = "text/watch-html; charset=utf-8";
        }
        if (this.mail.amp) {
            if (typeof this.mail.amp === "object" && (this.mail.amp.content || this.mail.amp.path || this.mail.amp.href || this.mail.amp.raw)) {
                amp = this.mail.amp;
            } else {
                amp = {
                    content: this.mail.amp
                };
            }
            amp.contentType = "text/x-amp-html; charset=utf-8";
        }
        // NB! when including attachments with a calendar alternative you might end up in a blank screen on some clients
        if (this.mail.icalEvent) {
            if (typeof this.mail.icalEvent === "object" && (this.mail.icalEvent.content || this.mail.icalEvent.path || this.mail.icalEvent.href || this.mail.icalEvent.raw)) {
                icalEvent = this.mail.icalEvent;
            } else {
                icalEvent = {
                    content: this.mail.icalEvent
                };
            }
            eventObject = {};
            Object.keys(icalEvent).forEach((key)=>{
                eventObject[key] = icalEvent[key];
            });
            if (eventObject.content && typeof eventObject.content === "object") {
                // we are going to have the same attachment twice, so mark this to be
                // resolved just once
                eventObject.content._resolve = true;
            }
            eventObject.filename = false;
            eventObject.contentType = "text/calendar; charset=utf-8; method=" + (eventObject.method || "PUBLISH").toString().trim().toUpperCase();
            if (!eventObject.headers) {
                eventObject.headers = {};
            }
        }
        if (this.mail.html) {
            if (typeof this.mail.html === "object" && (this.mail.html.content || this.mail.html.path || this.mail.html.href || this.mail.html.raw)) {
                html = this.mail.html;
            } else {
                html = {
                    content: this.mail.html
                };
            }
            html.contentType = "text/html; charset=utf-8";
        }
        [].concat(text || []).concat(watchHtml || []).concat(amp || []).concat(html || []).concat(eventObject || []).concat(this.mail.alternatives || []).forEach((alternative)=>{
            let data;
            if (/^data:/i.test(alternative.path || alternative.href)) {
                alternative = this._processDataUrl(alternative);
            }
            data = {
                contentType: alternative.contentType || mimeFuncs.detectMimeType(alternative.filename || alternative.path || alternative.href || "txt"),
                contentTransferEncoding: alternative.contentTransferEncoding
            };
            if (alternative.filename) {
                data.filename = alternative.filename;
            }
            if (/^https?:\/\//i.test(alternative.path)) {
                alternative.href = alternative.path;
                alternative.path = undefined;
            }
            if (alternative.raw) {
                data.raw = alternative.raw;
            } else if (alternative.path) {
                data.content = {
                    path: alternative.path
                };
            } else if (alternative.href) {
                data.content = {
                    href: alternative.href
                };
            } else {
                data.content = alternative.content || "";
            }
            if (alternative.encoding) {
                data.encoding = alternative.encoding;
            }
            if (alternative.headers) {
                data.headers = alternative.headers;
            }
            alternatives.push(data);
        });
        return alternatives;
    }
    /**
     * Builds multipart/mixed node. It should always contain different type of elements on the same level
     * eg. text + attachments
     *
     * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created
     * @returns {Object} MimeNode node element
     */ _createMixed(parentNode) {
        let node;
        if (!parentNode) {
            node = new MimeNode("multipart/mixed", {
                baseBoundary: this.mail.baseBoundary,
                textEncoding: this.mail.textEncoding,
                boundaryPrefix: this.mail.boundaryPrefix,
                disableUrlAccess: this.mail.disableUrlAccess,
                disableFileAccess: this.mail.disableFileAccess,
                normalizeHeaderKey: this.mail.normalizeHeaderKey,
                newline: this.mail.newline
            });
        } else {
            node = parentNode.createChild("multipart/mixed", {
                disableUrlAccess: this.mail.disableUrlAccess,
                disableFileAccess: this.mail.disableFileAccess,
                normalizeHeaderKey: this.mail.normalizeHeaderKey,
                newline: this.mail.newline
            });
        }
        if (this._useAlternative) {
            this._createAlternative(node);
        } else if (this._useRelated) {
            this._createRelated(node);
        }
        [].concat(!this._useAlternative && this._alternatives || []).concat(this._attachments.attached || []).forEach((element)=>{
            // if the element is a html node from related subpart then ignore it
            if (!this._useRelated || element !== this._htmlNode) {
                this._createContentNode(node, element);
            }
        });
        return node;
    }
    /**
     * Builds multipart/alternative node. It should always contain same type of elements on the same level
     * eg. text + html view of the same data
     *
     * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created
     * @returns {Object} MimeNode node element
     */ _createAlternative(parentNode) {
        let node;
        if (!parentNode) {
            node = new MimeNode("multipart/alternative", {
                baseBoundary: this.mail.baseBoundary,
                textEncoding: this.mail.textEncoding,
                boundaryPrefix: this.mail.boundaryPrefix,
                disableUrlAccess: this.mail.disableUrlAccess,
                disableFileAccess: this.mail.disableFileAccess,
                normalizeHeaderKey: this.mail.normalizeHeaderKey,
                newline: this.mail.newline
            });
        } else {
            node = parentNode.createChild("multipart/alternative", {
                disableUrlAccess: this.mail.disableUrlAccess,
                disableFileAccess: this.mail.disableFileAccess,
                normalizeHeaderKey: this.mail.normalizeHeaderKey,
                newline: this.mail.newline
            });
        }
        this._alternatives.forEach((alternative)=>{
            if (this._useRelated && this._htmlNode === alternative) {
                this._createRelated(node);
            } else {
                this._createContentNode(node, alternative);
            }
        });
        return node;
    }
    /**
     * Builds multipart/related node. It should always contain html node with related attachments
     *
     * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created
     * @returns {Object} MimeNode node element
     */ _createRelated(parentNode) {
        let node;
        if (!parentNode) {
            node = new MimeNode('multipart/related; type="text/html"', {
                baseBoundary: this.mail.baseBoundary,
                textEncoding: this.mail.textEncoding,
                boundaryPrefix: this.mail.boundaryPrefix,
                disableUrlAccess: this.mail.disableUrlAccess,
                disableFileAccess: this.mail.disableFileAccess,
                normalizeHeaderKey: this.mail.normalizeHeaderKey,
                newline: this.mail.newline
            });
        } else {
            node = parentNode.createChild('multipart/related; type="text/html"', {
                disableUrlAccess: this.mail.disableUrlAccess,
                disableFileAccess: this.mail.disableFileAccess,
                normalizeHeaderKey: this.mail.normalizeHeaderKey,
                newline: this.mail.newline
            });
        }
        this._createContentNode(node, this._htmlNode);
        this._attachments.related.forEach((alternative)=>this._createContentNode(node, alternative));
        return node;
    }
    /**
     * Creates a regular node with contents
     *
     * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created
     * @param {Object} element Node data
     * @returns {Object} MimeNode node element
     */ _createContentNode(parentNode, element) {
        element = element || {};
        element.content = element.content || "";
        let node;
        let encoding = (element.encoding || "utf8").toString().toLowerCase().replace(/[-_\s]/g, "");
        if (!parentNode) {
            node = new MimeNode(element.contentType, {
                filename: element.filename,
                baseBoundary: this.mail.baseBoundary,
                textEncoding: this.mail.textEncoding,
                boundaryPrefix: this.mail.boundaryPrefix,
                disableUrlAccess: this.mail.disableUrlAccess,
                disableFileAccess: this.mail.disableFileAccess,
                normalizeHeaderKey: this.mail.normalizeHeaderKey,
                newline: this.mail.newline
            });
        } else {
            node = parentNode.createChild(element.contentType, {
                filename: element.filename,
                textEncoding: this.mail.textEncoding,
                disableUrlAccess: this.mail.disableUrlAccess,
                disableFileAccess: this.mail.disableFileAccess,
                normalizeHeaderKey: this.mail.normalizeHeaderKey,
                newline: this.mail.newline
            });
        }
        // add custom headers
        if (element.headers) {
            node.addHeader(element.headers);
        }
        if (element.cid) {
            node.setHeader("Content-Id", "<" + element.cid.replace(/[<>]/g, "") + ">");
        }
        if (element.contentTransferEncoding) {
            node.setHeader("Content-Transfer-Encoding", element.contentTransferEncoding);
        } else if (this.mail.encoding && /^text\//i.test(element.contentType)) {
            node.setHeader("Content-Transfer-Encoding", this.mail.encoding);
        }
        if (!/^text\//i.test(element.contentType) || element.contentDisposition) {
            node.setHeader("Content-Disposition", element.contentDisposition || (element.cid ? "inline" : "attachment"));
        }
        if (typeof element.content === "string" && ![
            "utf8",
            "usascii",
            "ascii"
        ].includes(encoding)) {
            element.content = Buffer.from(element.content, encoding);
        }
        // prefer pregenerated raw content
        if (element.raw) {
            node.setRaw(element.raw);
        } else {
            node.setContent(element.content);
        }
        return node;
    }
    /**
     * Parses data uri and converts it to a Buffer
     *
     * @param {Object} element Content element
     * @return {Object} Parsed element
     */ _processDataUrl(element) {
        let parts = (element.path || element.href).match(/^data:((?:[^;]*;)*(?:[^,]*)),(.*)$/i);
        if (!parts) {
            return element;
        }
        element.content = /\bbase64$/i.test(parts[1]) ? Buffer.from(parts[2], "base64") : Buffer.from(decodeURIComponent(parts[2]));
        if ("path" in element) {
            element.path = false;
        }
        if ("href" in element) {
            element.href = false;
        }
        parts[1].split(";").forEach((item)=>{
            if (/^\w+\/[^/]+$/i.test(item)) {
                element.contentType = element.contentType || item.toLowerCase();
            }
        });
        return element;
    }
}
module.exports = MailComposer;


/***/ }),

/***/ 61469:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const EventEmitter = __webpack_require__(82361);
const shared = __webpack_require__(74741);
const mimeTypes = __webpack_require__(31707);
const MailComposer = __webpack_require__(188);
const DKIM = __webpack_require__(40358);
const httpProxyClient = __webpack_require__(43992);
const util = __webpack_require__(73837);
const urllib = __webpack_require__(57310);
const packageData = __webpack_require__(98350);
const MailMessage = __webpack_require__(11620);
const net = __webpack_require__(41808);
const dns = __webpack_require__(9523);
const crypto = __webpack_require__(6113);
/**
 * Creates an object for exposing the Mail API
 *
 * @constructor
 * @param {Object} transporter Transport object instance to pass the mails to
 */ class Mail extends EventEmitter {
    constructor(transporter, options, defaults){
        super();
        this.options = options || {};
        this._defaults = defaults || {};
        this._defaultPlugins = {
            compile: [
                (...args)=>this._convertDataImages(...args)
            ],
            stream: []
        };
        this._userPlugins = {
            compile: [],
            stream: []
        };
        this.meta = new Map();
        this.dkim = this.options.dkim ? new DKIM(this.options.dkim) : false;
        this.transporter = transporter;
        this.transporter.mailer = this;
        this.logger = shared.getLogger(this.options, {
            component: this.options.component || "mail"
        });
        this.logger.debug({
            tnx: "create"
        }, "Creating transport: %s", this.getVersionString());
        // setup emit handlers for the transporter
        if (typeof this.transporter.on === "function") {
            // deprecated log interface
            this.transporter.on("log", (log)=>{
                this.logger.debug({
                    tnx: "transport"
                }, "%s: %s", log.type, log.message);
            });
            // transporter errors
            this.transporter.on("error", (err)=>{
                this.logger.error({
                    err,
                    tnx: "transport"
                }, "Transport Error: %s", err.message);
                this.emit("error", err);
            });
            // indicates if the sender has became idle
            this.transporter.on("idle", (...args)=>{
                this.emit("idle", ...args);
            });
        }
        /**
         * Optional methods passed to the underlying transport object
         */ [
            "close",
            "isIdle",
            "verify"
        ].forEach((method)=>{
            this[method] = (...args)=>{
                if (typeof this.transporter[method] === "function") {
                    if (method === "verify" && typeof this.getSocket === "function") {
                        this.transporter.getSocket = this.getSocket;
                        this.getSocket = false;
                    }
                    return this.transporter[method](...args);
                } else {
                    this.logger.warn({
                        tnx: "transport",
                        methodName: method
                    }, "Non existing method %s called for transport", method);
                    return false;
                }
            };
        });
        // setup proxy handling
        if (this.options.proxy && typeof this.options.proxy === "string") {
            this.setupProxy(this.options.proxy);
        }
    }
    use(step, plugin) {
        step = (step || "").toString();
        if (!this._userPlugins.hasOwnProperty(step)) {
            this._userPlugins[step] = [
                plugin
            ];
        } else {
            this._userPlugins[step].push(plugin);
        }
        return this;
    }
    /**
     * Sends an email using the preselected transport object
     *
     * @param {Object} data E-data description
     * @param {Function?} callback Callback to run once the sending succeeded or failed
     */ sendMail(data, callback) {
        let promise;
        if (!callback) {
            promise = new Promise((resolve, reject)=>{
                callback = shared.callbackPromise(resolve, reject);
            });
        }
        if (typeof this.getSocket === "function") {
            this.transporter.getSocket = this.getSocket;
            this.getSocket = false;
        }
        let mail = new MailMessage(this, data);
        this.logger.debug({
            tnx: "transport",
            name: this.transporter.name,
            version: this.transporter.version,
            action: "send"
        }, "Sending mail using %s/%s", this.transporter.name, this.transporter.version);
        this._processPlugins("compile", mail, (err)=>{
            if (err) {
                this.logger.error({
                    err,
                    tnx: "plugin",
                    action: "compile"
                }, "PluginCompile Error: %s", err.message);
                return callback(err);
            }
            mail.message = new MailComposer(mail.data).compile();
            mail.setMailerHeader();
            mail.setPriorityHeaders();
            mail.setListHeaders();
            this._processPlugins("stream", mail, (err)=>{
                if (err) {
                    this.logger.error({
                        err,
                        tnx: "plugin",
                        action: "stream"
                    }, "PluginStream Error: %s", err.message);
                    return callback(err);
                }
                if (mail.data.dkim || this.dkim) {
                    mail.message.processFunc((input)=>{
                        let dkim = mail.data.dkim ? new DKIM(mail.data.dkim) : this.dkim;
                        this.logger.debug({
                            tnx: "DKIM",
                            messageId: mail.message.messageId(),
                            dkimDomains: dkim.keys.map((key)=>key.keySelector + "." + key.domainName).join(", ")
                        }, "Signing outgoing message with %s keys", dkim.keys.length);
                        return dkim.sign(input, mail.data._dkim);
                    });
                }
                this.transporter.send(mail, (...args)=>{
                    if (args[0]) {
                        this.logger.error({
                            err: args[0],
                            tnx: "transport",
                            action: "send"
                        }, "Send Error: %s", args[0].message);
                    }
                    callback(...args);
                });
            });
        });
        return promise;
    }
    getVersionString() {
        return util.format("%s (%s; +%s; %s/%s)", packageData.name, packageData.version, packageData.homepage, this.transporter.name, this.transporter.version);
    }
    _processPlugins(step, mail, callback) {
        step = (step || "").toString();
        if (!this._userPlugins.hasOwnProperty(step)) {
            return callback();
        }
        let userPlugins = this._userPlugins[step] || [];
        let defaultPlugins = this._defaultPlugins[step] || [];
        if (userPlugins.length) {
            this.logger.debug({
                tnx: "transaction",
                pluginCount: userPlugins.length,
                step
            }, "Using %s plugins for %s", userPlugins.length, step);
        }
        if (userPlugins.length + defaultPlugins.length === 0) {
            return callback();
        }
        let pos = 0;
        let block = "default";
        let processPlugins = ()=>{
            let curplugins = block === "default" ? defaultPlugins : userPlugins;
            if (pos >= curplugins.length) {
                if (block === "default" && userPlugins.length) {
                    block = "user";
                    pos = 0;
                    curplugins = userPlugins;
                } else {
                    return callback();
                }
            }
            let plugin = curplugins[pos++];
            plugin(mail, (err)=>{
                if (err) {
                    return callback(err);
                }
                processPlugins();
            });
        };
        processPlugins();
    }
    /**
     * Sets up proxy handler for a Nodemailer object
     *
     * @param {String} proxyUrl Proxy configuration url
     */ setupProxy(proxyUrl) {
        let proxy = urllib.parse(proxyUrl);
        // setup socket handler for the mailer object
        this.getSocket = (options, callback)=>{
            let protocol = proxy.protocol.replace(/:$/, "").toLowerCase();
            if (this.meta.has("proxy_handler_" + protocol)) {
                return this.meta.get("proxy_handler_" + protocol)(proxy, options, callback);
            }
            switch(protocol){
                // Connect using a HTTP CONNECT method
                case "http":
                case "https":
                    httpProxyClient(proxy.href, options.port, options.host, (err, socket)=>{
                        if (err) {
                            return callback(err);
                        }
                        return callback(null, {
                            connection: socket
                        });
                    });
                    return;
                case "socks":
                case "socks5":
                case "socks4":
                case "socks4a":
                    {
                        if (!this.meta.has("proxy_socks_module")) {
                            return callback(new Error("Socks module not loaded"));
                        }
                        let connect = (ipaddress)=>{
                            let proxyV2 = !!this.meta.get("proxy_socks_module").SocksClient;
                            let socksClient = proxyV2 ? this.meta.get("proxy_socks_module").SocksClient : this.meta.get("proxy_socks_module");
                            let proxyType = Number(proxy.protocol.replace(/\D/g, "")) || 5;
                            let connectionOpts = {
                                proxy: {
                                    ipaddress,
                                    port: Number(proxy.port),
                                    type: proxyType
                                },
                                [proxyV2 ? "destination" : "target"]: {
                                    host: options.host,
                                    port: options.port
                                },
                                command: "connect"
                            };
                            if (proxy.auth) {
                                let username = decodeURIComponent(proxy.auth.split(":").shift());
                                let password = decodeURIComponent(proxy.auth.split(":").pop());
                                if (proxyV2) {
                                    connectionOpts.proxy.userId = username;
                                    connectionOpts.proxy.password = password;
                                } else if (proxyType === 4) {
                                    connectionOpts.userid = username;
                                } else {
                                    connectionOpts.authentication = {
                                        username,
                                        password
                                    };
                                }
                            }
                            socksClient.createConnection(connectionOpts, (err, info)=>{
                                if (err) {
                                    return callback(err);
                                }
                                return callback(null, {
                                    connection: info.socket || info
                                });
                            });
                        };
                        if (net.isIP(proxy.hostname)) {
                            return connect(proxy.hostname);
                        }
                        return dns.resolve(proxy.hostname, (err, address)=>{
                            if (err) {
                                return callback(err);
                            }
                            connect(Array.isArray(address) ? address[0] : address);
                        });
                    }
            }
            callback(new Error("Unknown proxy configuration"));
        };
    }
    _convertDataImages(mail, callback) {
        if (!this.options.attachDataUrls && !mail.data.attachDataUrls || !mail.data.html) {
            return callback();
        }
        mail.resolveContent(mail.data, "html", (err, html)=>{
            if (err) {
                return callback(err);
            }
            let cidCounter = 0;
            html = (html || "").toString().replace(/(<img\b[^>]* src\s*=[\s"']*)(data:([^;]+);[^"'>\s]+)/gi, (match, prefix, dataUri, mimeType)=>{
                let cid = crypto.randomBytes(10).toString("hex") + "@localhost";
                if (!mail.data.attachments) {
                    mail.data.attachments = [];
                }
                if (!Array.isArray(mail.data.attachments)) {
                    mail.data.attachments = [].concat(mail.data.attachments || []);
                }
                mail.data.attachments.push({
                    path: dataUri,
                    cid,
                    filename: "image-" + ++cidCounter + "." + mimeTypes.detectExtension(mimeType)
                });
                return prefix + "cid:" + cid;
            });
            mail.data.html = html;
            callback();
        });
    }
    set(key, value) {
        return this.meta.set(key, value);
    }
    get(key) {
        return this.meta.get(key);
    }
}
module.exports = Mail;


/***/ }),

/***/ 11620:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const shared = __webpack_require__(74741);
const MimeNode = __webpack_require__(56312);
const mimeFuncs = __webpack_require__(96658);
class MailMessage {
    constructor(mailer, data){
        this.mailer = mailer;
        this.data = {};
        this.message = null;
        data = data || {};
        let options = mailer.options || {};
        let defaults = mailer._defaults || {};
        Object.keys(data).forEach((key)=>{
            this.data[key] = data[key];
        });
        this.data.headers = this.data.headers || {};
        // apply defaults
        Object.keys(defaults).forEach((key)=>{
            if (!(key in this.data)) {
                this.data[key] = defaults[key];
            } else if (key === "headers") {
                // headers is a special case. Allow setting individual default headers
                Object.keys(defaults.headers).forEach((key)=>{
                    if (!(key in this.data.headers)) {
                        this.data.headers[key] = defaults.headers[key];
                    }
                });
            }
        });
        // force specific keys from transporter options
        [
            "disableFileAccess",
            "disableUrlAccess",
            "normalizeHeaderKey"
        ].forEach((key)=>{
            if (key in options) {
                this.data[key] = options[key];
            }
        });
    }
    resolveContent(...args) {
        return shared.resolveContent(...args);
    }
    resolveAll(callback) {
        let keys = [
            [
                this.data,
                "html"
            ],
            [
                this.data,
                "text"
            ],
            [
                this.data,
                "watchHtml"
            ],
            [
                this.data,
                "amp"
            ],
            [
                this.data,
                "icalEvent"
            ]
        ];
        if (this.data.alternatives && this.data.alternatives.length) {
            this.data.alternatives.forEach((alternative, i)=>{
                keys.push([
                    this.data.alternatives,
                    i
                ]);
            });
        }
        if (this.data.attachments && this.data.attachments.length) {
            this.data.attachments.forEach((attachment, i)=>{
                if (!attachment.filename) {
                    attachment.filename = (attachment.path || attachment.href || "").split("/").pop().split("?").shift() || "attachment-" + (i + 1);
                    if (attachment.filename.indexOf(".") < 0) {
                        attachment.filename += "." + mimeFuncs.detectExtension(attachment.contentType);
                    }
                }
                if (!attachment.contentType) {
                    attachment.contentType = mimeFuncs.detectMimeType(attachment.filename || attachment.path || attachment.href || "bin");
                }
                keys.push([
                    this.data.attachments,
                    i
                ]);
            });
        }
        let mimeNode = new MimeNode();
        let addressKeys = [
            "from",
            "to",
            "cc",
            "bcc",
            "sender",
            "replyTo"
        ];
        addressKeys.forEach((address)=>{
            let value;
            if (this.message) {
                value = [].concat(mimeNode._parseAddresses(this.message.getHeader(address === "replyTo" ? "reply-to" : address)) || []);
            } else if (this.data[address]) {
                value = [].concat(mimeNode._parseAddresses(this.data[address]) || []);
            }
            if (value && value.length) {
                this.data[address] = value;
            } else if (address in this.data) {
                this.data[address] = null;
            }
        });
        let singleKeys = [
            "from",
            "sender"
        ];
        singleKeys.forEach((address)=>{
            if (this.data[address]) {
                this.data[address] = this.data[address].shift();
            }
        });
        let pos = 0;
        let resolveNext = ()=>{
            if (pos >= keys.length) {
                return callback(null, this.data);
            }
            let args = keys[pos++];
            if (!args[0] || !args[0][args[1]]) {
                return resolveNext();
            }
            shared.resolveContent(...args, (err, value)=>{
                if (err) {
                    return callback(err);
                }
                let node = {
                    content: value
                };
                if (args[0][args[1]] && typeof args[0][args[1]] === "object" && !Buffer.isBuffer(args[0][args[1]])) {
                    Object.keys(args[0][args[1]]).forEach((key)=>{
                        if (!(key in node) && ![
                            "content",
                            "path",
                            "href",
                            "raw"
                        ].includes(key)) {
                            node[key] = args[0][args[1]][key];
                        }
                    });
                }
                args[0][args[1]] = node;
                resolveNext();
            });
        };
        setImmediate(()=>resolveNext());
    }
    normalize(callback) {
        let envelope = this.data.envelope || this.message.getEnvelope();
        let messageId = this.message.messageId();
        this.resolveAll((err, data)=>{
            if (err) {
                return callback(err);
            }
            data.envelope = envelope;
            data.messageId = messageId;
            [
                "html",
                "text",
                "watchHtml",
                "amp"
            ].forEach((key)=>{
                if (data[key] && data[key].content) {
                    if (typeof data[key].content === "string") {
                        data[key] = data[key].content;
                    } else if (Buffer.isBuffer(data[key].content)) {
                        data[key] = data[key].content.toString();
                    }
                }
            });
            if (data.icalEvent && Buffer.isBuffer(data.icalEvent.content)) {
                data.icalEvent.content = data.icalEvent.content.toString("base64");
                data.icalEvent.encoding = "base64";
            }
            if (data.alternatives && data.alternatives.length) {
                data.alternatives.forEach((alternative)=>{
                    if (alternative && alternative.content && Buffer.isBuffer(alternative.content)) {
                        alternative.content = alternative.content.toString("base64");
                        alternative.encoding = "base64";
                    }
                });
            }
            if (data.attachments && data.attachments.length) {
                data.attachments.forEach((attachment)=>{
                    if (attachment && attachment.content && Buffer.isBuffer(attachment.content)) {
                        attachment.content = attachment.content.toString("base64");
                        attachment.encoding = "base64";
                    }
                });
            }
            data.normalizedHeaders = {};
            Object.keys(data.headers || {}).forEach((key)=>{
                let value = [].concat(data.headers[key] || []).shift();
                value = value && value.value || value;
                if (value) {
                    if ([
                        "references",
                        "in-reply-to",
                        "message-id",
                        "content-id"
                    ].includes(key)) {
                        value = this.message._encodeHeaderValue(key, value);
                    }
                    data.normalizedHeaders[key] = value;
                }
            });
            if (data.list && typeof data.list === "object") {
                let listHeaders = this._getListHeaders(data.list);
                listHeaders.forEach((entry)=>{
                    data.normalizedHeaders[entry.key] = entry.value.map((val)=>val && val.value || val).join(", ");
                });
            }
            if (data.references) {
                data.normalizedHeaders.references = this.message._encodeHeaderValue("references", data.references);
            }
            if (data.inReplyTo) {
                data.normalizedHeaders["in-reply-to"] = this.message._encodeHeaderValue("in-reply-to", data.inReplyTo);
            }
            return callback(null, data);
        });
    }
    setMailerHeader() {
        if (!this.message || !this.data.xMailer) {
            return;
        }
        this.message.setHeader("X-Mailer", this.data.xMailer);
    }
    setPriorityHeaders() {
        if (!this.message || !this.data.priority) {
            return;
        }
        switch((this.data.priority || "").toString().toLowerCase()){
            case "high":
                this.message.setHeader("X-Priority", "1 (Highest)");
                this.message.setHeader("X-MSMail-Priority", "High");
                this.message.setHeader("Importance", "High");
                break;
            case "low":
                this.message.setHeader("X-Priority", "5 (Lowest)");
                this.message.setHeader("X-MSMail-Priority", "Low");
                this.message.setHeader("Importance", "Low");
                break;
            default:
        }
    }
    setListHeaders() {
        if (!this.message || !this.data.list || typeof this.data.list !== "object") {
            return;
        }
        // add optional List-* headers
        if (this.data.list && typeof this.data.list === "object") {
            this._getListHeaders(this.data.list).forEach((listHeader)=>{
                listHeader.value.forEach((value)=>{
                    this.message.addHeader(listHeader.key, value);
                });
            });
        }
    }
    _getListHeaders(listData) {
        // make sure an url looks like <protocol:url>
        return Object.keys(listData).map((key)=>({
                key: "list-" + key.toLowerCase().trim(),
                value: [].concat(listData[key] || []).map((value)=>({
                        prepared: true,
                        foldLines: true,
                        value: [].concat(value || []).map((value)=>{
                            if (typeof value === "string") {
                                value = {
                                    url: value
                                };
                            }
                            if (value && value.url) {
                                if (key.toLowerCase().trim() === "id") {
                                    // List-ID: "comment" <domain>
                                    let comment = value.comment || "";
                                    if (mimeFuncs.isPlainText(comment)) {
                                        comment = '"' + comment + '"';
                                    } else {
                                        comment = mimeFuncs.encodeWord(comment);
                                    }
                                    return (value.comment ? comment + " " : "") + this._formatListUrl(value.url).replace(/^<[^:]+\/{,2}/, "");
                                }
                                // List-*: <http://domain> (comment)
                                let comment1 = value.comment || "";
                                if (!mimeFuncs.isPlainText(comment1)) {
                                    comment1 = mimeFuncs.encodeWord(comment1);
                                }
                                return this._formatListUrl(value.url) + (value.comment ? " (" + comment1 + ")" : "");
                            }
                            return "";
                        }).filter((value)=>value).join(", ")
                    }))
            }));
    }
    _formatListUrl(url) {
        url = url.replace(/[\s<]+|[\s>]+/g, "");
        if (/^(https?|mailto|ftp):/.test(url)) {
            return "<" + url + ">";
        }
        if (/^[^@]+@[^@]+$/.test(url)) {
            return "<mailto:" + url + ">";
        }
        return "<http://" + url + ">";
    }
}
module.exports = MailMessage;


/***/ }),

/***/ 96658:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-control-regex:0 */ 
const base64 = __webpack_require__(60038);
const qp = __webpack_require__(9050);
const mimeTypes = __webpack_require__(31707);
module.exports = {
    /**
     * Checks if a value is plaintext string (uses only printable 7bit chars)
     *
     * @param {String} value String to be tested
     * @returns {Boolean} true if it is a plaintext string
     */ isPlainText (value, isParam) {
        const re = isParam ? /[\x00-\x08\x0b\x0c\x0e-\x1f"\u0080-\uFFFF]/ : /[\x00-\x08\x0b\x0c\x0e-\x1f\u0080-\uFFFF]/;
        if (typeof value !== "string" || re.test(value)) {
            return false;
        } else {
            return true;
        }
    },
    /**
     * Checks if a multi line string containes lines longer than the selected value.
     *
     * Useful when detecting if a mail message needs any processing at all –
     * if only plaintext characters are used and lines are short, then there is
     * no need to encode the values in any way. If the value is plaintext but has
     * longer lines then allowed, then use format=flowed
     *
     * @param {Number} lineLength Max line length to check for
     * @returns {Boolean} Returns true if there is at least one line longer than lineLength chars
     */ hasLongerLines (str, lineLength) {
        if (str.length > 128 * 1024) {
            // do not test strings longer than 128kB
            return true;
        }
        return new RegExp("^.{" + (lineLength + 1) + ",}", "m").test(str);
    },
    /**
     * Encodes a string or an Buffer to an UTF-8 MIME Word (rfc2047)
     *
     * @param {String|Buffer} data String to be encoded
     * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B
     * @param {Number} [maxLength=0] If set, split mime words into several chunks if needed
     * @return {String} Single or several mime words joined together
     */ encodeWord (data, mimeWordEncoding, maxLength) {
        mimeWordEncoding = (mimeWordEncoding || "Q").toString().toUpperCase().trim().charAt(0);
        maxLength = maxLength || 0;
        let encodedStr;
        let toCharset = "UTF-8";
        if (maxLength && maxLength > 7 + toCharset.length) {
            maxLength -= 7 + toCharset.length;
        }
        if (mimeWordEncoding === "Q") {
            // https://tools.ietf.org/html/rfc2047#section-5 rule (3)
            encodedStr = qp.encode(data).replace(/[^a-z0-9!*+\-/=]/gi, (chr)=>{
                let ord = chr.charCodeAt(0).toString(16).toUpperCase();
                if (chr === " ") {
                    return "_";
                } else {
                    return "=" + (ord.length === 1 ? "0" + ord : ord);
                }
            });
        } else if (mimeWordEncoding === "B") {
            encodedStr = typeof data === "string" ? data : base64.encode(data);
            maxLength = maxLength ? Math.max(3, (maxLength - maxLength % 4) / 4 * 3) : 0;
        }
        if (maxLength && (mimeWordEncoding !== "B" ? encodedStr : base64.encode(data)).length > maxLength) {
            if (mimeWordEncoding === "Q") {
                encodedStr = this.splitMimeEncodedString(encodedStr, maxLength).join("?= =?" + toCharset + "?" + mimeWordEncoding + "?");
            } else {
                // RFC2047 6.3 (2) states that encoded-word must include an integral number of characters, so no chopping unicode sequences
                let parts = [];
                let lpart = "";
                for(let i = 0, len = encodedStr.length; i < len; i++){
                    let chr = encodedStr.charAt(i);
                    // check if we can add this character to the existing string
                    // without breaking byte length limit
                    if (Buffer.byteLength(lpart + chr) <= maxLength || i === 0) {
                        lpart += chr;
                    } else {
                        // we hit the length limit, so push the existing string and start over
                        parts.push(base64.encode(lpart));
                        lpart = chr;
                    }
                }
                if (lpart) {
                    parts.push(base64.encode(lpart));
                }
                if (parts.length > 1) {
                    encodedStr = parts.join("?= =?" + toCharset + "?" + mimeWordEncoding + "?");
                } else {
                    encodedStr = parts.join("");
                }
            }
        } else if (mimeWordEncoding === "B") {
            encodedStr = base64.encode(data);
        }
        return "=?" + toCharset + "?" + mimeWordEncoding + "?" + encodedStr + (encodedStr.substr(-2) === "?=" ? "" : "?=");
    },
    /**
     * Finds word sequences with non ascii text and converts these to mime words
     *
     * @param {String} value String to be encoded
     * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B
     * @param {Number} [maxLength=0] If set, split mime words into several chunks if needed
     * @param {Boolean} [encodeAll=false] If true and the value needs encoding then encodes entire string, not just the smallest match
     * @return {String} String with possible mime words
     */ encodeWords (value, mimeWordEncoding, maxLength, encodeAll) {
        maxLength = maxLength || 0;
        let encodedValue;
        // find first word with a non-printable ascii or special symbol in it
        let firstMatch = value.match(/(?:^|\s)([^\s]*["\u0080-\uFFFF])/);
        if (!firstMatch) {
            return value;
        }
        if (encodeAll) {
            // if it is requested to encode everything or the string contains something that resebles encoded word, then encode everything
            return this.encodeWord(value, mimeWordEncoding, maxLength);
        }
        // find the last word with a non-printable ascii in it
        let lastMatch = value.match(/(["\u0080-\uFFFF][^\s]*)[^"\u0080-\uFFFF]*$/);
        if (!lastMatch) {
            // should not happen
            return value;
        }
        let startIndex = firstMatch.index + (firstMatch[0].match(/[^\s]/) || {
            index: 0
        }).index;
        let endIndex = lastMatch.index + (lastMatch[1] || "").length;
        encodedValue = (startIndex ? value.substr(0, startIndex) : "") + this.encodeWord(value.substring(startIndex, endIndex), mimeWordEncoding || "Q", maxLength) + (endIndex < value.length ? value.substr(endIndex) : "");
        return encodedValue;
    },
    /**
     * Joins parsed header value together as 'value; param1=value1; param2=value2'
     * PS: We are following RFC 822 for the list of special characters that we need to keep in quotes.
     *      Refer: https://www.w3.org/Protocols/rfc1341/4_Content-Type.html
     * @param {Object} structured Parsed header value
     * @return {String} joined header value
     */ buildHeaderValue (structured) {
        let paramsArray = [];
        Object.keys(structured.params || {}).forEach((param)=>{
            // filename might include unicode characters so it is a special case
            // other values probably do not
            let value = structured.params[param];
            if (!this.isPlainText(value, true) || value.length >= 75) {
                this.buildHeaderParam(param, value, 50).forEach((encodedParam)=>{
                    if (!/[\s"\\;:/=(),<>@[\]?]|^[-']|'$/.test(encodedParam.value) || encodedParam.key.substr(-1) === "*") {
                        paramsArray.push(encodedParam.key + "=" + encodedParam.value);
                    } else {
                        paramsArray.push(encodedParam.key + "=" + JSON.stringify(encodedParam.value));
                    }
                });
            } else if (/[\s'"\\;:/=(),<>@[\]?]|^-/.test(value)) {
                paramsArray.push(param + "=" + JSON.stringify(value));
            } else {
                paramsArray.push(param + "=" + value);
            }
        });
        return structured.value + (paramsArray.length ? "; " + paramsArray.join("; ") : "");
    },
    /**
     * Encodes a string or an Buffer to an UTF-8 Parameter Value Continuation encoding (rfc2231)
     * Useful for splitting long parameter values.
     *
     * For example
     *      title="unicode string"
     * becomes
     *     title*0*=utf-8''unicode
     *     title*1*=%20string
     *
     * @param {String|Buffer} data String to be encoded
     * @param {Number} [maxLength=50] Max length for generated chunks
     * @param {String} [fromCharset='UTF-8'] Source sharacter set
     * @return {Array} A list of encoded keys and headers
     */ buildHeaderParam (key, data, maxLength) {
        let list = [];
        let encodedStr = typeof data === "string" ? data : (data || "").toString();
        let encodedStrArr;
        let chr, ord;
        let line;
        let startPos = 0;
        let i, len;
        maxLength = maxLength || 50;
        // process ascii only text
        if (this.isPlainText(data, true)) {
            // check if conversion is even needed
            if (encodedStr.length <= maxLength) {
                return [
                    {
                        key,
                        value: encodedStr
                    }
                ];
            }
            encodedStr = encodedStr.replace(new RegExp(".{" + maxLength + "}", "g"), (str)=>{
                list.push({
                    line: str
                });
                return "";
            });
            if (encodedStr) {
                list.push({
                    line: encodedStr
                });
            }
        } else {
            if (/[\uD800-\uDBFF]/.test(encodedStr)) {
                // string containts surrogate pairs, so normalize it to an array of bytes
                encodedStrArr = [];
                for(i = 0, len = encodedStr.length; i < len; i++){
                    chr = encodedStr.charAt(i);
                    ord = chr.charCodeAt(0);
                    if (ord >= 0xd800 && ord <= 0xdbff && i < len - 1) {
                        chr += encodedStr.charAt(i + 1);
                        encodedStrArr.push(chr);
                        i++;
                    } else {
                        encodedStrArr.push(chr);
                    }
                }
                encodedStr = encodedStrArr;
            }
            // first line includes the charset and language info and needs to be encoded
            // even if it does not contain any unicode characters
            line = "utf-8''";
            let encoded = true;
            startPos = 0;
            // process text with unicode or special chars
            for(i = 0, len = encodedStr.length; i < len; i++){
                chr = encodedStr[i];
                if (encoded) {
                    chr = this.safeEncodeURIComponent(chr);
                } else {
                    // try to urlencode current char
                    chr = chr === " " ? chr : this.safeEncodeURIComponent(chr);
                    // By default it is not required to encode a line, the need
                    // only appears when the string contains unicode or special chars
                    // in this case we start processing the line over and encode all chars
                    if (chr !== encodedStr[i]) {
                        // Check if it is even possible to add the encoded char to the line
                        // If not, there is no reason to use this line, just push it to the list
                        // and start a new line with the char that needs encoding
                        if ((this.safeEncodeURIComponent(line) + chr).length >= maxLength) {
                            list.push({
                                line,
                                encoded
                            });
                            line = "";
                            startPos = i - 1;
                        } else {
                            encoded = true;
                            i = startPos;
                            line = "";
                            continue;
                        }
                    }
                }
                // if the line is already too long, push it to the list and start a new one
                if ((line + chr).length >= maxLength) {
                    list.push({
                        line,
                        encoded
                    });
                    line = chr = encodedStr[i] === " " ? " " : this.safeEncodeURIComponent(encodedStr[i]);
                    if (chr === encodedStr[i]) {
                        encoded = false;
                        startPos = i - 1;
                    } else {
                        encoded = true;
                    }
                } else {
                    line += chr;
                }
            }
            if (line) {
                list.push({
                    line,
                    encoded
                });
            }
        }
        return list.map((item, i)=>({
                // encoded lines: {name}*{part}*
                // unencoded lines: {name}*{part}
                // if any line needs to be encoded then the first line (part==0) is always encoded
                key: key + "*" + i + (item.encoded ? "*" : ""),
                value: item.line
            }));
    },
    /**
     * Parses a header value with key=value arguments into a structured
     * object.
     *
     *   parseHeaderValue('content-type: text/plain; CHARSET='UTF-8'') ->
     *   {
     *     'value': 'text/plain',
     *     'params': {
     *       'charset': 'UTF-8'
     *     }
     *   }
     *
     * @param {String} str Header value
     * @return {Object} Header value as a parsed structure
     */ parseHeaderValue (str) {
        let response = {
            value: false,
            params: {}
        };
        let key = false;
        let value = "";
        let type = "value";
        let quote = false;
        let escaped = false;
        let chr;
        for(let i = 0, len = str.length; i < len; i++){
            chr = str.charAt(i);
            if (type === "key") {
                if (chr === "=") {
                    key = value.trim().toLowerCase();
                    type = "value";
                    value = "";
                    continue;
                }
                value += chr;
            } else {
                if (escaped) {
                    value += chr;
                } else if (chr === "\\") {
                    escaped = true;
                    continue;
                } else if (quote && chr === quote) {
                    quote = false;
                } else if (!quote && chr === '"') {
                    quote = chr;
                } else if (!quote && chr === ";") {
                    if (key === false) {
                        response.value = value.trim();
                    } else {
                        response.params[key] = value.trim();
                    }
                    type = "key";
                    value = "";
                } else {
                    value += chr;
                }
                escaped = false;
            }
        }
        if (type === "value") {
            if (key === false) {
                response.value = value.trim();
            } else {
                response.params[key] = value.trim();
            }
        } else if (value.trim()) {
            response.params[value.trim().toLowerCase()] = "";
        }
        // handle parameter value continuations
        // https://tools.ietf.org/html/rfc2231#section-3
        // preprocess values
        Object.keys(response.params).forEach((key)=>{
            let actualKey, nr, match, value;
            if (match = key.match(/(\*(\d+)|\*(\d+)\*|\*)$/)) {
                actualKey = key.substr(0, match.index);
                nr = Number(match[2] || match[3]) || 0;
                if (!response.params[actualKey] || typeof response.params[actualKey] !== "object") {
                    response.params[actualKey] = {
                        charset: false,
                        values: []
                    };
                }
                value = response.params[key];
                if (nr === 0 && match[0].substr(-1) === "*" && (match = value.match(/^([^']*)'[^']*'(.*)$/))) {
                    response.params[actualKey].charset = match[1] || "iso-8859-1";
                    value = match[2];
                }
                response.params[actualKey].values[nr] = value;
                // remove the old reference
                delete response.params[key];
            }
        });
        // concatenate split rfc2231 strings and convert encoded strings to mime encoded words
        Object.keys(response.params).forEach((key)=>{
            let value;
            if (response.params[key] && Array.isArray(response.params[key].values)) {
                value = response.params[key].values.map((val)=>val || "").join("");
                if (response.params[key].charset) {
                    // convert "%AB" to "=?charset?Q?=AB?="
                    response.params[key] = "=?" + response.params[key].charset + "?Q?" + value// fix invalidly encoded chars
                    .replace(/[=?_\s]/g, (s)=>{
                        let c = s.charCodeAt(0).toString(16);
                        if (s === " ") {
                            return "_";
                        } else {
                            return "%" + (c.length < 2 ? "0" : "") + c;
                        }
                    })// change from urlencoding to percent encoding
                    .replace(/%/g, "=") + "?=";
                } else {
                    response.params[key] = value;
                }
            }
        });
        return response;
    },
    /**
     * Returns file extension for a content type string. If no suitable extensions
     * are found, 'bin' is used as the default extension
     *
     * @param {String} mimeType Content type to be checked for
     * @return {String} File extension
     */ detectExtension: (mimeType)=>mimeTypes.detectExtension(mimeType),
    /**
     * Returns content type for a file extension. If no suitable content types
     * are found, 'application/octet-stream' is used as the default content type
     *
     * @param {String} extension Extension to be checked for
     * @return {String} File extension
     */ detectMimeType: (extension)=>mimeTypes.detectMimeType(extension),
    /**
     * Folds long lines, useful for folding header lines (afterSpace=false) and
     * flowed text (afterSpace=true)
     *
     * @param {String} str String to be folded
     * @param {Number} [lineLength=76] Maximum length of a line
     * @param {Boolean} afterSpace If true, leave a space in th end of a line
     * @return {String} String with folded lines
     */ foldLines (str, lineLength, afterSpace) {
        str = (str || "").toString();
        lineLength = lineLength || 76;
        let pos = 0, len = str.length, result = "", line, match;
        while(pos < len){
            line = str.substr(pos, lineLength);
            if (line.length < lineLength) {
                result += line;
                break;
            }
            if (match = line.match(/^[^\n\r]*(\r?\n|\r)/)) {
                line = match[0];
                result += line;
                pos += line.length;
                continue;
            } else if ((match = line.match(/(\s+)[^\s]*$/)) && match[0].length - (afterSpace ? (match[1] || "").length : 0) < line.length) {
                line = line.substr(0, line.length - (match[0].length - (afterSpace ? (match[1] || "").length : 0)));
            } else if (match = str.substr(pos + line.length).match(/^[^\s]+(\s*)/)) {
                line = line + match[0].substr(0, match[0].length - (!afterSpace ? (match[1] || "").length : 0));
            }
            result += line;
            pos += line.length;
            if (pos < len) {
                result += "\r\n";
            }
        }
        return result;
    },
    /**
     * Splits a mime encoded string. Needed for dividing mime words into smaller chunks
     *
     * @param {String} str Mime encoded string to be split up
     * @param {Number} maxlen Maximum length of characters for one part (minimum 12)
     * @return {Array} Split string
     */ splitMimeEncodedString: (str, maxlen)=>{
        let curLine, match, chr, done, lines = [];
        // require at least 12 symbols to fit possible 4 octet UTF-8 sequences
        maxlen = Math.max(maxlen || 0, 12);
        while(str.length){
            curLine = str.substr(0, maxlen);
            // move incomplete escaped char back to main
            if (match = curLine.match(/[=][0-9A-F]?$/i)) {
                curLine = curLine.substr(0, match.index);
            }
            done = false;
            while(!done){
                done = true;
                // check if not middle of a unicode char sequence
                if (match = str.substr(curLine.length).match(/^[=]([0-9A-F]{2})/i)) {
                    chr = parseInt(match[1], 16);
                    // invalid sequence, move one char back anc recheck
                    if (chr < 0xc2 && chr > 0x7f) {
                        curLine = curLine.substr(0, curLine.length - 3);
                        done = false;
                    }
                }
            }
            if (curLine.length) {
                lines.push(curLine);
            }
            str = str.substr(curLine.length);
        }
        return lines;
    },
    encodeURICharComponent: (chr)=>{
        let res = "";
        let ord = chr.charCodeAt(0).toString(16).toUpperCase();
        if (ord.length % 2) {
            ord = "0" + ord;
        }
        if (ord.length > 2) {
            for(let i = 0, len = ord.length / 2; i < len; i++){
                res += "%" + ord.substr(i, 2);
            }
        } else {
            res += "%" + ord;
        }
        return res;
    },
    safeEncodeURIComponent (str) {
        str = (str || "").toString();
        try {
            // might throw if we try to encode invalid sequences, eg. partial emoji
            str = encodeURIComponent(str);
        } catch (E) {
            // should never run
            return str.replace(/[^\x00-\x1F *'()<>@,;:\\"[\]?=\u007F-\uFFFF]+/g, "");
        }
        // ensure chars that are not handled by encodeURICompent are converted as well
        return str.replace(/[\x00-\x1F *'()<>@,;:\\"[\]?=\u007F-\uFFFF]/g, (chr)=>this.encodeURICharComponent(chr));
    }
};


/***/ }),

/***/ 31707:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint quote-props: 0 */ 
const path = __webpack_require__(71017);
const defaultMimeType = "application/octet-stream";
const defaultExtension = "bin";
const mimeTypes = new Map([
    [
        "application/acad",
        "dwg"
    ],
    [
        "application/applixware",
        "aw"
    ],
    [
        "application/arj",
        "arj"
    ],
    [
        "application/atom+xml",
        "xml"
    ],
    [
        "application/atomcat+xml",
        "atomcat"
    ],
    [
        "application/atomsvc+xml",
        "atomsvc"
    ],
    [
        "application/base64",
        [
            "mm",
            "mme"
        ]
    ],
    [
        "application/binhex",
        "hqx"
    ],
    [
        "application/binhex4",
        "hqx"
    ],
    [
        "application/book",
        [
            "book",
            "boo"
        ]
    ],
    [
        "application/ccxml+xml,",
        "ccxml"
    ],
    [
        "application/cdf",
        "cdf"
    ],
    [
        "application/cdmi-capability",
        "cdmia"
    ],
    [
        "application/cdmi-container",
        "cdmic"
    ],
    [
        "application/cdmi-domain",
        "cdmid"
    ],
    [
        "application/cdmi-object",
        "cdmio"
    ],
    [
        "application/cdmi-queue",
        "cdmiq"
    ],
    [
        "application/clariscad",
        "ccad"
    ],
    [
        "application/commonground",
        "dp"
    ],
    [
        "application/cu-seeme",
        "cu"
    ],
    [
        "application/davmount+xml",
        "davmount"
    ],
    [
        "application/drafting",
        "drw"
    ],
    [
        "application/dsptype",
        "tsp"
    ],
    [
        "application/dssc+der",
        "dssc"
    ],
    [
        "application/dssc+xml",
        "xdssc"
    ],
    [
        "application/dxf",
        "dxf"
    ],
    [
        "application/ecmascript",
        [
            "js",
            "es"
        ]
    ],
    [
        "application/emma+xml",
        "emma"
    ],
    [
        "application/envoy",
        "evy"
    ],
    [
        "application/epub+zip",
        "epub"
    ],
    [
        "application/excel",
        [
            "xls",
            "xl",
            "xla",
            "xlb",
            "xlc",
            "xld",
            "xlk",
            "xll",
            "xlm",
            "xlt",
            "xlv",
            "xlw"
        ]
    ],
    [
        "application/exi",
        "exi"
    ],
    [
        "application/font-tdpfr",
        "pfr"
    ],
    [
        "application/fractals",
        "fif"
    ],
    [
        "application/freeloader",
        "frl"
    ],
    [
        "application/futuresplash",
        "spl"
    ],
    [
        "application/gnutar",
        "tgz"
    ],
    [
        "application/groupwise",
        "vew"
    ],
    [
        "application/hlp",
        "hlp"
    ],
    [
        "application/hta",
        "hta"
    ],
    [
        "application/hyperstudio",
        "stk"
    ],
    [
        "application/i-deas",
        "unv"
    ],
    [
        "application/iges",
        [
            "iges",
            "igs"
        ]
    ],
    [
        "application/inf",
        "inf"
    ],
    [
        "application/internet-property-stream",
        "acx"
    ],
    [
        "application/ipfix",
        "ipfix"
    ],
    [
        "application/java",
        "class"
    ],
    [
        "application/java-archive",
        "jar"
    ],
    [
        "application/java-byte-code",
        "class"
    ],
    [
        "application/java-serialized-object",
        "ser"
    ],
    [
        "application/java-vm",
        "class"
    ],
    [
        "application/javascript",
        "js"
    ],
    [
        "application/json",
        "json"
    ],
    [
        "application/lha",
        "lha"
    ],
    [
        "application/lzx",
        "lzx"
    ],
    [
        "application/mac-binary",
        "bin"
    ],
    [
        "application/mac-binhex",
        "hqx"
    ],
    [
        "application/mac-binhex40",
        "hqx"
    ],
    [
        "application/mac-compactpro",
        "cpt"
    ],
    [
        "application/macbinary",
        "bin"
    ],
    [
        "application/mads+xml",
        "mads"
    ],
    [
        "application/marc",
        "mrc"
    ],
    [
        "application/marcxml+xml",
        "mrcx"
    ],
    [
        "application/mathematica",
        "ma"
    ],
    [
        "application/mathml+xml",
        "mathml"
    ],
    [
        "application/mbedlet",
        "mbd"
    ],
    [
        "application/mbox",
        "mbox"
    ],
    [
        "application/mcad",
        "mcd"
    ],
    [
        "application/mediaservercontrol+xml",
        "mscml"
    ],
    [
        "application/metalink4+xml",
        "meta4"
    ],
    [
        "application/mets+xml",
        "mets"
    ],
    [
        "application/mime",
        "aps"
    ],
    [
        "application/mods+xml",
        "mods"
    ],
    [
        "application/mp21",
        "m21"
    ],
    [
        "application/mp4",
        "mp4"
    ],
    [
        "application/mspowerpoint",
        [
            "ppt",
            "pot",
            "pps",
            "ppz"
        ]
    ],
    [
        "application/msword",
        [
            "doc",
            "dot",
            "w6w",
            "wiz",
            "word"
        ]
    ],
    [
        "application/mswrite",
        "wri"
    ],
    [
        "application/mxf",
        "mxf"
    ],
    [
        "application/netmc",
        "mcp"
    ],
    [
        "application/octet-stream",
        [
            "*"
        ]
    ],
    [
        "application/oda",
        "oda"
    ],
    [
        "application/oebps-package+xml",
        "opf"
    ],
    [
        "application/ogg",
        "ogx"
    ],
    [
        "application/olescript",
        "axs"
    ],
    [
        "application/onenote",
        "onetoc"
    ],
    [
        "application/patch-ops-error+xml",
        "xer"
    ],
    [
        "application/pdf",
        "pdf"
    ],
    [
        "application/pgp-encrypted",
        "asc"
    ],
    [
        "application/pgp-signature",
        "pgp"
    ],
    [
        "application/pics-rules",
        "prf"
    ],
    [
        "application/pkcs-12",
        "p12"
    ],
    [
        "application/pkcs-crl",
        "crl"
    ],
    [
        "application/pkcs10",
        "p10"
    ],
    [
        "application/pkcs7-mime",
        [
            "p7c",
            "p7m"
        ]
    ],
    [
        "application/pkcs7-signature",
        "p7s"
    ],
    [
        "application/pkcs8",
        "p8"
    ],
    [
        "application/pkix-attr-cert",
        "ac"
    ],
    [
        "application/pkix-cert",
        [
            "cer",
            "crt"
        ]
    ],
    [
        "application/pkix-crl",
        "crl"
    ],
    [
        "application/pkix-pkipath",
        "pkipath"
    ],
    [
        "application/pkixcmp",
        "pki"
    ],
    [
        "application/plain",
        "text"
    ],
    [
        "application/pls+xml",
        "pls"
    ],
    [
        "application/postscript",
        [
            "ps",
            "ai",
            "eps"
        ]
    ],
    [
        "application/powerpoint",
        "ppt"
    ],
    [
        "application/pro_eng",
        [
            "part",
            "prt"
        ]
    ],
    [
        "application/prs.cww",
        "cww"
    ],
    [
        "application/pskc+xml",
        "pskcxml"
    ],
    [
        "application/rdf+xml",
        "rdf"
    ],
    [
        "application/reginfo+xml",
        "rif"
    ],
    [
        "application/relax-ng-compact-syntax",
        "rnc"
    ],
    [
        "application/resource-lists+xml",
        "rl"
    ],
    [
        "application/resource-lists-diff+xml",
        "rld"
    ],
    [
        "application/ringing-tones",
        "rng"
    ],
    [
        "application/rls-services+xml",
        "rs"
    ],
    [
        "application/rsd+xml",
        "rsd"
    ],
    [
        "application/rss+xml",
        "xml"
    ],
    [
        "application/rtf",
        [
            "rtf",
            "rtx"
        ]
    ],
    [
        "application/sbml+xml",
        "sbml"
    ],
    [
        "application/scvp-cv-request",
        "scq"
    ],
    [
        "application/scvp-cv-response",
        "scs"
    ],
    [
        "application/scvp-vp-request",
        "spq"
    ],
    [
        "application/scvp-vp-response",
        "spp"
    ],
    [
        "application/sdp",
        "sdp"
    ],
    [
        "application/sea",
        "sea"
    ],
    [
        "application/set",
        "set"
    ],
    [
        "application/set-payment-initiation",
        "setpay"
    ],
    [
        "application/set-registration-initiation",
        "setreg"
    ],
    [
        "application/shf+xml",
        "shf"
    ],
    [
        "application/sla",
        "stl"
    ],
    [
        "application/smil",
        [
            "smi",
            "smil"
        ]
    ],
    [
        "application/smil+xml",
        "smi"
    ],
    [
        "application/solids",
        "sol"
    ],
    [
        "application/sounder",
        "sdr"
    ],
    [
        "application/sparql-query",
        "rq"
    ],
    [
        "application/sparql-results+xml",
        "srx"
    ],
    [
        "application/srgs",
        "gram"
    ],
    [
        "application/srgs+xml",
        "grxml"
    ],
    [
        "application/sru+xml",
        "sru"
    ],
    [
        "application/ssml+xml",
        "ssml"
    ],
    [
        "application/step",
        [
            "step",
            "stp"
        ]
    ],
    [
        "application/streamingmedia",
        "ssm"
    ],
    [
        "application/tei+xml",
        "tei"
    ],
    [
        "application/thraud+xml",
        "tfi"
    ],
    [
        "application/timestamped-data",
        "tsd"
    ],
    [
        "application/toolbook",
        "tbk"
    ],
    [
        "application/vda",
        "vda"
    ],
    [
        "application/vnd.3gpp.pic-bw-large",
        "plb"
    ],
    [
        "application/vnd.3gpp.pic-bw-small",
        "psb"
    ],
    [
        "application/vnd.3gpp.pic-bw-var",
        "pvb"
    ],
    [
        "application/vnd.3gpp2.tcap",
        "tcap"
    ],
    [
        "application/vnd.3m.post-it-notes",
        "pwn"
    ],
    [
        "application/vnd.accpac.simply.aso",
        "aso"
    ],
    [
        "application/vnd.accpac.simply.imp",
        "imp"
    ],
    [
        "application/vnd.acucobol",
        "acu"
    ],
    [
        "application/vnd.acucorp",
        "atc"
    ],
    [
        "application/vnd.adobe.air-application-installer-package+zip",
        "air"
    ],
    [
        "application/vnd.adobe.fxp",
        "fxp"
    ],
    [
        "application/vnd.adobe.xdp+xml",
        "xdp"
    ],
    [
        "application/vnd.adobe.xfdf",
        "xfdf"
    ],
    [
        "application/vnd.ahead.space",
        "ahead"
    ],
    [
        "application/vnd.airzip.filesecure.azf",
        "azf"
    ],
    [
        "application/vnd.airzip.filesecure.azs",
        "azs"
    ],
    [
        "application/vnd.amazon.ebook",
        "azw"
    ],
    [
        "application/vnd.americandynamics.acc",
        "acc"
    ],
    [
        "application/vnd.amiga.ami",
        "ami"
    ],
    [
        "application/vnd.android.package-archive",
        "apk"
    ],
    [
        "application/vnd.anser-web-certificate-issue-initiation",
        "cii"
    ],
    [
        "application/vnd.anser-web-funds-transfer-initiation",
        "fti"
    ],
    [
        "application/vnd.antix.game-component",
        "atx"
    ],
    [
        "application/vnd.apple.installer+xml",
        "mpkg"
    ],
    [
        "application/vnd.apple.mpegurl",
        "m3u8"
    ],
    [
        "application/vnd.aristanetworks.swi",
        "swi"
    ],
    [
        "application/vnd.audiograph",
        "aep"
    ],
    [
        "application/vnd.blueice.multipass",
        "mpm"
    ],
    [
        "application/vnd.bmi",
        "bmi"
    ],
    [
        "application/vnd.businessobjects",
        "rep"
    ],
    [
        "application/vnd.chemdraw+xml",
        "cdxml"
    ],
    [
        "application/vnd.chipnuts.karaoke-mmd",
        "mmd"
    ],
    [
        "application/vnd.cinderella",
        "cdy"
    ],
    [
        "application/vnd.claymore",
        "cla"
    ],
    [
        "application/vnd.cloanto.rp9",
        "rp9"
    ],
    [
        "application/vnd.clonk.c4group",
        "c4g"
    ],
    [
        "application/vnd.cluetrust.cartomobile-config",
        "c11amc"
    ],
    [
        "application/vnd.cluetrust.cartomobile-config-pkg",
        "c11amz"
    ],
    [
        "application/vnd.commonspace",
        "csp"
    ],
    [
        "application/vnd.contact.cmsg",
        "cdbcmsg"
    ],
    [
        "application/vnd.cosmocaller",
        "cmc"
    ],
    [
        "application/vnd.crick.clicker",
        "clkx"
    ],
    [
        "application/vnd.crick.clicker.keyboard",
        "clkk"
    ],
    [
        "application/vnd.crick.clicker.palette",
        "clkp"
    ],
    [
        "application/vnd.crick.clicker.template",
        "clkt"
    ],
    [
        "application/vnd.crick.clicker.wordbank",
        "clkw"
    ],
    [
        "application/vnd.criticaltools.wbs+xml",
        "wbs"
    ],
    [
        "application/vnd.ctc-posml",
        "pml"
    ],
    [
        "application/vnd.cups-ppd",
        "ppd"
    ],
    [
        "application/vnd.curl.car",
        "car"
    ],
    [
        "application/vnd.curl.pcurl",
        "pcurl"
    ],
    [
        "application/vnd.data-vision.rdz",
        "rdz"
    ],
    [
        "application/vnd.denovo.fcselayout-link",
        "fe_launch"
    ],
    [
        "application/vnd.dna",
        "dna"
    ],
    [
        "application/vnd.dolby.mlp",
        "mlp"
    ],
    [
        "application/vnd.dpgraph",
        "dpg"
    ],
    [
        "application/vnd.dreamfactory",
        "dfac"
    ],
    [
        "application/vnd.dvb.ait",
        "ait"
    ],
    [
        "application/vnd.dvb.service",
        "svc"
    ],
    [
        "application/vnd.dynageo",
        "geo"
    ],
    [
        "application/vnd.ecowin.chart",
        "mag"
    ],
    [
        "application/vnd.enliven",
        "nml"
    ],
    [
        "application/vnd.epson.esf",
        "esf"
    ],
    [
        "application/vnd.epson.msf",
        "msf"
    ],
    [
        "application/vnd.epson.quickanime",
        "qam"
    ],
    [
        "application/vnd.epson.salt",
        "slt"
    ],
    [
        "application/vnd.epson.ssf",
        "ssf"
    ],
    [
        "application/vnd.eszigno3+xml",
        "es3"
    ],
    [
        "application/vnd.ezpix-album",
        "ez2"
    ],
    [
        "application/vnd.ezpix-package",
        "ez3"
    ],
    [
        "application/vnd.fdf",
        "fdf"
    ],
    [
        "application/vnd.fdsn.seed",
        "seed"
    ],
    [
        "application/vnd.flographit",
        "gph"
    ],
    [
        "application/vnd.fluxtime.clip",
        "ftc"
    ],
    [
        "application/vnd.framemaker",
        "fm"
    ],
    [
        "application/vnd.frogans.fnc",
        "fnc"
    ],
    [
        "application/vnd.frogans.ltf",
        "ltf"
    ],
    [
        "application/vnd.fsc.weblaunch",
        "fsc"
    ],
    [
        "application/vnd.fujitsu.oasys",
        "oas"
    ],
    [
        "application/vnd.fujitsu.oasys2",
        "oa2"
    ],
    [
        "application/vnd.fujitsu.oasys3",
        "oa3"
    ],
    [
        "application/vnd.fujitsu.oasysgp",
        "fg5"
    ],
    [
        "application/vnd.fujitsu.oasysprs",
        "bh2"
    ],
    [
        "application/vnd.fujixerox.ddd",
        "ddd"
    ],
    [
        "application/vnd.fujixerox.docuworks",
        "xdw"
    ],
    [
        "application/vnd.fujixerox.docuworks.binder",
        "xbd"
    ],
    [
        "application/vnd.fuzzysheet",
        "fzs"
    ],
    [
        "application/vnd.genomatix.tuxedo",
        "txd"
    ],
    [
        "application/vnd.geogebra.file",
        "ggb"
    ],
    [
        "application/vnd.geogebra.tool",
        "ggt"
    ],
    [
        "application/vnd.geometry-explorer",
        "gex"
    ],
    [
        "application/vnd.geonext",
        "gxt"
    ],
    [
        "application/vnd.geoplan",
        "g2w"
    ],
    [
        "application/vnd.geospace",
        "g3w"
    ],
    [
        "application/vnd.gmx",
        "gmx"
    ],
    [
        "application/vnd.google-earth.kml+xml",
        "kml"
    ],
    [
        "application/vnd.google-earth.kmz",
        "kmz"
    ],
    [
        "application/vnd.grafeq",
        "gqf"
    ],
    [
        "application/vnd.groove-account",
        "gac"
    ],
    [
        "application/vnd.groove-help",
        "ghf"
    ],
    [
        "application/vnd.groove-identity-message",
        "gim"
    ],
    [
        "application/vnd.groove-injector",
        "grv"
    ],
    [
        "application/vnd.groove-tool-message",
        "gtm"
    ],
    [
        "application/vnd.groove-tool-template",
        "tpl"
    ],
    [
        "application/vnd.groove-vcard",
        "vcg"
    ],
    [
        "application/vnd.hal+xml",
        "hal"
    ],
    [
        "application/vnd.handheld-entertainment+xml",
        "zmm"
    ],
    [
        "application/vnd.hbci",
        "hbci"
    ],
    [
        "application/vnd.hhe.lesson-player",
        "les"
    ],
    [
        "application/vnd.hp-hpgl",
        [
            "hgl",
            "hpg",
            "hpgl"
        ]
    ],
    [
        "application/vnd.hp-hpid",
        "hpid"
    ],
    [
        "application/vnd.hp-hps",
        "hps"
    ],
    [
        "application/vnd.hp-jlyt",
        "jlt"
    ],
    [
        "application/vnd.hp-pcl",
        "pcl"
    ],
    [
        "application/vnd.hp-pclxl",
        "pclxl"
    ],
    [
        "application/vnd.hydrostatix.sof-data",
        "sfd-hdstx"
    ],
    [
        "application/vnd.hzn-3d-crossword",
        "x3d"
    ],
    [
        "application/vnd.ibm.minipay",
        "mpy"
    ],
    [
        "application/vnd.ibm.modcap",
        "afp"
    ],
    [
        "application/vnd.ibm.rights-management",
        "irm"
    ],
    [
        "application/vnd.ibm.secure-container",
        "sc"
    ],
    [
        "application/vnd.iccprofile",
        "icc"
    ],
    [
        "application/vnd.igloader",
        "igl"
    ],
    [
        "application/vnd.immervision-ivp",
        "ivp"
    ],
    [
        "application/vnd.immervision-ivu",
        "ivu"
    ],
    [
        "application/vnd.insors.igm",
        "igm"
    ],
    [
        "application/vnd.intercon.formnet",
        "xpw"
    ],
    [
        "application/vnd.intergeo",
        "i2g"
    ],
    [
        "application/vnd.intu.qbo",
        "qbo"
    ],
    [
        "application/vnd.intu.qfx",
        "qfx"
    ],
    [
        "application/vnd.ipunplugged.rcprofile",
        "rcprofile"
    ],
    [
        "application/vnd.irepository.package+xml",
        "irp"
    ],
    [
        "application/vnd.is-xpr",
        "xpr"
    ],
    [
        "application/vnd.isac.fcs",
        "fcs"
    ],
    [
        "application/vnd.jam",
        "jam"
    ],
    [
        "application/vnd.jcp.javame.midlet-rms",
        "rms"
    ],
    [
        "application/vnd.jisp",
        "jisp"
    ],
    [
        "application/vnd.joost.joda-archive",
        "joda"
    ],
    [
        "application/vnd.kahootz",
        "ktz"
    ],
    [
        "application/vnd.kde.karbon",
        "karbon"
    ],
    [
        "application/vnd.kde.kchart",
        "chrt"
    ],
    [
        "application/vnd.kde.kformula",
        "kfo"
    ],
    [
        "application/vnd.kde.kivio",
        "flw"
    ],
    [
        "application/vnd.kde.kontour",
        "kon"
    ],
    [
        "application/vnd.kde.kpresenter",
        "kpr"
    ],
    [
        "application/vnd.kde.kspread",
        "ksp"
    ],
    [
        "application/vnd.kde.kword",
        "kwd"
    ],
    [
        "application/vnd.kenameaapp",
        "htke"
    ],
    [
        "application/vnd.kidspiration",
        "kia"
    ],
    [
        "application/vnd.kinar",
        "kne"
    ],
    [
        "application/vnd.koan",
        "skp"
    ],
    [
        "application/vnd.kodak-descriptor",
        "sse"
    ],
    [
        "application/vnd.las.las+xml",
        "lasxml"
    ],
    [
        "application/vnd.llamagraphics.life-balance.desktop",
        "lbd"
    ],
    [
        "application/vnd.llamagraphics.life-balance.exchange+xml",
        "lbe"
    ],
    [
        "application/vnd.lotus-1-2-3",
        "123"
    ],
    [
        "application/vnd.lotus-approach",
        "apr"
    ],
    [
        "application/vnd.lotus-freelance",
        "pre"
    ],
    [
        "application/vnd.lotus-notes",
        "nsf"
    ],
    [
        "application/vnd.lotus-organizer",
        "org"
    ],
    [
        "application/vnd.lotus-screencam",
        "scm"
    ],
    [
        "application/vnd.lotus-wordpro",
        "lwp"
    ],
    [
        "application/vnd.macports.portpkg",
        "portpkg"
    ],
    [
        "application/vnd.mcd",
        "mcd"
    ],
    [
        "application/vnd.medcalcdata",
        "mc1"
    ],
    [
        "application/vnd.mediastation.cdkey",
        "cdkey"
    ],
    [
        "application/vnd.mfer",
        "mwf"
    ],
    [
        "application/vnd.mfmp",
        "mfm"
    ],
    [
        "application/vnd.micrografx.flo",
        "flo"
    ],
    [
        "application/vnd.micrografx.igx",
        "igx"
    ],
    [
        "application/vnd.mif",
        "mif"
    ],
    [
        "application/vnd.mobius.daf",
        "daf"
    ],
    [
        "application/vnd.mobius.dis",
        "dis"
    ],
    [
        "application/vnd.mobius.mbk",
        "mbk"
    ],
    [
        "application/vnd.mobius.mqy",
        "mqy"
    ],
    [
        "application/vnd.mobius.msl",
        "msl"
    ],
    [
        "application/vnd.mobius.plc",
        "plc"
    ],
    [
        "application/vnd.mobius.txf",
        "txf"
    ],
    [
        "application/vnd.mophun.application",
        "mpn"
    ],
    [
        "application/vnd.mophun.certificate",
        "mpc"
    ],
    [
        "application/vnd.mozilla.xul+xml",
        "xul"
    ],
    [
        "application/vnd.ms-artgalry",
        "cil"
    ],
    [
        "application/vnd.ms-cab-compressed",
        "cab"
    ],
    [
        "application/vnd.ms-excel",
        [
            "xls",
            "xla",
            "xlc",
            "xlm",
            "xlt",
            "xlw",
            "xlb",
            "xll"
        ]
    ],
    [
        "application/vnd.ms-excel.addin.macroenabled.12",
        "xlam"
    ],
    [
        "application/vnd.ms-excel.sheet.binary.macroenabled.12",
        "xlsb"
    ],
    [
        "application/vnd.ms-excel.sheet.macroenabled.12",
        "xlsm"
    ],
    [
        "application/vnd.ms-excel.template.macroenabled.12",
        "xltm"
    ],
    [
        "application/vnd.ms-fontobject",
        "eot"
    ],
    [
        "application/vnd.ms-htmlhelp",
        "chm"
    ],
    [
        "application/vnd.ms-ims",
        "ims"
    ],
    [
        "application/vnd.ms-lrm",
        "lrm"
    ],
    [
        "application/vnd.ms-officetheme",
        "thmx"
    ],
    [
        "application/vnd.ms-outlook",
        "msg"
    ],
    [
        "application/vnd.ms-pki.certstore",
        "sst"
    ],
    [
        "application/vnd.ms-pki.pko",
        "pko"
    ],
    [
        "application/vnd.ms-pki.seccat",
        "cat"
    ],
    [
        "application/vnd.ms-pki.stl",
        "stl"
    ],
    [
        "application/vnd.ms-pkicertstore",
        "sst"
    ],
    [
        "application/vnd.ms-pkiseccat",
        "cat"
    ],
    [
        "application/vnd.ms-pkistl",
        "stl"
    ],
    [
        "application/vnd.ms-powerpoint",
        [
            "ppt",
            "pot",
            "pps",
            "ppa",
            "pwz"
        ]
    ],
    [
        "application/vnd.ms-powerpoint.addin.macroenabled.12",
        "ppam"
    ],
    [
        "application/vnd.ms-powerpoint.presentation.macroenabled.12",
        "pptm"
    ],
    [
        "application/vnd.ms-powerpoint.slide.macroenabled.12",
        "sldm"
    ],
    [
        "application/vnd.ms-powerpoint.slideshow.macroenabled.12",
        "ppsm"
    ],
    [
        "application/vnd.ms-powerpoint.template.macroenabled.12",
        "potm"
    ],
    [
        "application/vnd.ms-project",
        "mpp"
    ],
    [
        "application/vnd.ms-word.document.macroenabled.12",
        "docm"
    ],
    [
        "application/vnd.ms-word.template.macroenabled.12",
        "dotm"
    ],
    [
        "application/vnd.ms-works",
        [
            "wks",
            "wcm",
            "wdb",
            "wps"
        ]
    ],
    [
        "application/vnd.ms-wpl",
        "wpl"
    ],
    [
        "application/vnd.ms-xpsdocument",
        "xps"
    ],
    [
        "application/vnd.mseq",
        "mseq"
    ],
    [
        "application/vnd.musician",
        "mus"
    ],
    [
        "application/vnd.muvee.style",
        "msty"
    ],
    [
        "application/vnd.neurolanguage.nlu",
        "nlu"
    ],
    [
        "application/vnd.noblenet-directory",
        "nnd"
    ],
    [
        "application/vnd.noblenet-sealer",
        "nns"
    ],
    [
        "application/vnd.noblenet-web",
        "nnw"
    ],
    [
        "application/vnd.nokia.configuration-message",
        "ncm"
    ],
    [
        "application/vnd.nokia.n-gage.data",
        "ngdat"
    ],
    [
        "application/vnd.nokia.n-gage.symbian.install",
        "n-gage"
    ],
    [
        "application/vnd.nokia.radio-preset",
        "rpst"
    ],
    [
        "application/vnd.nokia.radio-presets",
        "rpss"
    ],
    [
        "application/vnd.nokia.ringing-tone",
        "rng"
    ],
    [
        "application/vnd.novadigm.edm",
        "edm"
    ],
    [
        "application/vnd.novadigm.edx",
        "edx"
    ],
    [
        "application/vnd.novadigm.ext",
        "ext"
    ],
    [
        "application/vnd.oasis.opendocument.chart",
        "odc"
    ],
    [
        "application/vnd.oasis.opendocument.chart-template",
        "otc"
    ],
    [
        "application/vnd.oasis.opendocument.database",
        "odb"
    ],
    [
        "application/vnd.oasis.opendocument.formula",
        "odf"
    ],
    [
        "application/vnd.oasis.opendocument.formula-template",
        "odft"
    ],
    [
        "application/vnd.oasis.opendocument.graphics",
        "odg"
    ],
    [
        "application/vnd.oasis.opendocument.graphics-template",
        "otg"
    ],
    [
        "application/vnd.oasis.opendocument.image",
        "odi"
    ],
    [
        "application/vnd.oasis.opendocument.image-template",
        "oti"
    ],
    [
        "application/vnd.oasis.opendocument.presentation",
        "odp"
    ],
    [
        "application/vnd.oasis.opendocument.presentation-template",
        "otp"
    ],
    [
        "application/vnd.oasis.opendocument.spreadsheet",
        "ods"
    ],
    [
        "application/vnd.oasis.opendocument.spreadsheet-template",
        "ots"
    ],
    [
        "application/vnd.oasis.opendocument.text",
        "odt"
    ],
    [
        "application/vnd.oasis.opendocument.text-master",
        "odm"
    ],
    [
        "application/vnd.oasis.opendocument.text-template",
        "ott"
    ],
    [
        "application/vnd.oasis.opendocument.text-web",
        "oth"
    ],
    [
        "application/vnd.olpc-sugar",
        "xo"
    ],
    [
        "application/vnd.oma.dd2+xml",
        "dd2"
    ],
    [
        "application/vnd.openofficeorg.extension",
        "oxt"
    ],
    [
        "application/vnd.openxmlformats-officedocument.presentationml.presentation",
        "pptx"
    ],
    [
        "application/vnd.openxmlformats-officedocument.presentationml.slide",
        "sldx"
    ],
    [
        "application/vnd.openxmlformats-officedocument.presentationml.slideshow",
        "ppsx"
    ],
    [
        "application/vnd.openxmlformats-officedocument.presentationml.template",
        "potx"
    ],
    [
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        "xlsx"
    ],
    [
        "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
        "xltx"
    ],
    [
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        "docx"
    ],
    [
        "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
        "dotx"
    ],
    [
        "application/vnd.osgeo.mapguide.package",
        "mgp"
    ],
    [
        "application/vnd.osgi.dp",
        "dp"
    ],
    [
        "application/vnd.palm",
        "pdb"
    ],
    [
        "application/vnd.pawaafile",
        "paw"
    ],
    [
        "application/vnd.pg.format",
        "str"
    ],
    [
        "application/vnd.pg.osasli",
        "ei6"
    ],
    [
        "application/vnd.picsel",
        "efif"
    ],
    [
        "application/vnd.pmi.widget",
        "wg"
    ],
    [
        "application/vnd.pocketlearn",
        "plf"
    ],
    [
        "application/vnd.powerbuilder6",
        "pbd"
    ],
    [
        "application/vnd.previewsystems.box",
        "box"
    ],
    [
        "application/vnd.proteus.magazine",
        "mgz"
    ],
    [
        "application/vnd.publishare-delta-tree",
        "qps"
    ],
    [
        "application/vnd.pvi.ptid1",
        "ptid"
    ],
    [
        "application/vnd.quark.quarkxpress",
        "qxd"
    ],
    [
        "application/vnd.realvnc.bed",
        "bed"
    ],
    [
        "application/vnd.recordare.musicxml",
        "mxl"
    ],
    [
        "application/vnd.recordare.musicxml+xml",
        "musicxml"
    ],
    [
        "application/vnd.rig.cryptonote",
        "cryptonote"
    ],
    [
        "application/vnd.rim.cod",
        "cod"
    ],
    [
        "application/vnd.rn-realmedia",
        "rm"
    ],
    [
        "application/vnd.rn-realplayer",
        "rnx"
    ],
    [
        "application/vnd.route66.link66+xml",
        "link66"
    ],
    [
        "application/vnd.sailingtracker.track",
        "st"
    ],
    [
        "application/vnd.seemail",
        "see"
    ],
    [
        "application/vnd.sema",
        "sema"
    ],
    [
        "application/vnd.semd",
        "semd"
    ],
    [
        "application/vnd.semf",
        "semf"
    ],
    [
        "application/vnd.shana.informed.formdata",
        "ifm"
    ],
    [
        "application/vnd.shana.informed.formtemplate",
        "itp"
    ],
    [
        "application/vnd.shana.informed.interchange",
        "iif"
    ],
    [
        "application/vnd.shana.informed.package",
        "ipk"
    ],
    [
        "application/vnd.simtech-mindmapper",
        "twd"
    ],
    [
        "application/vnd.smaf",
        "mmf"
    ],
    [
        "application/vnd.smart.teacher",
        "teacher"
    ],
    [
        "application/vnd.solent.sdkm+xml",
        "sdkm"
    ],
    [
        "application/vnd.spotfire.dxp",
        "dxp"
    ],
    [
        "application/vnd.spotfire.sfs",
        "sfs"
    ],
    [
        "application/vnd.stardivision.calc",
        "sdc"
    ],
    [
        "application/vnd.stardivision.draw",
        "sda"
    ],
    [
        "application/vnd.stardivision.impress",
        "sdd"
    ],
    [
        "application/vnd.stardivision.math",
        "smf"
    ],
    [
        "application/vnd.stardivision.writer",
        "sdw"
    ],
    [
        "application/vnd.stardivision.writer-global",
        "sgl"
    ],
    [
        "application/vnd.stepmania.stepchart",
        "sm"
    ],
    [
        "application/vnd.sun.xml.calc",
        "sxc"
    ],
    [
        "application/vnd.sun.xml.calc.template",
        "stc"
    ],
    [
        "application/vnd.sun.xml.draw",
        "sxd"
    ],
    [
        "application/vnd.sun.xml.draw.template",
        "std"
    ],
    [
        "application/vnd.sun.xml.impress",
        "sxi"
    ],
    [
        "application/vnd.sun.xml.impress.template",
        "sti"
    ],
    [
        "application/vnd.sun.xml.math",
        "sxm"
    ],
    [
        "application/vnd.sun.xml.writer",
        "sxw"
    ],
    [
        "application/vnd.sun.xml.writer.global",
        "sxg"
    ],
    [
        "application/vnd.sun.xml.writer.template",
        "stw"
    ],
    [
        "application/vnd.sus-calendar",
        "sus"
    ],
    [
        "application/vnd.svd",
        "svd"
    ],
    [
        "application/vnd.symbian.install",
        "sis"
    ],
    [
        "application/vnd.syncml+xml",
        "xsm"
    ],
    [
        "application/vnd.syncml.dm+wbxml",
        "bdm"
    ],
    [
        "application/vnd.syncml.dm+xml",
        "xdm"
    ],
    [
        "application/vnd.tao.intent-module-archive",
        "tao"
    ],
    [
        "application/vnd.tmobile-livetv",
        "tmo"
    ],
    [
        "application/vnd.trid.tpt",
        "tpt"
    ],
    [
        "application/vnd.triscape.mxs",
        "mxs"
    ],
    [
        "application/vnd.trueapp",
        "tra"
    ],
    [
        "application/vnd.ufdl",
        "ufd"
    ],
    [
        "application/vnd.uiq.theme",
        "utz"
    ],
    [
        "application/vnd.umajin",
        "umj"
    ],
    [
        "application/vnd.unity",
        "unityweb"
    ],
    [
        "application/vnd.uoml+xml",
        "uoml"
    ],
    [
        "application/vnd.vcx",
        "vcx"
    ],
    [
        "application/vnd.visio",
        "vsd"
    ],
    [
        "application/vnd.visionary",
        "vis"
    ],
    [
        "application/vnd.vsf",
        "vsf"
    ],
    [
        "application/vnd.wap.wbxml",
        "wbxml"
    ],
    [
        "application/vnd.wap.wmlc",
        "wmlc"
    ],
    [
        "application/vnd.wap.wmlscriptc",
        "wmlsc"
    ],
    [
        "application/vnd.webturbo",
        "wtb"
    ],
    [
        "application/vnd.wolfram.player",
        "nbp"
    ],
    [
        "application/vnd.wordperfect",
        "wpd"
    ],
    [
        "application/vnd.wqd",
        "wqd"
    ],
    [
        "application/vnd.wt.stf",
        "stf"
    ],
    [
        "application/vnd.xara",
        [
            "web",
            "xar"
        ]
    ],
    [
        "application/vnd.xfdl",
        "xfdl"
    ],
    [
        "application/vnd.yamaha.hv-dic",
        "hvd"
    ],
    [
        "application/vnd.yamaha.hv-script",
        "hvs"
    ],
    [
        "application/vnd.yamaha.hv-voice",
        "hvp"
    ],
    [
        "application/vnd.yamaha.openscoreformat",
        "osf"
    ],
    [
        "application/vnd.yamaha.openscoreformat.osfpvg+xml",
        "osfpvg"
    ],
    [
        "application/vnd.yamaha.smaf-audio",
        "saf"
    ],
    [
        "application/vnd.yamaha.smaf-phrase",
        "spf"
    ],
    [
        "application/vnd.yellowriver-custom-menu",
        "cmp"
    ],
    [
        "application/vnd.zul",
        "zir"
    ],
    [
        "application/vnd.zzazz.deck+xml",
        "zaz"
    ],
    [
        "application/vocaltec-media-desc",
        "vmd"
    ],
    [
        "application/vocaltec-media-file",
        "vmf"
    ],
    [
        "application/voicexml+xml",
        "vxml"
    ],
    [
        "application/widget",
        "wgt"
    ],
    [
        "application/winhlp",
        "hlp"
    ],
    [
        "application/wordperfect",
        [
            "wp",
            "wp5",
            "wp6",
            "wpd"
        ]
    ],
    [
        "application/wordperfect6.0",
        [
            "w60",
            "wp5"
        ]
    ],
    [
        "application/wordperfect6.1",
        "w61"
    ],
    [
        "application/wsdl+xml",
        "wsdl"
    ],
    [
        "application/wspolicy+xml",
        "wspolicy"
    ],
    [
        "application/x-123",
        "wk1"
    ],
    [
        "application/x-7z-compressed",
        "7z"
    ],
    [
        "application/x-abiword",
        "abw"
    ],
    [
        "application/x-ace-compressed",
        "ace"
    ],
    [
        "application/x-aim",
        "aim"
    ],
    [
        "application/x-authorware-bin",
        "aab"
    ],
    [
        "application/x-authorware-map",
        "aam"
    ],
    [
        "application/x-authorware-seg",
        "aas"
    ],
    [
        "application/x-bcpio",
        "bcpio"
    ],
    [
        "application/x-binary",
        "bin"
    ],
    [
        "application/x-binhex40",
        "hqx"
    ],
    [
        "application/x-bittorrent",
        "torrent"
    ],
    [
        "application/x-bsh",
        [
            "bsh",
            "sh",
            "shar"
        ]
    ],
    [
        "application/x-bytecode.elisp",
        "elc"
    ],
    [
        "application/x-bytecode.python",
        "pyc"
    ],
    [
        "application/x-bzip",
        "bz"
    ],
    [
        "application/x-bzip2",
        [
            "boz",
            "bz2"
        ]
    ],
    [
        "application/x-cdf",
        "cdf"
    ],
    [
        "application/x-cdlink",
        "vcd"
    ],
    [
        "application/x-chat",
        [
            "cha",
            "chat"
        ]
    ],
    [
        "application/x-chess-pgn",
        "pgn"
    ],
    [
        "application/x-cmu-raster",
        "ras"
    ],
    [
        "application/x-cocoa",
        "cco"
    ],
    [
        "application/x-compactpro",
        "cpt"
    ],
    [
        "application/x-compress",
        "z"
    ],
    [
        "application/x-compressed",
        [
            "tgz",
            "gz",
            "z",
            "zip"
        ]
    ],
    [
        "application/x-conference",
        "nsc"
    ],
    [
        "application/x-cpio",
        "cpio"
    ],
    [
        "application/x-cpt",
        "cpt"
    ],
    [
        "application/x-csh",
        "csh"
    ],
    [
        "application/x-debian-package",
        "deb"
    ],
    [
        "application/x-deepv",
        "deepv"
    ],
    [
        "application/x-director",
        [
            "dir",
            "dcr",
            "dxr"
        ]
    ],
    [
        "application/x-doom",
        "wad"
    ],
    [
        "application/x-dtbncx+xml",
        "ncx"
    ],
    [
        "application/x-dtbook+xml",
        "dtb"
    ],
    [
        "application/x-dtbresource+xml",
        "res"
    ],
    [
        "application/x-dvi",
        "dvi"
    ],
    [
        "application/x-elc",
        "elc"
    ],
    [
        "application/x-envoy",
        [
            "env",
            "evy"
        ]
    ],
    [
        "application/x-esrehber",
        "es"
    ],
    [
        "application/x-excel",
        [
            "xls",
            "xla",
            "xlb",
            "xlc",
            "xld",
            "xlk",
            "xll",
            "xlm",
            "xlt",
            "xlv",
            "xlw"
        ]
    ],
    [
        "application/x-font-bdf",
        "bdf"
    ],
    [
        "application/x-font-ghostscript",
        "gsf"
    ],
    [
        "application/x-font-linux-psf",
        "psf"
    ],
    [
        "application/x-font-otf",
        "otf"
    ],
    [
        "application/x-font-pcf",
        "pcf"
    ],
    [
        "application/x-font-snf",
        "snf"
    ],
    [
        "application/x-font-ttf",
        "ttf"
    ],
    [
        "application/x-font-type1",
        "pfa"
    ],
    [
        "application/x-font-woff",
        "woff"
    ],
    [
        "application/x-frame",
        "mif"
    ],
    [
        "application/x-freelance",
        "pre"
    ],
    [
        "application/x-futuresplash",
        "spl"
    ],
    [
        "application/x-gnumeric",
        "gnumeric"
    ],
    [
        "application/x-gsp",
        "gsp"
    ],
    [
        "application/x-gss",
        "gss"
    ],
    [
        "application/x-gtar",
        "gtar"
    ],
    [
        "application/x-gzip",
        [
            "gz",
            "gzip"
        ]
    ],
    [
        "application/x-hdf",
        "hdf"
    ],
    [
        "application/x-helpfile",
        [
            "help",
            "hlp"
        ]
    ],
    [
        "application/x-httpd-imap",
        "imap"
    ],
    [
        "application/x-ima",
        "ima"
    ],
    [
        "application/x-internet-signup",
        [
            "ins",
            "isp"
        ]
    ],
    [
        "application/x-internett-signup",
        "ins"
    ],
    [
        "application/x-inventor",
        "iv"
    ],
    [
        "application/x-ip2",
        "ip"
    ],
    [
        "application/x-iphone",
        "iii"
    ],
    [
        "application/x-java-class",
        "class"
    ],
    [
        "application/x-java-commerce",
        "jcm"
    ],
    [
        "application/x-java-jnlp-file",
        "jnlp"
    ],
    [
        "application/x-javascript",
        "js"
    ],
    [
        "application/x-koan",
        [
            "skd",
            "skm",
            "skp",
            "skt"
        ]
    ],
    [
        "application/x-ksh",
        "ksh"
    ],
    [
        "application/x-latex",
        [
            "latex",
            "ltx"
        ]
    ],
    [
        "application/x-lha",
        "lha"
    ],
    [
        "application/x-lisp",
        "lsp"
    ],
    [
        "application/x-livescreen",
        "ivy"
    ],
    [
        "application/x-lotus",
        "wq1"
    ],
    [
        "application/x-lotusscreencam",
        "scm"
    ],
    [
        "application/x-lzh",
        "lzh"
    ],
    [
        "application/x-lzx",
        "lzx"
    ],
    [
        "application/x-mac-binhex40",
        "hqx"
    ],
    [
        "application/x-macbinary",
        "bin"
    ],
    [
        "application/x-magic-cap-package-1.0",
        "mc$"
    ],
    [
        "application/x-mathcad",
        "mcd"
    ],
    [
        "application/x-meme",
        "mm"
    ],
    [
        "application/x-midi",
        [
            "mid",
            "midi"
        ]
    ],
    [
        "application/x-mif",
        "mif"
    ],
    [
        "application/x-mix-transfer",
        "nix"
    ],
    [
        "application/x-mobipocket-ebook",
        "prc"
    ],
    [
        "application/x-mplayer2",
        "asx"
    ],
    [
        "application/x-ms-application",
        "application"
    ],
    [
        "application/x-ms-wmd",
        "wmd"
    ],
    [
        "application/x-ms-wmz",
        "wmz"
    ],
    [
        "application/x-ms-xbap",
        "xbap"
    ],
    [
        "application/x-msaccess",
        "mdb"
    ],
    [
        "application/x-msbinder",
        "obd"
    ],
    [
        "application/x-mscardfile",
        "crd"
    ],
    [
        "application/x-msclip",
        "clp"
    ],
    [
        "application/x-msdownload",
        [
            "exe",
            "dll"
        ]
    ],
    [
        "application/x-msexcel",
        [
            "xls",
            "xla",
            "xlw"
        ]
    ],
    [
        "application/x-msmediaview",
        [
            "mvb",
            "m13",
            "m14"
        ]
    ],
    [
        "application/x-msmetafile",
        "wmf"
    ],
    [
        "application/x-msmoney",
        "mny"
    ],
    [
        "application/x-mspowerpoint",
        "ppt"
    ],
    [
        "application/x-mspublisher",
        "pub"
    ],
    [
        "application/x-msschedule",
        "scd"
    ],
    [
        "application/x-msterminal",
        "trm"
    ],
    [
        "application/x-mswrite",
        "wri"
    ],
    [
        "application/x-navi-animation",
        "ani"
    ],
    [
        "application/x-navidoc",
        "nvd"
    ],
    [
        "application/x-navimap",
        "map"
    ],
    [
        "application/x-navistyle",
        "stl"
    ],
    [
        "application/x-netcdf",
        [
            "cdf",
            "nc"
        ]
    ],
    [
        "application/x-newton-compatible-pkg",
        "pkg"
    ],
    [
        "application/x-nokia-9000-communicator-add-on-software",
        "aos"
    ],
    [
        "application/x-omc",
        "omc"
    ],
    [
        "application/x-omcdatamaker",
        "omcd"
    ],
    [
        "application/x-omcregerator",
        "omcr"
    ],
    [
        "application/x-pagemaker",
        [
            "pm4",
            "pm5"
        ]
    ],
    [
        "application/x-pcl",
        "pcl"
    ],
    [
        "application/x-perfmon",
        [
            "pma",
            "pmc",
            "pml",
            "pmr",
            "pmw"
        ]
    ],
    [
        "application/x-pixclscript",
        "plx"
    ],
    [
        "application/x-pkcs10",
        "p10"
    ],
    [
        "application/x-pkcs12",
        [
            "p12",
            "pfx"
        ]
    ],
    [
        "application/x-pkcs7-certificates",
        [
            "p7b",
            "spc"
        ]
    ],
    [
        "application/x-pkcs7-certreqresp",
        "p7r"
    ],
    [
        "application/x-pkcs7-mime",
        [
            "p7m",
            "p7c"
        ]
    ],
    [
        "application/x-pkcs7-signature",
        [
            "p7s",
            "p7a"
        ]
    ],
    [
        "application/x-pointplus",
        "css"
    ],
    [
        "application/x-portable-anymap",
        "pnm"
    ],
    [
        "application/x-project",
        [
            "mpc",
            "mpt",
            "mpv",
            "mpx"
        ]
    ],
    [
        "application/x-qpro",
        "wb1"
    ],
    [
        "application/x-rar-compressed",
        "rar"
    ],
    [
        "application/x-rtf",
        "rtf"
    ],
    [
        "application/x-sdp",
        "sdp"
    ],
    [
        "application/x-sea",
        "sea"
    ],
    [
        "application/x-seelogo",
        "sl"
    ],
    [
        "application/x-sh",
        "sh"
    ],
    [
        "application/x-shar",
        [
            "shar",
            "sh"
        ]
    ],
    [
        "application/x-shockwave-flash",
        "swf"
    ],
    [
        "application/x-silverlight-app",
        "xap"
    ],
    [
        "application/x-sit",
        "sit"
    ],
    [
        "application/x-sprite",
        [
            "spr",
            "sprite"
        ]
    ],
    [
        "application/x-stuffit",
        "sit"
    ],
    [
        "application/x-stuffitx",
        "sitx"
    ],
    [
        "application/x-sv4cpio",
        "sv4cpio"
    ],
    [
        "application/x-sv4crc",
        "sv4crc"
    ],
    [
        "application/x-tar",
        "tar"
    ],
    [
        "application/x-tbook",
        [
            "sbk",
            "tbk"
        ]
    ],
    [
        "application/x-tcl",
        "tcl"
    ],
    [
        "application/x-tex",
        "tex"
    ],
    [
        "application/x-tex-tfm",
        "tfm"
    ],
    [
        "application/x-texinfo",
        [
            "texi",
            "texinfo"
        ]
    ],
    [
        "application/x-troff",
        [
            "roff",
            "t",
            "tr"
        ]
    ],
    [
        "application/x-troff-man",
        "man"
    ],
    [
        "application/x-troff-me",
        "me"
    ],
    [
        "application/x-troff-ms",
        "ms"
    ],
    [
        "application/x-troff-msvideo",
        "avi"
    ],
    [
        "application/x-ustar",
        "ustar"
    ],
    [
        "application/x-visio",
        [
            "vsd",
            "vst",
            "vsw"
        ]
    ],
    [
        "application/x-vnd.audioexplosion.mzz",
        "mzz"
    ],
    [
        "application/x-vnd.ls-xpix",
        "xpix"
    ],
    [
        "application/x-vrml",
        "vrml"
    ],
    [
        "application/x-wais-source",
        [
            "src",
            "wsrc"
        ]
    ],
    [
        "application/x-winhelp",
        "hlp"
    ],
    [
        "application/x-wintalk",
        "wtk"
    ],
    [
        "application/x-world",
        [
            "wrl",
            "svr"
        ]
    ],
    [
        "application/x-wpwin",
        "wpd"
    ],
    [
        "application/x-wri",
        "wri"
    ],
    [
        "application/x-x509-ca-cert",
        [
            "cer",
            "crt",
            "der"
        ]
    ],
    [
        "application/x-x509-user-cert",
        "crt"
    ],
    [
        "application/x-xfig",
        "fig"
    ],
    [
        "application/x-xpinstall",
        "xpi"
    ],
    [
        "application/x-zip-compressed",
        "zip"
    ],
    [
        "application/xcap-diff+xml",
        "xdf"
    ],
    [
        "application/xenc+xml",
        "xenc"
    ],
    [
        "application/xhtml+xml",
        "xhtml"
    ],
    [
        "application/xml",
        "xml"
    ],
    [
        "application/xml-dtd",
        "dtd"
    ],
    [
        "application/xop+xml",
        "xop"
    ],
    [
        "application/xslt+xml",
        "xslt"
    ],
    [
        "application/xspf+xml",
        "xspf"
    ],
    [
        "application/xv+xml",
        "mxml"
    ],
    [
        "application/yang",
        "yang"
    ],
    [
        "application/yin+xml",
        "yin"
    ],
    [
        "application/ynd.ms-pkipko",
        "pko"
    ],
    [
        "application/zip",
        "zip"
    ],
    [
        "audio/adpcm",
        "adp"
    ],
    [
        "audio/aiff",
        [
            "aiff",
            "aif",
            "aifc"
        ]
    ],
    [
        "audio/basic",
        [
            "snd",
            "au"
        ]
    ],
    [
        "audio/it",
        "it"
    ],
    [
        "audio/make",
        [
            "funk",
            "my",
            "pfunk"
        ]
    ],
    [
        "audio/make.my.funk",
        "pfunk"
    ],
    [
        "audio/mid",
        [
            "mid",
            "rmi"
        ]
    ],
    [
        "audio/midi",
        [
            "midi",
            "kar",
            "mid"
        ]
    ],
    [
        "audio/mod",
        "mod"
    ],
    [
        "audio/mp4",
        "mp4a"
    ],
    [
        "audio/mpeg",
        [
            "mpga",
            "mp3",
            "m2a",
            "mp2",
            "mpa",
            "mpg"
        ]
    ],
    [
        "audio/mpeg3",
        "mp3"
    ],
    [
        "audio/nspaudio",
        [
            "la",
            "lma"
        ]
    ],
    [
        "audio/ogg",
        "oga"
    ],
    [
        "audio/s3m",
        "s3m"
    ],
    [
        "audio/tsp-audio",
        "tsi"
    ],
    [
        "audio/tsplayer",
        "tsp"
    ],
    [
        "audio/vnd.dece.audio",
        "uva"
    ],
    [
        "audio/vnd.digital-winds",
        "eol"
    ],
    [
        "audio/vnd.dra",
        "dra"
    ],
    [
        "audio/vnd.dts",
        "dts"
    ],
    [
        "audio/vnd.dts.hd",
        "dtshd"
    ],
    [
        "audio/vnd.lucent.voice",
        "lvp"
    ],
    [
        "audio/vnd.ms-playready.media.pya",
        "pya"
    ],
    [
        "audio/vnd.nuera.ecelp4800",
        "ecelp4800"
    ],
    [
        "audio/vnd.nuera.ecelp7470",
        "ecelp7470"
    ],
    [
        "audio/vnd.nuera.ecelp9600",
        "ecelp9600"
    ],
    [
        "audio/vnd.qcelp",
        "qcp"
    ],
    [
        "audio/vnd.rip",
        "rip"
    ],
    [
        "audio/voc",
        "voc"
    ],
    [
        "audio/voxware",
        "vox"
    ],
    [
        "audio/wav",
        "wav"
    ],
    [
        "audio/webm",
        "weba"
    ],
    [
        "audio/x-aac",
        "aac"
    ],
    [
        "audio/x-adpcm",
        "snd"
    ],
    [
        "audio/x-aiff",
        [
            "aiff",
            "aif",
            "aifc"
        ]
    ],
    [
        "audio/x-au",
        "au"
    ],
    [
        "audio/x-gsm",
        [
            "gsd",
            "gsm"
        ]
    ],
    [
        "audio/x-jam",
        "jam"
    ],
    [
        "audio/x-liveaudio",
        "lam"
    ],
    [
        "audio/x-mid",
        [
            "mid",
            "midi"
        ]
    ],
    [
        "audio/x-midi",
        [
            "midi",
            "mid"
        ]
    ],
    [
        "audio/x-mod",
        "mod"
    ],
    [
        "audio/x-mpeg",
        "mp2"
    ],
    [
        "audio/x-mpeg-3",
        "mp3"
    ],
    [
        "audio/x-mpegurl",
        "m3u"
    ],
    [
        "audio/x-mpequrl",
        "m3u"
    ],
    [
        "audio/x-ms-wax",
        "wax"
    ],
    [
        "audio/x-ms-wma",
        "wma"
    ],
    [
        "audio/x-nspaudio",
        [
            "la",
            "lma"
        ]
    ],
    [
        "audio/x-pn-realaudio",
        [
            "ra",
            "ram",
            "rm",
            "rmm",
            "rmp"
        ]
    ],
    [
        "audio/x-pn-realaudio-plugin",
        [
            "ra",
            "rmp",
            "rpm"
        ]
    ],
    [
        "audio/x-psid",
        "sid"
    ],
    [
        "audio/x-realaudio",
        "ra"
    ],
    [
        "audio/x-twinvq",
        "vqf"
    ],
    [
        "audio/x-twinvq-plugin",
        [
            "vqe",
            "vql"
        ]
    ],
    [
        "audio/x-vnd.audioexplosion.mjuicemediafile",
        "mjf"
    ],
    [
        "audio/x-voc",
        "voc"
    ],
    [
        "audio/x-wav",
        "wav"
    ],
    [
        "audio/xm",
        "xm"
    ],
    [
        "chemical/x-cdx",
        "cdx"
    ],
    [
        "chemical/x-cif",
        "cif"
    ],
    [
        "chemical/x-cmdf",
        "cmdf"
    ],
    [
        "chemical/x-cml",
        "cml"
    ],
    [
        "chemical/x-csml",
        "csml"
    ],
    [
        "chemical/x-pdb",
        [
            "pdb",
            "xyz"
        ]
    ],
    [
        "chemical/x-xyz",
        "xyz"
    ],
    [
        "drawing/x-dwf",
        "dwf"
    ],
    [
        "i-world/i-vrml",
        "ivr"
    ],
    [
        "image/bmp",
        [
            "bmp",
            "bm"
        ]
    ],
    [
        "image/cgm",
        "cgm"
    ],
    [
        "image/cis-cod",
        "cod"
    ],
    [
        "image/cmu-raster",
        [
            "ras",
            "rast"
        ]
    ],
    [
        "image/fif",
        "fif"
    ],
    [
        "image/florian",
        [
            "flo",
            "turbot"
        ]
    ],
    [
        "image/g3fax",
        "g3"
    ],
    [
        "image/gif",
        "gif"
    ],
    [
        "image/ief",
        [
            "ief",
            "iefs"
        ]
    ],
    [
        "image/jpeg",
        [
            "jpeg",
            "jpe",
            "jpg",
            "jfif",
            "jfif-tbnl"
        ]
    ],
    [
        "image/jutvision",
        "jut"
    ],
    [
        "image/ktx",
        "ktx"
    ],
    [
        "image/naplps",
        [
            "nap",
            "naplps"
        ]
    ],
    [
        "image/pict",
        [
            "pic",
            "pict"
        ]
    ],
    [
        "image/pipeg",
        "jfif"
    ],
    [
        "image/pjpeg",
        [
            "jfif",
            "jpe",
            "jpeg",
            "jpg"
        ]
    ],
    [
        "image/png",
        [
            "png",
            "x-png"
        ]
    ],
    [
        "image/prs.btif",
        "btif"
    ],
    [
        "image/svg+xml",
        "svg"
    ],
    [
        "image/tiff",
        [
            "tif",
            "tiff"
        ]
    ],
    [
        "image/vasa",
        "mcf"
    ],
    [
        "image/vnd.adobe.photoshop",
        "psd"
    ],
    [
        "image/vnd.dece.graphic",
        "uvi"
    ],
    [
        "image/vnd.djvu",
        "djvu"
    ],
    [
        "image/vnd.dvb.subtitle",
        "sub"
    ],
    [
        "image/vnd.dwg",
        [
            "dwg",
            "dxf",
            "svf"
        ]
    ],
    [
        "image/vnd.dxf",
        "dxf"
    ],
    [
        "image/vnd.fastbidsheet",
        "fbs"
    ],
    [
        "image/vnd.fpx",
        "fpx"
    ],
    [
        "image/vnd.fst",
        "fst"
    ],
    [
        "image/vnd.fujixerox.edmics-mmr",
        "mmr"
    ],
    [
        "image/vnd.fujixerox.edmics-rlc",
        "rlc"
    ],
    [
        "image/vnd.ms-modi",
        "mdi"
    ],
    [
        "image/vnd.net-fpx",
        [
            "fpx",
            "npx"
        ]
    ],
    [
        "image/vnd.rn-realflash",
        "rf"
    ],
    [
        "image/vnd.rn-realpix",
        "rp"
    ],
    [
        "image/vnd.wap.wbmp",
        "wbmp"
    ],
    [
        "image/vnd.xiff",
        "xif"
    ],
    [
        "image/webp",
        "webp"
    ],
    [
        "image/x-cmu-raster",
        "ras"
    ],
    [
        "image/x-cmx",
        "cmx"
    ],
    [
        "image/x-dwg",
        [
            "dwg",
            "dxf",
            "svf"
        ]
    ],
    [
        "image/x-freehand",
        "fh"
    ],
    [
        "image/x-icon",
        "ico"
    ],
    [
        "image/x-jg",
        "art"
    ],
    [
        "image/x-jps",
        "jps"
    ],
    [
        "image/x-niff",
        [
            "niff",
            "nif"
        ]
    ],
    [
        "image/x-pcx",
        "pcx"
    ],
    [
        "image/x-pict",
        [
            "pct",
            "pic"
        ]
    ],
    [
        "image/x-portable-anymap",
        "pnm"
    ],
    [
        "image/x-portable-bitmap",
        "pbm"
    ],
    [
        "image/x-portable-graymap",
        "pgm"
    ],
    [
        "image/x-portable-greymap",
        "pgm"
    ],
    [
        "image/x-portable-pixmap",
        "ppm"
    ],
    [
        "image/x-quicktime",
        [
            "qif",
            "qti",
            "qtif"
        ]
    ],
    [
        "image/x-rgb",
        "rgb"
    ],
    [
        "image/x-tiff",
        [
            "tif",
            "tiff"
        ]
    ],
    [
        "image/x-windows-bmp",
        "bmp"
    ],
    [
        "image/x-xbitmap",
        "xbm"
    ],
    [
        "image/x-xbm",
        "xbm"
    ],
    [
        "image/x-xpixmap",
        [
            "xpm",
            "pm"
        ]
    ],
    [
        "image/x-xwd",
        "xwd"
    ],
    [
        "image/x-xwindowdump",
        "xwd"
    ],
    [
        "image/xbm",
        "xbm"
    ],
    [
        "image/xpm",
        "xpm"
    ],
    [
        "message/rfc822",
        [
            "eml",
            "mht",
            "mhtml",
            "nws",
            "mime"
        ]
    ],
    [
        "model/iges",
        [
            "iges",
            "igs"
        ]
    ],
    [
        "model/mesh",
        "msh"
    ],
    [
        "model/vnd.collada+xml",
        "dae"
    ],
    [
        "model/vnd.dwf",
        "dwf"
    ],
    [
        "model/vnd.gdl",
        "gdl"
    ],
    [
        "model/vnd.gtw",
        "gtw"
    ],
    [
        "model/vnd.mts",
        "mts"
    ],
    [
        "model/vnd.vtu",
        "vtu"
    ],
    [
        "model/vrml",
        [
            "vrml",
            "wrl",
            "wrz"
        ]
    ],
    [
        "model/x-pov",
        "pov"
    ],
    [
        "multipart/x-gzip",
        "gzip"
    ],
    [
        "multipart/x-ustar",
        "ustar"
    ],
    [
        "multipart/x-zip",
        "zip"
    ],
    [
        "music/crescendo",
        [
            "mid",
            "midi"
        ]
    ],
    [
        "music/x-karaoke",
        "kar"
    ],
    [
        "paleovu/x-pv",
        "pvu"
    ],
    [
        "text/asp",
        "asp"
    ],
    [
        "text/calendar",
        "ics"
    ],
    [
        "text/css",
        "css"
    ],
    [
        "text/csv",
        "csv"
    ],
    [
        "text/ecmascript",
        "js"
    ],
    [
        "text/h323",
        "323"
    ],
    [
        "text/html",
        [
            "html",
            "htm",
            "stm",
            "acgi",
            "htmls",
            "htx",
            "shtml"
        ]
    ],
    [
        "text/iuls",
        "uls"
    ],
    [
        "text/javascript",
        "js"
    ],
    [
        "text/mcf",
        "mcf"
    ],
    [
        "text/n3",
        "n3"
    ],
    [
        "text/pascal",
        "pas"
    ],
    [
        "text/plain",
        [
            "txt",
            "bas",
            "c",
            "h",
            "c++",
            "cc",
            "com",
            "conf",
            "cxx",
            "def",
            "f",
            "f90",
            "for",
            "g",
            "hh",
            "idc",
            "jav",
            "java",
            "list",
            "log",
            "lst",
            "m",
            "mar",
            "pl",
            "sdml",
            "text"
        ]
    ],
    [
        "text/plain-bas",
        "par"
    ],
    [
        "text/prs.lines.tag",
        "dsc"
    ],
    [
        "text/richtext",
        [
            "rtx",
            "rt",
            "rtf"
        ]
    ],
    [
        "text/scriplet",
        "wsc"
    ],
    [
        "text/scriptlet",
        "sct"
    ],
    [
        "text/sgml",
        [
            "sgm",
            "sgml"
        ]
    ],
    [
        "text/tab-separated-values",
        "tsv"
    ],
    [
        "text/troff",
        "t"
    ],
    [
        "text/turtle",
        "ttl"
    ],
    [
        "text/uri-list",
        [
            "uni",
            "unis",
            "uri",
            "uris"
        ]
    ],
    [
        "text/vnd.abc",
        "abc"
    ],
    [
        "text/vnd.curl",
        "curl"
    ],
    [
        "text/vnd.curl.dcurl",
        "dcurl"
    ],
    [
        "text/vnd.curl.mcurl",
        "mcurl"
    ],
    [
        "text/vnd.curl.scurl",
        "scurl"
    ],
    [
        "text/vnd.fly",
        "fly"
    ],
    [
        "text/vnd.fmi.flexstor",
        "flx"
    ],
    [
        "text/vnd.graphviz",
        "gv"
    ],
    [
        "text/vnd.in3d.3dml",
        "3dml"
    ],
    [
        "text/vnd.in3d.spot",
        "spot"
    ],
    [
        "text/vnd.rn-realtext",
        "rt"
    ],
    [
        "text/vnd.sun.j2me.app-descriptor",
        "jad"
    ],
    [
        "text/vnd.wap.wml",
        "wml"
    ],
    [
        "text/vnd.wap.wmlscript",
        "wmls"
    ],
    [
        "text/webviewhtml",
        "htt"
    ],
    [
        "text/x-asm",
        [
            "asm",
            "s"
        ]
    ],
    [
        "text/x-audiosoft-intra",
        "aip"
    ],
    [
        "text/x-c",
        [
            "c",
            "cc",
            "cpp"
        ]
    ],
    [
        "text/x-component",
        "htc"
    ],
    [
        "text/x-fortran",
        [
            "for",
            "f",
            "f77",
            "f90"
        ]
    ],
    [
        "text/x-h",
        [
            "h",
            "hh"
        ]
    ],
    [
        "text/x-java-source",
        [
            "java",
            "jav"
        ]
    ],
    [
        "text/x-java-source,java",
        "java"
    ],
    [
        "text/x-la-asf",
        "lsx"
    ],
    [
        "text/x-m",
        "m"
    ],
    [
        "text/x-pascal",
        "p"
    ],
    [
        "text/x-script",
        "hlb"
    ],
    [
        "text/x-script.csh",
        "csh"
    ],
    [
        "text/x-script.elisp",
        "el"
    ],
    [
        "text/x-script.guile",
        "scm"
    ],
    [
        "text/x-script.ksh",
        "ksh"
    ],
    [
        "text/x-script.lisp",
        "lsp"
    ],
    [
        "text/x-script.perl",
        "pl"
    ],
    [
        "text/x-script.perl-module",
        "pm"
    ],
    [
        "text/x-script.phyton",
        "py"
    ],
    [
        "text/x-script.rexx",
        "rexx"
    ],
    [
        "text/x-script.scheme",
        "scm"
    ],
    [
        "text/x-script.sh",
        "sh"
    ],
    [
        "text/x-script.tcl",
        "tcl"
    ],
    [
        "text/x-script.tcsh",
        "tcsh"
    ],
    [
        "text/x-script.zsh",
        "zsh"
    ],
    [
        "text/x-server-parsed-html",
        [
            "shtml",
            "ssi"
        ]
    ],
    [
        "text/x-setext",
        "etx"
    ],
    [
        "text/x-sgml",
        [
            "sgm",
            "sgml"
        ]
    ],
    [
        "text/x-speech",
        [
            "spc",
            "talk"
        ]
    ],
    [
        "text/x-uil",
        "uil"
    ],
    [
        "text/x-uuencode",
        [
            "uu",
            "uue"
        ]
    ],
    [
        "text/x-vcalendar",
        "vcs"
    ],
    [
        "text/x-vcard",
        "vcf"
    ],
    [
        "text/xml",
        "xml"
    ],
    [
        "video/3gpp",
        "3gp"
    ],
    [
        "video/3gpp2",
        "3g2"
    ],
    [
        "video/animaflex",
        "afl"
    ],
    [
        "video/avi",
        "avi"
    ],
    [
        "video/avs-video",
        "avs"
    ],
    [
        "video/dl",
        "dl"
    ],
    [
        "video/fli",
        "fli"
    ],
    [
        "video/gl",
        "gl"
    ],
    [
        "video/h261",
        "h261"
    ],
    [
        "video/h263",
        "h263"
    ],
    [
        "video/h264",
        "h264"
    ],
    [
        "video/jpeg",
        "jpgv"
    ],
    [
        "video/jpm",
        "jpm"
    ],
    [
        "video/mj2",
        "mj2"
    ],
    [
        "video/mp4",
        "mp4"
    ],
    [
        "video/mpeg",
        [
            "mpeg",
            "mp2",
            "mpa",
            "mpe",
            "mpg",
            "mpv2",
            "m1v",
            "m2v",
            "mp3"
        ]
    ],
    [
        "video/msvideo",
        "avi"
    ],
    [
        "video/ogg",
        "ogv"
    ],
    [
        "video/quicktime",
        [
            "mov",
            "qt",
            "moov"
        ]
    ],
    [
        "video/vdo",
        "vdo"
    ],
    [
        "video/vivo",
        [
            "viv",
            "vivo"
        ]
    ],
    [
        "video/vnd.dece.hd",
        "uvh"
    ],
    [
        "video/vnd.dece.mobile",
        "uvm"
    ],
    [
        "video/vnd.dece.pd",
        "uvp"
    ],
    [
        "video/vnd.dece.sd",
        "uvs"
    ],
    [
        "video/vnd.dece.video",
        "uvv"
    ],
    [
        "video/vnd.fvt",
        "fvt"
    ],
    [
        "video/vnd.mpegurl",
        "mxu"
    ],
    [
        "video/vnd.ms-playready.media.pyv",
        "pyv"
    ],
    [
        "video/vnd.rn-realvideo",
        "rv"
    ],
    [
        "video/vnd.uvvu.mp4",
        "uvu"
    ],
    [
        "video/vnd.vivo",
        [
            "viv",
            "vivo"
        ]
    ],
    [
        "video/vosaic",
        "vos"
    ],
    [
        "video/webm",
        "webm"
    ],
    [
        "video/x-amt-demorun",
        "xdr"
    ],
    [
        "video/x-amt-showrun",
        "xsr"
    ],
    [
        "video/x-atomic3d-feature",
        "fmf"
    ],
    [
        "video/x-dl",
        "dl"
    ],
    [
        "video/x-dv",
        [
            "dif",
            "dv"
        ]
    ],
    [
        "video/x-f4v",
        "f4v"
    ],
    [
        "video/x-fli",
        "fli"
    ],
    [
        "video/x-flv",
        "flv"
    ],
    [
        "video/x-gl",
        "gl"
    ],
    [
        "video/x-isvideo",
        "isu"
    ],
    [
        "video/x-la-asf",
        [
            "lsf",
            "lsx"
        ]
    ],
    [
        "video/x-m4v",
        "m4v"
    ],
    [
        "video/x-motion-jpeg",
        "mjpg"
    ],
    [
        "video/x-mpeg",
        [
            "mp3",
            "mp2"
        ]
    ],
    [
        "video/x-mpeq2a",
        "mp2"
    ],
    [
        "video/x-ms-asf",
        [
            "asf",
            "asr",
            "asx"
        ]
    ],
    [
        "video/x-ms-asf-plugin",
        "asx"
    ],
    [
        "video/x-ms-wm",
        "wm"
    ],
    [
        "video/x-ms-wmv",
        "wmv"
    ],
    [
        "video/x-ms-wmx",
        "wmx"
    ],
    [
        "video/x-ms-wvx",
        "wvx"
    ],
    [
        "video/x-msvideo",
        "avi"
    ],
    [
        "video/x-qtc",
        "qtc"
    ],
    [
        "video/x-scm",
        "scm"
    ],
    [
        "video/x-sgi-movie",
        [
            "movie",
            "mv"
        ]
    ],
    [
        "windows/metafile",
        "wmf"
    ],
    [
        "www/mime",
        "mime"
    ],
    [
        "x-conference/x-cooltalk",
        "ice"
    ],
    [
        "x-music/x-midi",
        [
            "mid",
            "midi"
        ]
    ],
    [
        "x-world/x-3dmf",
        [
            "3dm",
            "3dmf",
            "qd3",
            "qd3d"
        ]
    ],
    [
        "x-world/x-svr",
        "svr"
    ],
    [
        "x-world/x-vrml",
        [
            "flr",
            "vrml",
            "wrl",
            "wrz",
            "xaf",
            "xof"
        ]
    ],
    [
        "x-world/x-vrt",
        "vrt"
    ],
    [
        "xgl/drawing",
        "xgz"
    ],
    [
        "xgl/movie",
        "xmz"
    ]
]);
const extensions = new Map([
    [
        "123",
        "application/vnd.lotus-1-2-3"
    ],
    [
        "323",
        "text/h323"
    ],
    [
        "*",
        "application/octet-stream"
    ],
    [
        "3dm",
        "x-world/x-3dmf"
    ],
    [
        "3dmf",
        "x-world/x-3dmf"
    ],
    [
        "3dml",
        "text/vnd.in3d.3dml"
    ],
    [
        "3g2",
        "video/3gpp2"
    ],
    [
        "3gp",
        "video/3gpp"
    ],
    [
        "7z",
        "application/x-7z-compressed"
    ],
    [
        "a",
        "application/octet-stream"
    ],
    [
        "aab",
        "application/x-authorware-bin"
    ],
    [
        "aac",
        "audio/x-aac"
    ],
    [
        "aam",
        "application/x-authorware-map"
    ],
    [
        "aas",
        "application/x-authorware-seg"
    ],
    [
        "abc",
        "text/vnd.abc"
    ],
    [
        "abw",
        "application/x-abiword"
    ],
    [
        "ac",
        "application/pkix-attr-cert"
    ],
    [
        "acc",
        "application/vnd.americandynamics.acc"
    ],
    [
        "ace",
        "application/x-ace-compressed"
    ],
    [
        "acgi",
        "text/html"
    ],
    [
        "acu",
        "application/vnd.acucobol"
    ],
    [
        "acx",
        "application/internet-property-stream"
    ],
    [
        "adp",
        "audio/adpcm"
    ],
    [
        "aep",
        "application/vnd.audiograph"
    ],
    [
        "afl",
        "video/animaflex"
    ],
    [
        "afp",
        "application/vnd.ibm.modcap"
    ],
    [
        "ahead",
        "application/vnd.ahead.space"
    ],
    [
        "ai",
        "application/postscript"
    ],
    [
        "aif",
        [
            "audio/aiff",
            "audio/x-aiff"
        ]
    ],
    [
        "aifc",
        [
            "audio/aiff",
            "audio/x-aiff"
        ]
    ],
    [
        "aiff",
        [
            "audio/aiff",
            "audio/x-aiff"
        ]
    ],
    [
        "aim",
        "application/x-aim"
    ],
    [
        "aip",
        "text/x-audiosoft-intra"
    ],
    [
        "air",
        "application/vnd.adobe.air-application-installer-package+zip"
    ],
    [
        "ait",
        "application/vnd.dvb.ait"
    ],
    [
        "ami",
        "application/vnd.amiga.ami"
    ],
    [
        "ani",
        "application/x-navi-animation"
    ],
    [
        "aos",
        "application/x-nokia-9000-communicator-add-on-software"
    ],
    [
        "apk",
        "application/vnd.android.package-archive"
    ],
    [
        "application",
        "application/x-ms-application"
    ],
    [
        "apr",
        "application/vnd.lotus-approach"
    ],
    [
        "aps",
        "application/mime"
    ],
    [
        "arc",
        "application/octet-stream"
    ],
    [
        "arj",
        [
            "application/arj",
            "application/octet-stream"
        ]
    ],
    [
        "art",
        "image/x-jg"
    ],
    [
        "asf",
        "video/x-ms-asf"
    ],
    [
        "asm",
        "text/x-asm"
    ],
    [
        "aso",
        "application/vnd.accpac.simply.aso"
    ],
    [
        "asp",
        "text/asp"
    ],
    [
        "asr",
        "video/x-ms-asf"
    ],
    [
        "asx",
        [
            "video/x-ms-asf",
            "application/x-mplayer2",
            "video/x-ms-asf-plugin"
        ]
    ],
    [
        "atc",
        "application/vnd.acucorp"
    ],
    [
        "atomcat",
        "application/atomcat+xml"
    ],
    [
        "atomsvc",
        "application/atomsvc+xml"
    ],
    [
        "atx",
        "application/vnd.antix.game-component"
    ],
    [
        "au",
        [
            "audio/basic",
            "audio/x-au"
        ]
    ],
    [
        "avi",
        [
            "video/avi",
            "video/msvideo",
            "application/x-troff-msvideo",
            "video/x-msvideo"
        ]
    ],
    [
        "avs",
        "video/avs-video"
    ],
    [
        "aw",
        "application/applixware"
    ],
    [
        "axs",
        "application/olescript"
    ],
    [
        "azf",
        "application/vnd.airzip.filesecure.azf"
    ],
    [
        "azs",
        "application/vnd.airzip.filesecure.azs"
    ],
    [
        "azw",
        "application/vnd.amazon.ebook"
    ],
    [
        "bas",
        "text/plain"
    ],
    [
        "bcpio",
        "application/x-bcpio"
    ],
    [
        "bdf",
        "application/x-font-bdf"
    ],
    [
        "bdm",
        "application/vnd.syncml.dm+wbxml"
    ],
    [
        "bed",
        "application/vnd.realvnc.bed"
    ],
    [
        "bh2",
        "application/vnd.fujitsu.oasysprs"
    ],
    [
        "bin",
        [
            "application/octet-stream",
            "application/mac-binary",
            "application/macbinary",
            "application/x-macbinary",
            "application/x-binary"
        ]
    ],
    [
        "bm",
        "image/bmp"
    ],
    [
        "bmi",
        "application/vnd.bmi"
    ],
    [
        "bmp",
        [
            "image/bmp",
            "image/x-windows-bmp"
        ]
    ],
    [
        "boo",
        "application/book"
    ],
    [
        "book",
        "application/book"
    ],
    [
        "box",
        "application/vnd.previewsystems.box"
    ],
    [
        "boz",
        "application/x-bzip2"
    ],
    [
        "bsh",
        "application/x-bsh"
    ],
    [
        "btif",
        "image/prs.btif"
    ],
    [
        "bz",
        "application/x-bzip"
    ],
    [
        "bz2",
        "application/x-bzip2"
    ],
    [
        "c",
        [
            "text/plain",
            "text/x-c"
        ]
    ],
    [
        "c++",
        "text/plain"
    ],
    [
        "c11amc",
        "application/vnd.cluetrust.cartomobile-config"
    ],
    [
        "c11amz",
        "application/vnd.cluetrust.cartomobile-config-pkg"
    ],
    [
        "c4g",
        "application/vnd.clonk.c4group"
    ],
    [
        "cab",
        "application/vnd.ms-cab-compressed"
    ],
    [
        "car",
        "application/vnd.curl.car"
    ],
    [
        "cat",
        [
            "application/vnd.ms-pkiseccat",
            "application/vnd.ms-pki.seccat"
        ]
    ],
    [
        "cc",
        [
            "text/plain",
            "text/x-c"
        ]
    ],
    [
        "ccad",
        "application/clariscad"
    ],
    [
        "cco",
        "application/x-cocoa"
    ],
    [
        "ccxml",
        "application/ccxml+xml,"
    ],
    [
        "cdbcmsg",
        "application/vnd.contact.cmsg"
    ],
    [
        "cdf",
        [
            "application/cdf",
            "application/x-cdf",
            "application/x-netcdf"
        ]
    ],
    [
        "cdkey",
        "application/vnd.mediastation.cdkey"
    ],
    [
        "cdmia",
        "application/cdmi-capability"
    ],
    [
        "cdmic",
        "application/cdmi-container"
    ],
    [
        "cdmid",
        "application/cdmi-domain"
    ],
    [
        "cdmio",
        "application/cdmi-object"
    ],
    [
        "cdmiq",
        "application/cdmi-queue"
    ],
    [
        "cdx",
        "chemical/x-cdx"
    ],
    [
        "cdxml",
        "application/vnd.chemdraw+xml"
    ],
    [
        "cdy",
        "application/vnd.cinderella"
    ],
    [
        "cer",
        [
            "application/pkix-cert",
            "application/x-x509-ca-cert"
        ]
    ],
    [
        "cgm",
        "image/cgm"
    ],
    [
        "cha",
        "application/x-chat"
    ],
    [
        "chat",
        "application/x-chat"
    ],
    [
        "chm",
        "application/vnd.ms-htmlhelp"
    ],
    [
        "chrt",
        "application/vnd.kde.kchart"
    ],
    [
        "cif",
        "chemical/x-cif"
    ],
    [
        "cii",
        "application/vnd.anser-web-certificate-issue-initiation"
    ],
    [
        "cil",
        "application/vnd.ms-artgalry"
    ],
    [
        "cla",
        "application/vnd.claymore"
    ],
    [
        "class",
        [
            "application/octet-stream",
            "application/java",
            "application/java-byte-code",
            "application/java-vm",
            "application/x-java-class"
        ]
    ],
    [
        "clkk",
        "application/vnd.crick.clicker.keyboard"
    ],
    [
        "clkp",
        "application/vnd.crick.clicker.palette"
    ],
    [
        "clkt",
        "application/vnd.crick.clicker.template"
    ],
    [
        "clkw",
        "application/vnd.crick.clicker.wordbank"
    ],
    [
        "clkx",
        "application/vnd.crick.clicker"
    ],
    [
        "clp",
        "application/x-msclip"
    ],
    [
        "cmc",
        "application/vnd.cosmocaller"
    ],
    [
        "cmdf",
        "chemical/x-cmdf"
    ],
    [
        "cml",
        "chemical/x-cml"
    ],
    [
        "cmp",
        "application/vnd.yellowriver-custom-menu"
    ],
    [
        "cmx",
        "image/x-cmx"
    ],
    [
        "cod",
        [
            "image/cis-cod",
            "application/vnd.rim.cod"
        ]
    ],
    [
        "com",
        [
            "application/octet-stream",
            "text/plain"
        ]
    ],
    [
        "conf",
        "text/plain"
    ],
    [
        "cpio",
        "application/x-cpio"
    ],
    [
        "cpp",
        "text/x-c"
    ],
    [
        "cpt",
        [
            "application/mac-compactpro",
            "application/x-compactpro",
            "application/x-cpt"
        ]
    ],
    [
        "crd",
        "application/x-mscardfile"
    ],
    [
        "crl",
        [
            "application/pkix-crl",
            "application/pkcs-crl"
        ]
    ],
    [
        "crt",
        [
            "application/pkix-cert",
            "application/x-x509-user-cert",
            "application/x-x509-ca-cert"
        ]
    ],
    [
        "cryptonote",
        "application/vnd.rig.cryptonote"
    ],
    [
        "csh",
        [
            "text/x-script.csh",
            "application/x-csh"
        ]
    ],
    [
        "csml",
        "chemical/x-csml"
    ],
    [
        "csp",
        "application/vnd.commonspace"
    ],
    [
        "css",
        [
            "text/css",
            "application/x-pointplus"
        ]
    ],
    [
        "csv",
        "text/csv"
    ],
    [
        "cu",
        "application/cu-seeme"
    ],
    [
        "curl",
        "text/vnd.curl"
    ],
    [
        "cww",
        "application/prs.cww"
    ],
    [
        "cxx",
        "text/plain"
    ],
    [
        "dae",
        "model/vnd.collada+xml"
    ],
    [
        "daf",
        "application/vnd.mobius.daf"
    ],
    [
        "davmount",
        "application/davmount+xml"
    ],
    [
        "dcr",
        "application/x-director"
    ],
    [
        "dcurl",
        "text/vnd.curl.dcurl"
    ],
    [
        "dd2",
        "application/vnd.oma.dd2+xml"
    ],
    [
        "ddd",
        "application/vnd.fujixerox.ddd"
    ],
    [
        "deb",
        "application/x-debian-package"
    ],
    [
        "deepv",
        "application/x-deepv"
    ],
    [
        "def",
        "text/plain"
    ],
    [
        "der",
        "application/x-x509-ca-cert"
    ],
    [
        "dfac",
        "application/vnd.dreamfactory"
    ],
    [
        "dif",
        "video/x-dv"
    ],
    [
        "dir",
        "application/x-director"
    ],
    [
        "dis",
        "application/vnd.mobius.dis"
    ],
    [
        "djvu",
        "image/vnd.djvu"
    ],
    [
        "dl",
        [
            "video/dl",
            "video/x-dl"
        ]
    ],
    [
        "dll",
        "application/x-msdownload"
    ],
    [
        "dms",
        "application/octet-stream"
    ],
    [
        "dna",
        "application/vnd.dna"
    ],
    [
        "doc",
        "application/msword"
    ],
    [
        "docm",
        "application/vnd.ms-word.document.macroenabled.12"
    ],
    [
        "docx",
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    ],
    [
        "dot",
        "application/msword"
    ],
    [
        "dotm",
        "application/vnd.ms-word.template.macroenabled.12"
    ],
    [
        "dotx",
        "application/vnd.openxmlformats-officedocument.wordprocessingml.template"
    ],
    [
        "dp",
        [
            "application/commonground",
            "application/vnd.osgi.dp"
        ]
    ],
    [
        "dpg",
        "application/vnd.dpgraph"
    ],
    [
        "dra",
        "audio/vnd.dra"
    ],
    [
        "drw",
        "application/drafting"
    ],
    [
        "dsc",
        "text/prs.lines.tag"
    ],
    [
        "dssc",
        "application/dssc+der"
    ],
    [
        "dtb",
        "application/x-dtbook+xml"
    ],
    [
        "dtd",
        "application/xml-dtd"
    ],
    [
        "dts",
        "audio/vnd.dts"
    ],
    [
        "dtshd",
        "audio/vnd.dts.hd"
    ],
    [
        "dump",
        "application/octet-stream"
    ],
    [
        "dv",
        "video/x-dv"
    ],
    [
        "dvi",
        "application/x-dvi"
    ],
    [
        "dwf",
        [
            "model/vnd.dwf",
            "drawing/x-dwf"
        ]
    ],
    [
        "dwg",
        [
            "application/acad",
            "image/vnd.dwg",
            "image/x-dwg"
        ]
    ],
    [
        "dxf",
        [
            "application/dxf",
            "image/vnd.dwg",
            "image/vnd.dxf",
            "image/x-dwg"
        ]
    ],
    [
        "dxp",
        "application/vnd.spotfire.dxp"
    ],
    [
        "dxr",
        "application/x-director"
    ],
    [
        "ecelp4800",
        "audio/vnd.nuera.ecelp4800"
    ],
    [
        "ecelp7470",
        "audio/vnd.nuera.ecelp7470"
    ],
    [
        "ecelp9600",
        "audio/vnd.nuera.ecelp9600"
    ],
    [
        "edm",
        "application/vnd.novadigm.edm"
    ],
    [
        "edx",
        "application/vnd.novadigm.edx"
    ],
    [
        "efif",
        "application/vnd.picsel"
    ],
    [
        "ei6",
        "application/vnd.pg.osasli"
    ],
    [
        "el",
        "text/x-script.elisp"
    ],
    [
        "elc",
        [
            "application/x-elc",
            "application/x-bytecode.elisp"
        ]
    ],
    [
        "eml",
        "message/rfc822"
    ],
    [
        "emma",
        "application/emma+xml"
    ],
    [
        "env",
        "application/x-envoy"
    ],
    [
        "eol",
        "audio/vnd.digital-winds"
    ],
    [
        "eot",
        "application/vnd.ms-fontobject"
    ],
    [
        "eps",
        "application/postscript"
    ],
    [
        "epub",
        "application/epub+zip"
    ],
    [
        "es",
        [
            "application/ecmascript",
            "application/x-esrehber"
        ]
    ],
    [
        "es3",
        "application/vnd.eszigno3+xml"
    ],
    [
        "esf",
        "application/vnd.epson.esf"
    ],
    [
        "etx",
        "text/x-setext"
    ],
    [
        "evy",
        [
            "application/envoy",
            "application/x-envoy"
        ]
    ],
    [
        "exe",
        [
            "application/octet-stream",
            "application/x-msdownload"
        ]
    ],
    [
        "exi",
        "application/exi"
    ],
    [
        "ext",
        "application/vnd.novadigm.ext"
    ],
    [
        "ez2",
        "application/vnd.ezpix-album"
    ],
    [
        "ez3",
        "application/vnd.ezpix-package"
    ],
    [
        "f",
        [
            "text/plain",
            "text/x-fortran"
        ]
    ],
    [
        "f4v",
        "video/x-f4v"
    ],
    [
        "f77",
        "text/x-fortran"
    ],
    [
        "f90",
        [
            "text/plain",
            "text/x-fortran"
        ]
    ],
    [
        "fbs",
        "image/vnd.fastbidsheet"
    ],
    [
        "fcs",
        "application/vnd.isac.fcs"
    ],
    [
        "fdf",
        "application/vnd.fdf"
    ],
    [
        "fe_launch",
        "application/vnd.denovo.fcselayout-link"
    ],
    [
        "fg5",
        "application/vnd.fujitsu.oasysgp"
    ],
    [
        "fh",
        "image/x-freehand"
    ],
    [
        "fif",
        [
            "application/fractals",
            "image/fif"
        ]
    ],
    [
        "fig",
        "application/x-xfig"
    ],
    [
        "fli",
        [
            "video/fli",
            "video/x-fli"
        ]
    ],
    [
        "flo",
        [
            "image/florian",
            "application/vnd.micrografx.flo"
        ]
    ],
    [
        "flr",
        "x-world/x-vrml"
    ],
    [
        "flv",
        "video/x-flv"
    ],
    [
        "flw",
        "application/vnd.kde.kivio"
    ],
    [
        "flx",
        "text/vnd.fmi.flexstor"
    ],
    [
        "fly",
        "text/vnd.fly"
    ],
    [
        "fm",
        "application/vnd.framemaker"
    ],
    [
        "fmf",
        "video/x-atomic3d-feature"
    ],
    [
        "fnc",
        "application/vnd.frogans.fnc"
    ],
    [
        "for",
        [
            "text/plain",
            "text/x-fortran"
        ]
    ],
    [
        "fpx",
        [
            "image/vnd.fpx",
            "image/vnd.net-fpx"
        ]
    ],
    [
        "frl",
        "application/freeloader"
    ],
    [
        "fsc",
        "application/vnd.fsc.weblaunch"
    ],
    [
        "fst",
        "image/vnd.fst"
    ],
    [
        "ftc",
        "application/vnd.fluxtime.clip"
    ],
    [
        "fti",
        "application/vnd.anser-web-funds-transfer-initiation"
    ],
    [
        "funk",
        "audio/make"
    ],
    [
        "fvt",
        "video/vnd.fvt"
    ],
    [
        "fxp",
        "application/vnd.adobe.fxp"
    ],
    [
        "fzs",
        "application/vnd.fuzzysheet"
    ],
    [
        "g",
        "text/plain"
    ],
    [
        "g2w",
        "application/vnd.geoplan"
    ],
    [
        "g3",
        "image/g3fax"
    ],
    [
        "g3w",
        "application/vnd.geospace"
    ],
    [
        "gac",
        "application/vnd.groove-account"
    ],
    [
        "gdl",
        "model/vnd.gdl"
    ],
    [
        "geo",
        "application/vnd.dynageo"
    ],
    [
        "gex",
        "application/vnd.geometry-explorer"
    ],
    [
        "ggb",
        "application/vnd.geogebra.file"
    ],
    [
        "ggt",
        "application/vnd.geogebra.tool"
    ],
    [
        "ghf",
        "application/vnd.groove-help"
    ],
    [
        "gif",
        "image/gif"
    ],
    [
        "gim",
        "application/vnd.groove-identity-message"
    ],
    [
        "gl",
        [
            "video/gl",
            "video/x-gl"
        ]
    ],
    [
        "gmx",
        "application/vnd.gmx"
    ],
    [
        "gnumeric",
        "application/x-gnumeric"
    ],
    [
        "gph",
        "application/vnd.flographit"
    ],
    [
        "gqf",
        "application/vnd.grafeq"
    ],
    [
        "gram",
        "application/srgs"
    ],
    [
        "grv",
        "application/vnd.groove-injector"
    ],
    [
        "grxml",
        "application/srgs+xml"
    ],
    [
        "gsd",
        "audio/x-gsm"
    ],
    [
        "gsf",
        "application/x-font-ghostscript"
    ],
    [
        "gsm",
        "audio/x-gsm"
    ],
    [
        "gsp",
        "application/x-gsp"
    ],
    [
        "gss",
        "application/x-gss"
    ],
    [
        "gtar",
        "application/x-gtar"
    ],
    [
        "gtm",
        "application/vnd.groove-tool-message"
    ],
    [
        "gtw",
        "model/vnd.gtw"
    ],
    [
        "gv",
        "text/vnd.graphviz"
    ],
    [
        "gxt",
        "application/vnd.geonext"
    ],
    [
        "gz",
        [
            "application/x-gzip",
            "application/x-compressed"
        ]
    ],
    [
        "gzip",
        [
            "multipart/x-gzip",
            "application/x-gzip"
        ]
    ],
    [
        "h",
        [
            "text/plain",
            "text/x-h"
        ]
    ],
    [
        "h261",
        "video/h261"
    ],
    [
        "h263",
        "video/h263"
    ],
    [
        "h264",
        "video/h264"
    ],
    [
        "hal",
        "application/vnd.hal+xml"
    ],
    [
        "hbci",
        "application/vnd.hbci"
    ],
    [
        "hdf",
        "application/x-hdf"
    ],
    [
        "help",
        "application/x-helpfile"
    ],
    [
        "hgl",
        "application/vnd.hp-hpgl"
    ],
    [
        "hh",
        [
            "text/plain",
            "text/x-h"
        ]
    ],
    [
        "hlb",
        "text/x-script"
    ],
    [
        "hlp",
        [
            "application/winhlp",
            "application/hlp",
            "application/x-helpfile",
            "application/x-winhelp"
        ]
    ],
    [
        "hpg",
        "application/vnd.hp-hpgl"
    ],
    [
        "hpgl",
        "application/vnd.hp-hpgl"
    ],
    [
        "hpid",
        "application/vnd.hp-hpid"
    ],
    [
        "hps",
        "application/vnd.hp-hps"
    ],
    [
        "hqx",
        [
            "application/mac-binhex40",
            "application/binhex",
            "application/binhex4",
            "application/mac-binhex",
            "application/x-binhex40",
            "application/x-mac-binhex40"
        ]
    ],
    [
        "hta",
        "application/hta"
    ],
    [
        "htc",
        "text/x-component"
    ],
    [
        "htke",
        "application/vnd.kenameaapp"
    ],
    [
        "htm",
        "text/html"
    ],
    [
        "html",
        "text/html"
    ],
    [
        "htmls",
        "text/html"
    ],
    [
        "htt",
        "text/webviewhtml"
    ],
    [
        "htx",
        "text/html"
    ],
    [
        "hvd",
        "application/vnd.yamaha.hv-dic"
    ],
    [
        "hvp",
        "application/vnd.yamaha.hv-voice"
    ],
    [
        "hvs",
        "application/vnd.yamaha.hv-script"
    ],
    [
        "i2g",
        "application/vnd.intergeo"
    ],
    [
        "icc",
        "application/vnd.iccprofile"
    ],
    [
        "ice",
        "x-conference/x-cooltalk"
    ],
    [
        "ico",
        "image/x-icon"
    ],
    [
        "ics",
        "text/calendar"
    ],
    [
        "idc",
        "text/plain"
    ],
    [
        "ief",
        "image/ief"
    ],
    [
        "iefs",
        "image/ief"
    ],
    [
        "ifm",
        "application/vnd.shana.informed.formdata"
    ],
    [
        "iges",
        [
            "application/iges",
            "model/iges"
        ]
    ],
    [
        "igl",
        "application/vnd.igloader"
    ],
    [
        "igm",
        "application/vnd.insors.igm"
    ],
    [
        "igs",
        [
            "application/iges",
            "model/iges"
        ]
    ],
    [
        "igx",
        "application/vnd.micrografx.igx"
    ],
    [
        "iif",
        "application/vnd.shana.informed.interchange"
    ],
    [
        "iii",
        "application/x-iphone"
    ],
    [
        "ima",
        "application/x-ima"
    ],
    [
        "imap",
        "application/x-httpd-imap"
    ],
    [
        "imp",
        "application/vnd.accpac.simply.imp"
    ],
    [
        "ims",
        "application/vnd.ms-ims"
    ],
    [
        "inf",
        "application/inf"
    ],
    [
        "ins",
        [
            "application/x-internet-signup",
            "application/x-internett-signup"
        ]
    ],
    [
        "ip",
        "application/x-ip2"
    ],
    [
        "ipfix",
        "application/ipfix"
    ],
    [
        "ipk",
        "application/vnd.shana.informed.package"
    ],
    [
        "irm",
        "application/vnd.ibm.rights-management"
    ],
    [
        "irp",
        "application/vnd.irepository.package+xml"
    ],
    [
        "isp",
        "application/x-internet-signup"
    ],
    [
        "isu",
        "video/x-isvideo"
    ],
    [
        "it",
        "audio/it"
    ],
    [
        "itp",
        "application/vnd.shana.informed.formtemplate"
    ],
    [
        "iv",
        "application/x-inventor"
    ],
    [
        "ivp",
        "application/vnd.immervision-ivp"
    ],
    [
        "ivr",
        "i-world/i-vrml"
    ],
    [
        "ivu",
        "application/vnd.immervision-ivu"
    ],
    [
        "ivy",
        "application/x-livescreen"
    ],
    [
        "jad",
        "text/vnd.sun.j2me.app-descriptor"
    ],
    [
        "jam",
        [
            "application/vnd.jam",
            "audio/x-jam"
        ]
    ],
    [
        "jar",
        "application/java-archive"
    ],
    [
        "jav",
        [
            "text/plain",
            "text/x-java-source"
        ]
    ],
    [
        "java",
        [
            "text/plain",
            "text/x-java-source,java",
            "text/x-java-source"
        ]
    ],
    [
        "jcm",
        "application/x-java-commerce"
    ],
    [
        "jfif",
        [
            "image/pipeg",
            "image/jpeg",
            "image/pjpeg"
        ]
    ],
    [
        "jfif-tbnl",
        "image/jpeg"
    ],
    [
        "jisp",
        "application/vnd.jisp"
    ],
    [
        "jlt",
        "application/vnd.hp-jlyt"
    ],
    [
        "jnlp",
        "application/x-java-jnlp-file"
    ],
    [
        "joda",
        "application/vnd.joost.joda-archive"
    ],
    [
        "jpe",
        [
            "image/jpeg",
            "image/pjpeg"
        ]
    ],
    [
        "jpeg",
        [
            "image/jpeg",
            "image/pjpeg"
        ]
    ],
    [
        "jpg",
        [
            "image/jpeg",
            "image/pjpeg"
        ]
    ],
    [
        "jpgv",
        "video/jpeg"
    ],
    [
        "jpm",
        "video/jpm"
    ],
    [
        "jps",
        "image/x-jps"
    ],
    [
        "js",
        [
            "application/javascript",
            "application/ecmascript",
            "text/javascript",
            "text/ecmascript",
            "application/x-javascript"
        ]
    ],
    [
        "json",
        "application/json"
    ],
    [
        "jut",
        "image/jutvision"
    ],
    [
        "kar",
        [
            "audio/midi",
            "music/x-karaoke"
        ]
    ],
    [
        "karbon",
        "application/vnd.kde.karbon"
    ],
    [
        "kfo",
        "application/vnd.kde.kformula"
    ],
    [
        "kia",
        "application/vnd.kidspiration"
    ],
    [
        "kml",
        "application/vnd.google-earth.kml+xml"
    ],
    [
        "kmz",
        "application/vnd.google-earth.kmz"
    ],
    [
        "kne",
        "application/vnd.kinar"
    ],
    [
        "kon",
        "application/vnd.kde.kontour"
    ],
    [
        "kpr",
        "application/vnd.kde.kpresenter"
    ],
    [
        "ksh",
        [
            "application/x-ksh",
            "text/x-script.ksh"
        ]
    ],
    [
        "ksp",
        "application/vnd.kde.kspread"
    ],
    [
        "ktx",
        "image/ktx"
    ],
    [
        "ktz",
        "application/vnd.kahootz"
    ],
    [
        "kwd",
        "application/vnd.kde.kword"
    ],
    [
        "la",
        [
            "audio/nspaudio",
            "audio/x-nspaudio"
        ]
    ],
    [
        "lam",
        "audio/x-liveaudio"
    ],
    [
        "lasxml",
        "application/vnd.las.las+xml"
    ],
    [
        "latex",
        "application/x-latex"
    ],
    [
        "lbd",
        "application/vnd.llamagraphics.life-balance.desktop"
    ],
    [
        "lbe",
        "application/vnd.llamagraphics.life-balance.exchange+xml"
    ],
    [
        "les",
        "application/vnd.hhe.lesson-player"
    ],
    [
        "lha",
        [
            "application/octet-stream",
            "application/lha",
            "application/x-lha"
        ]
    ],
    [
        "lhx",
        "application/octet-stream"
    ],
    [
        "link66",
        "application/vnd.route66.link66+xml"
    ],
    [
        "list",
        "text/plain"
    ],
    [
        "lma",
        [
            "audio/nspaudio",
            "audio/x-nspaudio"
        ]
    ],
    [
        "log",
        "text/plain"
    ],
    [
        "lrm",
        "application/vnd.ms-lrm"
    ],
    [
        "lsf",
        "video/x-la-asf"
    ],
    [
        "lsp",
        [
            "application/x-lisp",
            "text/x-script.lisp"
        ]
    ],
    [
        "lst",
        "text/plain"
    ],
    [
        "lsx",
        [
            "video/x-la-asf",
            "text/x-la-asf"
        ]
    ],
    [
        "ltf",
        "application/vnd.frogans.ltf"
    ],
    [
        "ltx",
        "application/x-latex"
    ],
    [
        "lvp",
        "audio/vnd.lucent.voice"
    ],
    [
        "lwp",
        "application/vnd.lotus-wordpro"
    ],
    [
        "lzh",
        [
            "application/octet-stream",
            "application/x-lzh"
        ]
    ],
    [
        "lzx",
        [
            "application/lzx",
            "application/octet-stream",
            "application/x-lzx"
        ]
    ],
    [
        "m",
        [
            "text/plain",
            "text/x-m"
        ]
    ],
    [
        "m13",
        "application/x-msmediaview"
    ],
    [
        "m14",
        "application/x-msmediaview"
    ],
    [
        "m1v",
        "video/mpeg"
    ],
    [
        "m21",
        "application/mp21"
    ],
    [
        "m2a",
        "audio/mpeg"
    ],
    [
        "m2v",
        "video/mpeg"
    ],
    [
        "m3u",
        [
            "audio/x-mpegurl",
            "audio/x-mpequrl"
        ]
    ],
    [
        "m3u8",
        "application/vnd.apple.mpegurl"
    ],
    [
        "m4v",
        "video/x-m4v"
    ],
    [
        "ma",
        "application/mathematica"
    ],
    [
        "mads",
        "application/mads+xml"
    ],
    [
        "mag",
        "application/vnd.ecowin.chart"
    ],
    [
        "man",
        "application/x-troff-man"
    ],
    [
        "map",
        "application/x-navimap"
    ],
    [
        "mar",
        "text/plain"
    ],
    [
        "mathml",
        "application/mathml+xml"
    ],
    [
        "mbd",
        "application/mbedlet"
    ],
    [
        "mbk",
        "application/vnd.mobius.mbk"
    ],
    [
        "mbox",
        "application/mbox"
    ],
    [
        "mc$",
        "application/x-magic-cap-package-1.0"
    ],
    [
        "mc1",
        "application/vnd.medcalcdata"
    ],
    [
        "mcd",
        [
            "application/mcad",
            "application/vnd.mcd",
            "application/x-mathcad"
        ]
    ],
    [
        "mcf",
        [
            "image/vasa",
            "text/mcf"
        ]
    ],
    [
        "mcp",
        "application/netmc"
    ],
    [
        "mcurl",
        "text/vnd.curl.mcurl"
    ],
    [
        "mdb",
        "application/x-msaccess"
    ],
    [
        "mdi",
        "image/vnd.ms-modi"
    ],
    [
        "me",
        "application/x-troff-me"
    ],
    [
        "meta4",
        "application/metalink4+xml"
    ],
    [
        "mets",
        "application/mets+xml"
    ],
    [
        "mfm",
        "application/vnd.mfmp"
    ],
    [
        "mgp",
        "application/vnd.osgeo.mapguide.package"
    ],
    [
        "mgz",
        "application/vnd.proteus.magazine"
    ],
    [
        "mht",
        "message/rfc822"
    ],
    [
        "mhtml",
        "message/rfc822"
    ],
    [
        "mid",
        [
            "audio/mid",
            "audio/midi",
            "music/crescendo",
            "x-music/x-midi",
            "audio/x-midi",
            "application/x-midi",
            "audio/x-mid"
        ]
    ],
    [
        "midi",
        [
            "audio/midi",
            "music/crescendo",
            "x-music/x-midi",
            "audio/x-midi",
            "application/x-midi",
            "audio/x-mid"
        ]
    ],
    [
        "mif",
        [
            "application/vnd.mif",
            "application/x-mif",
            "application/x-frame"
        ]
    ],
    [
        "mime",
        [
            "message/rfc822",
            "www/mime"
        ]
    ],
    [
        "mj2",
        "video/mj2"
    ],
    [
        "mjf",
        "audio/x-vnd.audioexplosion.mjuicemediafile"
    ],
    [
        "mjpg",
        "video/x-motion-jpeg"
    ],
    [
        "mlp",
        "application/vnd.dolby.mlp"
    ],
    [
        "mm",
        [
            "application/base64",
            "application/x-meme"
        ]
    ],
    [
        "mmd",
        "application/vnd.chipnuts.karaoke-mmd"
    ],
    [
        "mme",
        "application/base64"
    ],
    [
        "mmf",
        "application/vnd.smaf"
    ],
    [
        "mmr",
        "image/vnd.fujixerox.edmics-mmr"
    ],
    [
        "mny",
        "application/x-msmoney"
    ],
    [
        "mod",
        [
            "audio/mod",
            "audio/x-mod"
        ]
    ],
    [
        "mods",
        "application/mods+xml"
    ],
    [
        "moov",
        "video/quicktime"
    ],
    [
        "mov",
        "video/quicktime"
    ],
    [
        "movie",
        "video/x-sgi-movie"
    ],
    [
        "mp2",
        [
            "video/mpeg",
            "audio/mpeg",
            "video/x-mpeg",
            "audio/x-mpeg",
            "video/x-mpeq2a"
        ]
    ],
    [
        "mp3",
        [
            "audio/mpeg",
            "audio/mpeg3",
            "video/mpeg",
            "audio/x-mpeg-3",
            "video/x-mpeg"
        ]
    ],
    [
        "mp4",
        [
            "video/mp4",
            "application/mp4"
        ]
    ],
    [
        "mp4a",
        "audio/mp4"
    ],
    [
        "mpa",
        [
            "video/mpeg",
            "audio/mpeg"
        ]
    ],
    [
        "mpc",
        [
            "application/vnd.mophun.certificate",
            "application/x-project"
        ]
    ],
    [
        "mpe",
        "video/mpeg"
    ],
    [
        "mpeg",
        "video/mpeg"
    ],
    [
        "mpg",
        [
            "video/mpeg",
            "audio/mpeg"
        ]
    ],
    [
        "mpga",
        "audio/mpeg"
    ],
    [
        "mpkg",
        "application/vnd.apple.installer+xml"
    ],
    [
        "mpm",
        "application/vnd.blueice.multipass"
    ],
    [
        "mpn",
        "application/vnd.mophun.application"
    ],
    [
        "mpp",
        "application/vnd.ms-project"
    ],
    [
        "mpt",
        "application/x-project"
    ],
    [
        "mpv",
        "application/x-project"
    ],
    [
        "mpv2",
        "video/mpeg"
    ],
    [
        "mpx",
        "application/x-project"
    ],
    [
        "mpy",
        "application/vnd.ibm.minipay"
    ],
    [
        "mqy",
        "application/vnd.mobius.mqy"
    ],
    [
        "mrc",
        "application/marc"
    ],
    [
        "mrcx",
        "application/marcxml+xml"
    ],
    [
        "ms",
        "application/x-troff-ms"
    ],
    [
        "mscml",
        "application/mediaservercontrol+xml"
    ],
    [
        "mseq",
        "application/vnd.mseq"
    ],
    [
        "msf",
        "application/vnd.epson.msf"
    ],
    [
        "msg",
        "application/vnd.ms-outlook"
    ],
    [
        "msh",
        "model/mesh"
    ],
    [
        "msl",
        "application/vnd.mobius.msl"
    ],
    [
        "msty",
        "application/vnd.muvee.style"
    ],
    [
        "mts",
        "model/vnd.mts"
    ],
    [
        "mus",
        "application/vnd.musician"
    ],
    [
        "musicxml",
        "application/vnd.recordare.musicxml+xml"
    ],
    [
        "mv",
        "video/x-sgi-movie"
    ],
    [
        "mvb",
        "application/x-msmediaview"
    ],
    [
        "mwf",
        "application/vnd.mfer"
    ],
    [
        "mxf",
        "application/mxf"
    ],
    [
        "mxl",
        "application/vnd.recordare.musicxml"
    ],
    [
        "mxml",
        "application/xv+xml"
    ],
    [
        "mxs",
        "application/vnd.triscape.mxs"
    ],
    [
        "mxu",
        "video/vnd.mpegurl"
    ],
    [
        "my",
        "audio/make"
    ],
    [
        "mzz",
        "application/x-vnd.audioexplosion.mzz"
    ],
    [
        "n-gage",
        "application/vnd.nokia.n-gage.symbian.install"
    ],
    [
        "n3",
        "text/n3"
    ],
    [
        "nap",
        "image/naplps"
    ],
    [
        "naplps",
        "image/naplps"
    ],
    [
        "nbp",
        "application/vnd.wolfram.player"
    ],
    [
        "nc",
        "application/x-netcdf"
    ],
    [
        "ncm",
        "application/vnd.nokia.configuration-message"
    ],
    [
        "ncx",
        "application/x-dtbncx+xml"
    ],
    [
        "ngdat",
        "application/vnd.nokia.n-gage.data"
    ],
    [
        "nif",
        "image/x-niff"
    ],
    [
        "niff",
        "image/x-niff"
    ],
    [
        "nix",
        "application/x-mix-transfer"
    ],
    [
        "nlu",
        "application/vnd.neurolanguage.nlu"
    ],
    [
        "nml",
        "application/vnd.enliven"
    ],
    [
        "nnd",
        "application/vnd.noblenet-directory"
    ],
    [
        "nns",
        "application/vnd.noblenet-sealer"
    ],
    [
        "nnw",
        "application/vnd.noblenet-web"
    ],
    [
        "npx",
        "image/vnd.net-fpx"
    ],
    [
        "nsc",
        "application/x-conference"
    ],
    [
        "nsf",
        "application/vnd.lotus-notes"
    ],
    [
        "nvd",
        "application/x-navidoc"
    ],
    [
        "nws",
        "message/rfc822"
    ],
    [
        "o",
        "application/octet-stream"
    ],
    [
        "oa2",
        "application/vnd.fujitsu.oasys2"
    ],
    [
        "oa3",
        "application/vnd.fujitsu.oasys3"
    ],
    [
        "oas",
        "application/vnd.fujitsu.oasys"
    ],
    [
        "obd",
        "application/x-msbinder"
    ],
    [
        "oda",
        "application/oda"
    ],
    [
        "odb",
        "application/vnd.oasis.opendocument.database"
    ],
    [
        "odc",
        "application/vnd.oasis.opendocument.chart"
    ],
    [
        "odf",
        "application/vnd.oasis.opendocument.formula"
    ],
    [
        "odft",
        "application/vnd.oasis.opendocument.formula-template"
    ],
    [
        "odg",
        "application/vnd.oasis.opendocument.graphics"
    ],
    [
        "odi",
        "application/vnd.oasis.opendocument.image"
    ],
    [
        "odm",
        "application/vnd.oasis.opendocument.text-master"
    ],
    [
        "odp",
        "application/vnd.oasis.opendocument.presentation"
    ],
    [
        "ods",
        "application/vnd.oasis.opendocument.spreadsheet"
    ],
    [
        "odt",
        "application/vnd.oasis.opendocument.text"
    ],
    [
        "oga",
        "audio/ogg"
    ],
    [
        "ogv",
        "video/ogg"
    ],
    [
        "ogx",
        "application/ogg"
    ],
    [
        "omc",
        "application/x-omc"
    ],
    [
        "omcd",
        "application/x-omcdatamaker"
    ],
    [
        "omcr",
        "application/x-omcregerator"
    ],
    [
        "onetoc",
        "application/onenote"
    ],
    [
        "opf",
        "application/oebps-package+xml"
    ],
    [
        "org",
        "application/vnd.lotus-organizer"
    ],
    [
        "osf",
        "application/vnd.yamaha.openscoreformat"
    ],
    [
        "osfpvg",
        "application/vnd.yamaha.openscoreformat.osfpvg+xml"
    ],
    [
        "otc",
        "application/vnd.oasis.opendocument.chart-template"
    ],
    [
        "otf",
        "application/x-font-otf"
    ],
    [
        "otg",
        "application/vnd.oasis.opendocument.graphics-template"
    ],
    [
        "oth",
        "application/vnd.oasis.opendocument.text-web"
    ],
    [
        "oti",
        "application/vnd.oasis.opendocument.image-template"
    ],
    [
        "otp",
        "application/vnd.oasis.opendocument.presentation-template"
    ],
    [
        "ots",
        "application/vnd.oasis.opendocument.spreadsheet-template"
    ],
    [
        "ott",
        "application/vnd.oasis.opendocument.text-template"
    ],
    [
        "oxt",
        "application/vnd.openofficeorg.extension"
    ],
    [
        "p",
        "text/x-pascal"
    ],
    [
        "p10",
        [
            "application/pkcs10",
            "application/x-pkcs10"
        ]
    ],
    [
        "p12",
        [
            "application/pkcs-12",
            "application/x-pkcs12"
        ]
    ],
    [
        "p7a",
        "application/x-pkcs7-signature"
    ],
    [
        "p7b",
        "application/x-pkcs7-certificates"
    ],
    [
        "p7c",
        [
            "application/pkcs7-mime",
            "application/x-pkcs7-mime"
        ]
    ],
    [
        "p7m",
        [
            "application/pkcs7-mime",
            "application/x-pkcs7-mime"
        ]
    ],
    [
        "p7r",
        "application/x-pkcs7-certreqresp"
    ],
    [
        "p7s",
        [
            "application/pkcs7-signature",
            "application/x-pkcs7-signature"
        ]
    ],
    [
        "p8",
        "application/pkcs8"
    ],
    [
        "par",
        "text/plain-bas"
    ],
    [
        "part",
        "application/pro_eng"
    ],
    [
        "pas",
        "text/pascal"
    ],
    [
        "paw",
        "application/vnd.pawaafile"
    ],
    [
        "pbd",
        "application/vnd.powerbuilder6"
    ],
    [
        "pbm",
        "image/x-portable-bitmap"
    ],
    [
        "pcf",
        "application/x-font-pcf"
    ],
    [
        "pcl",
        [
            "application/vnd.hp-pcl",
            "application/x-pcl"
        ]
    ],
    [
        "pclxl",
        "application/vnd.hp-pclxl"
    ],
    [
        "pct",
        "image/x-pict"
    ],
    [
        "pcurl",
        "application/vnd.curl.pcurl"
    ],
    [
        "pcx",
        "image/x-pcx"
    ],
    [
        "pdb",
        [
            "application/vnd.palm",
            "chemical/x-pdb"
        ]
    ],
    [
        "pdf",
        "application/pdf"
    ],
    [
        "pfa",
        "application/x-font-type1"
    ],
    [
        "pfr",
        "application/font-tdpfr"
    ],
    [
        "pfunk",
        [
            "audio/make",
            "audio/make.my.funk"
        ]
    ],
    [
        "pfx",
        "application/x-pkcs12"
    ],
    [
        "pgm",
        [
            "image/x-portable-graymap",
            "image/x-portable-greymap"
        ]
    ],
    [
        "pgn",
        "application/x-chess-pgn"
    ],
    [
        "pgp",
        "application/pgp-signature"
    ],
    [
        "pic",
        [
            "image/pict",
            "image/x-pict"
        ]
    ],
    [
        "pict",
        "image/pict"
    ],
    [
        "pkg",
        "application/x-newton-compatible-pkg"
    ],
    [
        "pki",
        "application/pkixcmp"
    ],
    [
        "pkipath",
        "application/pkix-pkipath"
    ],
    [
        "pko",
        [
            "application/ynd.ms-pkipko",
            "application/vnd.ms-pki.pko"
        ]
    ],
    [
        "pl",
        [
            "text/plain",
            "text/x-script.perl"
        ]
    ],
    [
        "plb",
        "application/vnd.3gpp.pic-bw-large"
    ],
    [
        "plc",
        "application/vnd.mobius.plc"
    ],
    [
        "plf",
        "application/vnd.pocketlearn"
    ],
    [
        "pls",
        "application/pls+xml"
    ],
    [
        "plx",
        "application/x-pixclscript"
    ],
    [
        "pm",
        [
            "text/x-script.perl-module",
            "image/x-xpixmap"
        ]
    ],
    [
        "pm4",
        "application/x-pagemaker"
    ],
    [
        "pm5",
        "application/x-pagemaker"
    ],
    [
        "pma",
        "application/x-perfmon"
    ],
    [
        "pmc",
        "application/x-perfmon"
    ],
    [
        "pml",
        [
            "application/vnd.ctc-posml",
            "application/x-perfmon"
        ]
    ],
    [
        "pmr",
        "application/x-perfmon"
    ],
    [
        "pmw",
        "application/x-perfmon"
    ],
    [
        "png",
        "image/png"
    ],
    [
        "pnm",
        [
            "application/x-portable-anymap",
            "image/x-portable-anymap"
        ]
    ],
    [
        "portpkg",
        "application/vnd.macports.portpkg"
    ],
    [
        "pot",
        [
            "application/vnd.ms-powerpoint",
            "application/mspowerpoint"
        ]
    ],
    [
        "potm",
        "application/vnd.ms-powerpoint.template.macroenabled.12"
    ],
    [
        "potx",
        "application/vnd.openxmlformats-officedocument.presentationml.template"
    ],
    [
        "pov",
        "model/x-pov"
    ],
    [
        "ppa",
        "application/vnd.ms-powerpoint"
    ],
    [
        "ppam",
        "application/vnd.ms-powerpoint.addin.macroenabled.12"
    ],
    [
        "ppd",
        "application/vnd.cups-ppd"
    ],
    [
        "ppm",
        "image/x-portable-pixmap"
    ],
    [
        "pps",
        [
            "application/vnd.ms-powerpoint",
            "application/mspowerpoint"
        ]
    ],
    [
        "ppsm",
        "application/vnd.ms-powerpoint.slideshow.macroenabled.12"
    ],
    [
        "ppsx",
        "application/vnd.openxmlformats-officedocument.presentationml.slideshow"
    ],
    [
        "ppt",
        [
            "application/vnd.ms-powerpoint",
            "application/mspowerpoint",
            "application/powerpoint",
            "application/x-mspowerpoint"
        ]
    ],
    [
        "pptm",
        "application/vnd.ms-powerpoint.presentation.macroenabled.12"
    ],
    [
        "pptx",
        "application/vnd.openxmlformats-officedocument.presentationml.presentation"
    ],
    [
        "ppz",
        "application/mspowerpoint"
    ],
    [
        "prc",
        "application/x-mobipocket-ebook"
    ],
    [
        "pre",
        [
            "application/vnd.lotus-freelance",
            "application/x-freelance"
        ]
    ],
    [
        "prf",
        "application/pics-rules"
    ],
    [
        "prt",
        "application/pro_eng"
    ],
    [
        "ps",
        "application/postscript"
    ],
    [
        "psb",
        "application/vnd.3gpp.pic-bw-small"
    ],
    [
        "psd",
        [
            "application/octet-stream",
            "image/vnd.adobe.photoshop"
        ]
    ],
    [
        "psf",
        "application/x-font-linux-psf"
    ],
    [
        "pskcxml",
        "application/pskc+xml"
    ],
    [
        "ptid",
        "application/vnd.pvi.ptid1"
    ],
    [
        "pub",
        "application/x-mspublisher"
    ],
    [
        "pvb",
        "application/vnd.3gpp.pic-bw-var"
    ],
    [
        "pvu",
        "paleovu/x-pv"
    ],
    [
        "pwn",
        "application/vnd.3m.post-it-notes"
    ],
    [
        "pwz",
        "application/vnd.ms-powerpoint"
    ],
    [
        "py",
        "text/x-script.phyton"
    ],
    [
        "pya",
        "audio/vnd.ms-playready.media.pya"
    ],
    [
        "pyc",
        "application/x-bytecode.python"
    ],
    [
        "pyv",
        "video/vnd.ms-playready.media.pyv"
    ],
    [
        "qam",
        "application/vnd.epson.quickanime"
    ],
    [
        "qbo",
        "application/vnd.intu.qbo"
    ],
    [
        "qcp",
        "audio/vnd.qcelp"
    ],
    [
        "qd3",
        "x-world/x-3dmf"
    ],
    [
        "qd3d",
        "x-world/x-3dmf"
    ],
    [
        "qfx",
        "application/vnd.intu.qfx"
    ],
    [
        "qif",
        "image/x-quicktime"
    ],
    [
        "qps",
        "application/vnd.publishare-delta-tree"
    ],
    [
        "qt",
        "video/quicktime"
    ],
    [
        "qtc",
        "video/x-qtc"
    ],
    [
        "qti",
        "image/x-quicktime"
    ],
    [
        "qtif",
        "image/x-quicktime"
    ],
    [
        "qxd",
        "application/vnd.quark.quarkxpress"
    ],
    [
        "ra",
        [
            "audio/x-realaudio",
            "audio/x-pn-realaudio",
            "audio/x-pn-realaudio-plugin"
        ]
    ],
    [
        "ram",
        "audio/x-pn-realaudio"
    ],
    [
        "rar",
        "application/x-rar-compressed"
    ],
    [
        "ras",
        [
            "image/cmu-raster",
            "application/x-cmu-raster",
            "image/x-cmu-raster"
        ]
    ],
    [
        "rast",
        "image/cmu-raster"
    ],
    [
        "rcprofile",
        "application/vnd.ipunplugged.rcprofile"
    ],
    [
        "rdf",
        "application/rdf+xml"
    ],
    [
        "rdz",
        "application/vnd.data-vision.rdz"
    ],
    [
        "rep",
        "application/vnd.businessobjects"
    ],
    [
        "res",
        "application/x-dtbresource+xml"
    ],
    [
        "rexx",
        "text/x-script.rexx"
    ],
    [
        "rf",
        "image/vnd.rn-realflash"
    ],
    [
        "rgb",
        "image/x-rgb"
    ],
    [
        "rif",
        "application/reginfo+xml"
    ],
    [
        "rip",
        "audio/vnd.rip"
    ],
    [
        "rl",
        "application/resource-lists+xml"
    ],
    [
        "rlc",
        "image/vnd.fujixerox.edmics-rlc"
    ],
    [
        "rld",
        "application/resource-lists-diff+xml"
    ],
    [
        "rm",
        [
            "application/vnd.rn-realmedia",
            "audio/x-pn-realaudio"
        ]
    ],
    [
        "rmi",
        "audio/mid"
    ],
    [
        "rmm",
        "audio/x-pn-realaudio"
    ],
    [
        "rmp",
        [
            "audio/x-pn-realaudio-plugin",
            "audio/x-pn-realaudio"
        ]
    ],
    [
        "rms",
        "application/vnd.jcp.javame.midlet-rms"
    ],
    [
        "rnc",
        "application/relax-ng-compact-syntax"
    ],
    [
        "rng",
        [
            "application/ringing-tones",
            "application/vnd.nokia.ringing-tone"
        ]
    ],
    [
        "rnx",
        "application/vnd.rn-realplayer"
    ],
    [
        "roff",
        "application/x-troff"
    ],
    [
        "rp",
        "image/vnd.rn-realpix"
    ],
    [
        "rp9",
        "application/vnd.cloanto.rp9"
    ],
    [
        "rpm",
        "audio/x-pn-realaudio-plugin"
    ],
    [
        "rpss",
        "application/vnd.nokia.radio-presets"
    ],
    [
        "rpst",
        "application/vnd.nokia.radio-preset"
    ],
    [
        "rq",
        "application/sparql-query"
    ],
    [
        "rs",
        "application/rls-services+xml"
    ],
    [
        "rsd",
        "application/rsd+xml"
    ],
    [
        "rt",
        [
            "text/richtext",
            "text/vnd.rn-realtext"
        ]
    ],
    [
        "rtf",
        [
            "application/rtf",
            "text/richtext",
            "application/x-rtf"
        ]
    ],
    [
        "rtx",
        [
            "text/richtext",
            "application/rtf"
        ]
    ],
    [
        "rv",
        "video/vnd.rn-realvideo"
    ],
    [
        "s",
        "text/x-asm"
    ],
    [
        "s3m",
        "audio/s3m"
    ],
    [
        "saf",
        "application/vnd.yamaha.smaf-audio"
    ],
    [
        "saveme",
        "application/octet-stream"
    ],
    [
        "sbk",
        "application/x-tbook"
    ],
    [
        "sbml",
        "application/sbml+xml"
    ],
    [
        "sc",
        "application/vnd.ibm.secure-container"
    ],
    [
        "scd",
        "application/x-msschedule"
    ],
    [
        "scm",
        [
            "application/vnd.lotus-screencam",
            "video/x-scm",
            "text/x-script.guile",
            "application/x-lotusscreencam",
            "text/x-script.scheme"
        ]
    ],
    [
        "scq",
        "application/scvp-cv-request"
    ],
    [
        "scs",
        "application/scvp-cv-response"
    ],
    [
        "sct",
        "text/scriptlet"
    ],
    [
        "scurl",
        "text/vnd.curl.scurl"
    ],
    [
        "sda",
        "application/vnd.stardivision.draw"
    ],
    [
        "sdc",
        "application/vnd.stardivision.calc"
    ],
    [
        "sdd",
        "application/vnd.stardivision.impress"
    ],
    [
        "sdkm",
        "application/vnd.solent.sdkm+xml"
    ],
    [
        "sdml",
        "text/plain"
    ],
    [
        "sdp",
        [
            "application/sdp",
            "application/x-sdp"
        ]
    ],
    [
        "sdr",
        "application/sounder"
    ],
    [
        "sdw",
        "application/vnd.stardivision.writer"
    ],
    [
        "sea",
        [
            "application/sea",
            "application/x-sea"
        ]
    ],
    [
        "see",
        "application/vnd.seemail"
    ],
    [
        "seed",
        "application/vnd.fdsn.seed"
    ],
    [
        "sema",
        "application/vnd.sema"
    ],
    [
        "semd",
        "application/vnd.semd"
    ],
    [
        "semf",
        "application/vnd.semf"
    ],
    [
        "ser",
        "application/java-serialized-object"
    ],
    [
        "set",
        "application/set"
    ],
    [
        "setpay",
        "application/set-payment-initiation"
    ],
    [
        "setreg",
        "application/set-registration-initiation"
    ],
    [
        "sfd-hdstx",
        "application/vnd.hydrostatix.sof-data"
    ],
    [
        "sfs",
        "application/vnd.spotfire.sfs"
    ],
    [
        "sgl",
        "application/vnd.stardivision.writer-global"
    ],
    [
        "sgm",
        [
            "text/sgml",
            "text/x-sgml"
        ]
    ],
    [
        "sgml",
        [
            "text/sgml",
            "text/x-sgml"
        ]
    ],
    [
        "sh",
        [
            "application/x-shar",
            "application/x-bsh",
            "application/x-sh",
            "text/x-script.sh"
        ]
    ],
    [
        "shar",
        [
            "application/x-bsh",
            "application/x-shar"
        ]
    ],
    [
        "shf",
        "application/shf+xml"
    ],
    [
        "shtml",
        [
            "text/html",
            "text/x-server-parsed-html"
        ]
    ],
    [
        "sid",
        "audio/x-psid"
    ],
    [
        "sis",
        "application/vnd.symbian.install"
    ],
    [
        "sit",
        [
            "application/x-stuffit",
            "application/x-sit"
        ]
    ],
    [
        "sitx",
        "application/x-stuffitx"
    ],
    [
        "skd",
        "application/x-koan"
    ],
    [
        "skm",
        "application/x-koan"
    ],
    [
        "skp",
        [
            "application/vnd.koan",
            "application/x-koan"
        ]
    ],
    [
        "skt",
        "application/x-koan"
    ],
    [
        "sl",
        "application/x-seelogo"
    ],
    [
        "sldm",
        "application/vnd.ms-powerpoint.slide.macroenabled.12"
    ],
    [
        "sldx",
        "application/vnd.openxmlformats-officedocument.presentationml.slide"
    ],
    [
        "slt",
        "application/vnd.epson.salt"
    ],
    [
        "sm",
        "application/vnd.stepmania.stepchart"
    ],
    [
        "smf",
        "application/vnd.stardivision.math"
    ],
    [
        "smi",
        [
            "application/smil",
            "application/smil+xml"
        ]
    ],
    [
        "smil",
        "application/smil"
    ],
    [
        "snd",
        [
            "audio/basic",
            "audio/x-adpcm"
        ]
    ],
    [
        "snf",
        "application/x-font-snf"
    ],
    [
        "sol",
        "application/solids"
    ],
    [
        "spc",
        [
            "text/x-speech",
            "application/x-pkcs7-certificates"
        ]
    ],
    [
        "spf",
        "application/vnd.yamaha.smaf-phrase"
    ],
    [
        "spl",
        [
            "application/futuresplash",
            "application/x-futuresplash"
        ]
    ],
    [
        "spot",
        "text/vnd.in3d.spot"
    ],
    [
        "spp",
        "application/scvp-vp-response"
    ],
    [
        "spq",
        "application/scvp-vp-request"
    ],
    [
        "spr",
        "application/x-sprite"
    ],
    [
        "sprite",
        "application/x-sprite"
    ],
    [
        "src",
        "application/x-wais-source"
    ],
    [
        "sru",
        "application/sru+xml"
    ],
    [
        "srx",
        "application/sparql-results+xml"
    ],
    [
        "sse",
        "application/vnd.kodak-descriptor"
    ],
    [
        "ssf",
        "application/vnd.epson.ssf"
    ],
    [
        "ssi",
        "text/x-server-parsed-html"
    ],
    [
        "ssm",
        "application/streamingmedia"
    ],
    [
        "ssml",
        "application/ssml+xml"
    ],
    [
        "sst",
        [
            "application/vnd.ms-pkicertstore",
            "application/vnd.ms-pki.certstore"
        ]
    ],
    [
        "st",
        "application/vnd.sailingtracker.track"
    ],
    [
        "stc",
        "application/vnd.sun.xml.calc.template"
    ],
    [
        "std",
        "application/vnd.sun.xml.draw.template"
    ],
    [
        "step",
        "application/step"
    ],
    [
        "stf",
        "application/vnd.wt.stf"
    ],
    [
        "sti",
        "application/vnd.sun.xml.impress.template"
    ],
    [
        "stk",
        "application/hyperstudio"
    ],
    [
        "stl",
        [
            "application/vnd.ms-pkistl",
            "application/sla",
            "application/vnd.ms-pki.stl",
            "application/x-navistyle"
        ]
    ],
    [
        "stm",
        "text/html"
    ],
    [
        "stp",
        "application/step"
    ],
    [
        "str",
        "application/vnd.pg.format"
    ],
    [
        "stw",
        "application/vnd.sun.xml.writer.template"
    ],
    [
        "sub",
        "image/vnd.dvb.subtitle"
    ],
    [
        "sus",
        "application/vnd.sus-calendar"
    ],
    [
        "sv4cpio",
        "application/x-sv4cpio"
    ],
    [
        "sv4crc",
        "application/x-sv4crc"
    ],
    [
        "svc",
        "application/vnd.dvb.service"
    ],
    [
        "svd",
        "application/vnd.svd"
    ],
    [
        "svf",
        [
            "image/vnd.dwg",
            "image/x-dwg"
        ]
    ],
    [
        "svg",
        "image/svg+xml"
    ],
    [
        "svr",
        [
            "x-world/x-svr",
            "application/x-world"
        ]
    ],
    [
        "swf",
        "application/x-shockwave-flash"
    ],
    [
        "swi",
        "application/vnd.aristanetworks.swi"
    ],
    [
        "sxc",
        "application/vnd.sun.xml.calc"
    ],
    [
        "sxd",
        "application/vnd.sun.xml.draw"
    ],
    [
        "sxg",
        "application/vnd.sun.xml.writer.global"
    ],
    [
        "sxi",
        "application/vnd.sun.xml.impress"
    ],
    [
        "sxm",
        "application/vnd.sun.xml.math"
    ],
    [
        "sxw",
        "application/vnd.sun.xml.writer"
    ],
    [
        "t",
        [
            "text/troff",
            "application/x-troff"
        ]
    ],
    [
        "talk",
        "text/x-speech"
    ],
    [
        "tao",
        "application/vnd.tao.intent-module-archive"
    ],
    [
        "tar",
        "application/x-tar"
    ],
    [
        "tbk",
        [
            "application/toolbook",
            "application/x-tbook"
        ]
    ],
    [
        "tcap",
        "application/vnd.3gpp2.tcap"
    ],
    [
        "tcl",
        [
            "text/x-script.tcl",
            "application/x-tcl"
        ]
    ],
    [
        "tcsh",
        "text/x-script.tcsh"
    ],
    [
        "teacher",
        "application/vnd.smart.teacher"
    ],
    [
        "tei",
        "application/tei+xml"
    ],
    [
        "tex",
        "application/x-tex"
    ],
    [
        "texi",
        "application/x-texinfo"
    ],
    [
        "texinfo",
        "application/x-texinfo"
    ],
    [
        "text",
        [
            "application/plain",
            "text/plain"
        ]
    ],
    [
        "tfi",
        "application/thraud+xml"
    ],
    [
        "tfm",
        "application/x-tex-tfm"
    ],
    [
        "tgz",
        [
            "application/gnutar",
            "application/x-compressed"
        ]
    ],
    [
        "thmx",
        "application/vnd.ms-officetheme"
    ],
    [
        "tif",
        [
            "image/tiff",
            "image/x-tiff"
        ]
    ],
    [
        "tiff",
        [
            "image/tiff",
            "image/x-tiff"
        ]
    ],
    [
        "tmo",
        "application/vnd.tmobile-livetv"
    ],
    [
        "torrent",
        "application/x-bittorrent"
    ],
    [
        "tpl",
        "application/vnd.groove-tool-template"
    ],
    [
        "tpt",
        "application/vnd.trid.tpt"
    ],
    [
        "tr",
        "application/x-troff"
    ],
    [
        "tra",
        "application/vnd.trueapp"
    ],
    [
        "trm",
        "application/x-msterminal"
    ],
    [
        "tsd",
        "application/timestamped-data"
    ],
    [
        "tsi",
        "audio/tsp-audio"
    ],
    [
        "tsp",
        [
            "application/dsptype",
            "audio/tsplayer"
        ]
    ],
    [
        "tsv",
        "text/tab-separated-values"
    ],
    [
        "ttf",
        "application/x-font-ttf"
    ],
    [
        "ttl",
        "text/turtle"
    ],
    [
        "turbot",
        "image/florian"
    ],
    [
        "twd",
        "application/vnd.simtech-mindmapper"
    ],
    [
        "txd",
        "application/vnd.genomatix.tuxedo"
    ],
    [
        "txf",
        "application/vnd.mobius.txf"
    ],
    [
        "txt",
        "text/plain"
    ],
    [
        "ufd",
        "application/vnd.ufdl"
    ],
    [
        "uil",
        "text/x-uil"
    ],
    [
        "uls",
        "text/iuls"
    ],
    [
        "umj",
        "application/vnd.umajin"
    ],
    [
        "uni",
        "text/uri-list"
    ],
    [
        "unis",
        "text/uri-list"
    ],
    [
        "unityweb",
        "application/vnd.unity"
    ],
    [
        "unv",
        "application/i-deas"
    ],
    [
        "uoml",
        "application/vnd.uoml+xml"
    ],
    [
        "uri",
        "text/uri-list"
    ],
    [
        "uris",
        "text/uri-list"
    ],
    [
        "ustar",
        [
            "application/x-ustar",
            "multipart/x-ustar"
        ]
    ],
    [
        "utz",
        "application/vnd.uiq.theme"
    ],
    [
        "uu",
        [
            "application/octet-stream",
            "text/x-uuencode"
        ]
    ],
    [
        "uue",
        "text/x-uuencode"
    ],
    [
        "uva",
        "audio/vnd.dece.audio"
    ],
    [
        "uvh",
        "video/vnd.dece.hd"
    ],
    [
        "uvi",
        "image/vnd.dece.graphic"
    ],
    [
        "uvm",
        "video/vnd.dece.mobile"
    ],
    [
        "uvp",
        "video/vnd.dece.pd"
    ],
    [
        "uvs",
        "video/vnd.dece.sd"
    ],
    [
        "uvu",
        "video/vnd.uvvu.mp4"
    ],
    [
        "uvv",
        "video/vnd.dece.video"
    ],
    [
        "vcd",
        "application/x-cdlink"
    ],
    [
        "vcf",
        "text/x-vcard"
    ],
    [
        "vcg",
        "application/vnd.groove-vcard"
    ],
    [
        "vcs",
        "text/x-vcalendar"
    ],
    [
        "vcx",
        "application/vnd.vcx"
    ],
    [
        "vda",
        "application/vda"
    ],
    [
        "vdo",
        "video/vdo"
    ],
    [
        "vew",
        "application/groupwise"
    ],
    [
        "vis",
        "application/vnd.visionary"
    ],
    [
        "viv",
        [
            "video/vivo",
            "video/vnd.vivo"
        ]
    ],
    [
        "vivo",
        [
            "video/vivo",
            "video/vnd.vivo"
        ]
    ],
    [
        "vmd",
        "application/vocaltec-media-desc"
    ],
    [
        "vmf",
        "application/vocaltec-media-file"
    ],
    [
        "voc",
        [
            "audio/voc",
            "audio/x-voc"
        ]
    ],
    [
        "vos",
        "video/vosaic"
    ],
    [
        "vox",
        "audio/voxware"
    ],
    [
        "vqe",
        "audio/x-twinvq-plugin"
    ],
    [
        "vqf",
        "audio/x-twinvq"
    ],
    [
        "vql",
        "audio/x-twinvq-plugin"
    ],
    [
        "vrml",
        [
            "model/vrml",
            "x-world/x-vrml",
            "application/x-vrml"
        ]
    ],
    [
        "vrt",
        "x-world/x-vrt"
    ],
    [
        "vsd",
        [
            "application/vnd.visio",
            "application/x-visio"
        ]
    ],
    [
        "vsf",
        "application/vnd.vsf"
    ],
    [
        "vst",
        "application/x-visio"
    ],
    [
        "vsw",
        "application/x-visio"
    ],
    [
        "vtu",
        "model/vnd.vtu"
    ],
    [
        "vxml",
        "application/voicexml+xml"
    ],
    [
        "w60",
        "application/wordperfect6.0"
    ],
    [
        "w61",
        "application/wordperfect6.1"
    ],
    [
        "w6w",
        "application/msword"
    ],
    [
        "wad",
        "application/x-doom"
    ],
    [
        "wav",
        [
            "audio/wav",
            "audio/x-wav"
        ]
    ],
    [
        "wax",
        "audio/x-ms-wax"
    ],
    [
        "wb1",
        "application/x-qpro"
    ],
    [
        "wbmp",
        "image/vnd.wap.wbmp"
    ],
    [
        "wbs",
        "application/vnd.criticaltools.wbs+xml"
    ],
    [
        "wbxml",
        "application/vnd.wap.wbxml"
    ],
    [
        "wcm",
        "application/vnd.ms-works"
    ],
    [
        "wdb",
        "application/vnd.ms-works"
    ],
    [
        "web",
        "application/vnd.xara"
    ],
    [
        "weba",
        "audio/webm"
    ],
    [
        "webm",
        "video/webm"
    ],
    [
        "webp",
        "image/webp"
    ],
    [
        "wg",
        "application/vnd.pmi.widget"
    ],
    [
        "wgt",
        "application/widget"
    ],
    [
        "wiz",
        "application/msword"
    ],
    [
        "wk1",
        "application/x-123"
    ],
    [
        "wks",
        "application/vnd.ms-works"
    ],
    [
        "wm",
        "video/x-ms-wm"
    ],
    [
        "wma",
        "audio/x-ms-wma"
    ],
    [
        "wmd",
        "application/x-ms-wmd"
    ],
    [
        "wmf",
        [
            "windows/metafile",
            "application/x-msmetafile"
        ]
    ],
    [
        "wml",
        "text/vnd.wap.wml"
    ],
    [
        "wmlc",
        "application/vnd.wap.wmlc"
    ],
    [
        "wmls",
        "text/vnd.wap.wmlscript"
    ],
    [
        "wmlsc",
        "application/vnd.wap.wmlscriptc"
    ],
    [
        "wmv",
        "video/x-ms-wmv"
    ],
    [
        "wmx",
        "video/x-ms-wmx"
    ],
    [
        "wmz",
        "application/x-ms-wmz"
    ],
    [
        "woff",
        "application/x-font-woff"
    ],
    [
        "word",
        "application/msword"
    ],
    [
        "wp",
        "application/wordperfect"
    ],
    [
        "wp5",
        [
            "application/wordperfect",
            "application/wordperfect6.0"
        ]
    ],
    [
        "wp6",
        "application/wordperfect"
    ],
    [
        "wpd",
        [
            "application/wordperfect",
            "application/vnd.wordperfect",
            "application/x-wpwin"
        ]
    ],
    [
        "wpl",
        "application/vnd.ms-wpl"
    ],
    [
        "wps",
        "application/vnd.ms-works"
    ],
    [
        "wq1",
        "application/x-lotus"
    ],
    [
        "wqd",
        "application/vnd.wqd"
    ],
    [
        "wri",
        [
            "application/mswrite",
            "application/x-wri",
            "application/x-mswrite"
        ]
    ],
    [
        "wrl",
        [
            "model/vrml",
            "x-world/x-vrml",
            "application/x-world"
        ]
    ],
    [
        "wrz",
        [
            "model/vrml",
            "x-world/x-vrml"
        ]
    ],
    [
        "wsc",
        "text/scriplet"
    ],
    [
        "wsdl",
        "application/wsdl+xml"
    ],
    [
        "wspolicy",
        "application/wspolicy+xml"
    ],
    [
        "wsrc",
        "application/x-wais-source"
    ],
    [
        "wtb",
        "application/vnd.webturbo"
    ],
    [
        "wtk",
        "application/x-wintalk"
    ],
    [
        "wvx",
        "video/x-ms-wvx"
    ],
    [
        "x-png",
        "image/png"
    ],
    [
        "x3d",
        "application/vnd.hzn-3d-crossword"
    ],
    [
        "xaf",
        "x-world/x-vrml"
    ],
    [
        "xap",
        "application/x-silverlight-app"
    ],
    [
        "xar",
        "application/vnd.xara"
    ],
    [
        "xbap",
        "application/x-ms-xbap"
    ],
    [
        "xbd",
        "application/vnd.fujixerox.docuworks.binder"
    ],
    [
        "xbm",
        [
            "image/xbm",
            "image/x-xbm",
            "image/x-xbitmap"
        ]
    ],
    [
        "xdf",
        "application/xcap-diff+xml"
    ],
    [
        "xdm",
        "application/vnd.syncml.dm+xml"
    ],
    [
        "xdp",
        "application/vnd.adobe.xdp+xml"
    ],
    [
        "xdr",
        "video/x-amt-demorun"
    ],
    [
        "xdssc",
        "application/dssc+xml"
    ],
    [
        "xdw",
        "application/vnd.fujixerox.docuworks"
    ],
    [
        "xenc",
        "application/xenc+xml"
    ],
    [
        "xer",
        "application/patch-ops-error+xml"
    ],
    [
        "xfdf",
        "application/vnd.adobe.xfdf"
    ],
    [
        "xfdl",
        "application/vnd.xfdl"
    ],
    [
        "xgz",
        "xgl/drawing"
    ],
    [
        "xhtml",
        "application/xhtml+xml"
    ],
    [
        "xif",
        "image/vnd.xiff"
    ],
    [
        "xl",
        "application/excel"
    ],
    [
        "xla",
        [
            "application/vnd.ms-excel",
            "application/excel",
            "application/x-msexcel",
            "application/x-excel"
        ]
    ],
    [
        "xlam",
        "application/vnd.ms-excel.addin.macroenabled.12"
    ],
    [
        "xlb",
        [
            "application/excel",
            "application/vnd.ms-excel",
            "application/x-excel"
        ]
    ],
    [
        "xlc",
        [
            "application/vnd.ms-excel",
            "application/excel",
            "application/x-excel"
        ]
    ],
    [
        "xld",
        [
            "application/excel",
            "application/x-excel"
        ]
    ],
    [
        "xlk",
        [
            "application/excel",
            "application/x-excel"
        ]
    ],
    [
        "xll",
        [
            "application/excel",
            "application/vnd.ms-excel",
            "application/x-excel"
        ]
    ],
    [
        "xlm",
        [
            "application/vnd.ms-excel",
            "application/excel",
            "application/x-excel"
        ]
    ],
    [
        "xls",
        [
            "application/vnd.ms-excel",
            "application/excel",
            "application/x-msexcel",
            "application/x-excel"
        ]
    ],
    [
        "xlsb",
        "application/vnd.ms-excel.sheet.binary.macroenabled.12"
    ],
    [
        "xlsm",
        "application/vnd.ms-excel.sheet.macroenabled.12"
    ],
    [
        "xlsx",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    ],
    [
        "xlt",
        [
            "application/vnd.ms-excel",
            "application/excel",
            "application/x-excel"
        ]
    ],
    [
        "xltm",
        "application/vnd.ms-excel.template.macroenabled.12"
    ],
    [
        "xltx",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.template"
    ],
    [
        "xlv",
        [
            "application/excel",
            "application/x-excel"
        ]
    ],
    [
        "xlw",
        [
            "application/vnd.ms-excel",
            "application/excel",
            "application/x-msexcel",
            "application/x-excel"
        ]
    ],
    [
        "xm",
        "audio/xm"
    ],
    [
        "xml",
        [
            "application/xml",
            "text/xml",
            "application/atom+xml",
            "application/rss+xml"
        ]
    ],
    [
        "xmz",
        "xgl/movie"
    ],
    [
        "xo",
        "application/vnd.olpc-sugar"
    ],
    [
        "xof",
        "x-world/x-vrml"
    ],
    [
        "xop",
        "application/xop+xml"
    ],
    [
        "xpi",
        "application/x-xpinstall"
    ],
    [
        "xpix",
        "application/x-vnd.ls-xpix"
    ],
    [
        "xpm",
        [
            "image/xpm",
            "image/x-xpixmap"
        ]
    ],
    [
        "xpr",
        "application/vnd.is-xpr"
    ],
    [
        "xps",
        "application/vnd.ms-xpsdocument"
    ],
    [
        "xpw",
        "application/vnd.intercon.formnet"
    ],
    [
        "xslt",
        "application/xslt+xml"
    ],
    [
        "xsm",
        "application/vnd.syncml+xml"
    ],
    [
        "xspf",
        "application/xspf+xml"
    ],
    [
        "xsr",
        "video/x-amt-showrun"
    ],
    [
        "xul",
        "application/vnd.mozilla.xul+xml"
    ],
    [
        "xwd",
        [
            "image/x-xwd",
            "image/x-xwindowdump"
        ]
    ],
    [
        "xyz",
        [
            "chemical/x-xyz",
            "chemical/x-pdb"
        ]
    ],
    [
        "yang",
        "application/yang"
    ],
    [
        "yin",
        "application/yin+xml"
    ],
    [
        "z",
        [
            "application/x-compressed",
            "application/x-compress"
        ]
    ],
    [
        "zaz",
        "application/vnd.zzazz.deck+xml"
    ],
    [
        "zip",
        [
            "application/zip",
            "multipart/x-zip",
            "application/x-zip-compressed",
            "application/x-compressed"
        ]
    ],
    [
        "zir",
        "application/vnd.zul"
    ],
    [
        "zmm",
        "application/vnd.handheld-entertainment+xml"
    ],
    [
        "zoo",
        "application/octet-stream"
    ],
    [
        "zsh",
        "text/x-script.zsh"
    ]
]);
module.exports = {
    detectMimeType (filename) {
        if (!filename) {
            return defaultMimeType;
        }
        let parsed = path.parse(filename);
        let extension = (parsed.ext.substr(1) || parsed.name || "").split("?").shift().trim().toLowerCase();
        let value = defaultMimeType;
        if (extensions.has(extension)) {
            value = extensions.get(extension);
        }
        if (Array.isArray(value)) {
            return value[0];
        }
        return value;
    },
    detectExtension (mimeType) {
        if (!mimeType) {
            return defaultExtension;
        }
        let parts = (mimeType || "").toLowerCase().trim().split("/");
        let rootType = parts.shift().trim();
        let subType = parts.join("/").trim();
        if (mimeTypes.has(rootType + "/" + subType)) {
            let value = mimeTypes.get(rootType + "/" + subType);
            if (Array.isArray(value)) {
                return value[0];
            }
            return value;
        }
        switch(rootType){
            case "text":
                return "txt";
            default:
                return "bin";
        }
    }
};


/***/ }),

/***/ 56312:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-undefined: 0, prefer-spread: 0, no-control-regex: 0 */ 
const crypto = __webpack_require__(6113);
const fs = __webpack_require__(57147);
const punycode = __webpack_require__(85477);
const PassThrough = (__webpack_require__(12781).PassThrough);
const shared = __webpack_require__(74741);
const mimeFuncs = __webpack_require__(96658);
const qp = __webpack_require__(9050);
const base64 = __webpack_require__(60038);
const addressparser = __webpack_require__(53287);
const nmfetch = __webpack_require__(23872);
const LastNewline = __webpack_require__(10873);
const LeWindows = __webpack_require__(36974);
const LeUnix = __webpack_require__(67386);
/**
 * Creates a new mime tree node. Assumes 'multipart/*' as the content type
 * if it is a branch, anything else counts as leaf. If rootNode is missing from
 * the options, assumes this is the root.
 *
 * @param {String} contentType Define the content type for the node. Can be left blank for attachments (derived from filename)
 * @param {Object} [options] optional options
 * @param {Object} [options.rootNode] root node for this tree
 * @param {Object} [options.parentNode] immediate parent for this node
 * @param {Object} [options.filename] filename for an attachment node
 * @param {String} [options.baseBoundary] shared part of the unique multipart boundary
 * @param {Boolean} [options.keepBcc] If true, do not exclude Bcc from the generated headers
 * @param {Function} [options.normalizeHeaderKey] method to normalize header keys for custom caseing
 * @param {String} [options.textEncoding] either 'Q' (the default) or 'B'
 */ class MimeNode {
    constructor(contentType, options){
        this.nodeCounter = 0;
        options = options || {};
        /**
         * shared part of the unique multipart boundary
         */ this.baseBoundary = options.baseBoundary || crypto.randomBytes(8).toString("hex");
        this.boundaryPrefix = options.boundaryPrefix || "--_NmP";
        this.disableFileAccess = !!options.disableFileAccess;
        this.disableUrlAccess = !!options.disableUrlAccess;
        this.normalizeHeaderKey = options.normalizeHeaderKey;
        /**
         * If date headers is missing and current node is the root, this value is used instead
         */ this.date = new Date();
        /**
         * Root node for current mime tree
         */ this.rootNode = options.rootNode || this;
        /**
         * If true include Bcc in generated headers (if available)
         */ this.keepBcc = !!options.keepBcc;
        /**
         * If filename is specified but contentType is not (probably an attachment)
         * detect the content type from filename extension
         */ if (options.filename) {
            /**
             * Filename for this node. Useful with attachments
             */ this.filename = options.filename;
            if (!contentType) {
                contentType = mimeFuncs.detectMimeType(this.filename.split(".").pop());
            }
        }
        /**
         * Indicates which encoding should be used for header strings: "Q" or "B"
         */ this.textEncoding = (options.textEncoding || "").toString().trim().charAt(0).toUpperCase();
        /**
         * Immediate parent for this node (or undefined if not set)
         */ this.parentNode = options.parentNode;
        /**
         * Hostname for default message-id values
         */ this.hostname = options.hostname;
        /**
         * If set to 'win' then uses \r\n, if 'linux' then \n. If not set (or `raw` is used) then newlines are kept as is.
         */ this.newline = options.newline;
        /**
         * An array for possible child nodes
         */ this.childNodes = [];
        /**
         * Used for generating unique boundaries (prepended to the shared base)
         */ this._nodeId = ++this.rootNode.nodeCounter;
        /**
         * A list of header values for this node in the form of [{key:'', value:''}]
         */ this._headers = [];
        /**
         * True if the content only uses ASCII printable characters
         * @type {Boolean}
         */ this._isPlainText = false;
        /**
         * True if the content is plain text but has longer lines than allowed
         * @type {Boolean}
         */ this._hasLongLines = false;
        /**
         * If set, use instead this value for envelopes instead of generating one
         * @type {Boolean}
         */ this._envelope = false;
        /**
         * If set then use this value as the stream content instead of building it
         * @type {String|Buffer|Stream}
         */ this._raw = false;
        /**
         * Additional transform streams that the message will be piped before
         * exposing by createReadStream
         * @type {Array}
         */ this._transforms = [];
        /**
         * Additional process functions that the message will be piped through before
         * exposing by createReadStream. These functions are run after transforms
         * @type {Array}
         */ this._processFuncs = [];
        /**
         * If content type is set (or derived from the filename) add it to headers
         */ if (contentType) {
            this.setHeader("Content-Type", contentType);
        }
    }
    /////// PUBLIC METHODS
    /**
     * Creates and appends a child node.Arguments provided are passed to MimeNode constructor
     *
     * @param {String} [contentType] Optional content type
     * @param {Object} [options] Optional options object
     * @return {Object} Created node object
     */ createChild(contentType, options) {
        if (!options && typeof contentType === "object") {
            options = contentType;
            contentType = undefined;
        }
        let node = new MimeNode(contentType, options);
        this.appendChild(node);
        return node;
    }
    /**
     * Appends an existing node to the mime tree. Removes the node from an existing
     * tree if needed
     *
     * @param {Object} childNode node to be appended
     * @return {Object} Appended node object
     */ appendChild(childNode) {
        if (childNode.rootNode !== this.rootNode) {
            childNode.rootNode = this.rootNode;
            childNode._nodeId = ++this.rootNode.nodeCounter;
        }
        childNode.parentNode = this;
        this.childNodes.push(childNode);
        return childNode;
    }
    /**
     * Replaces current node with another node
     *
     * @param {Object} node Replacement node
     * @return {Object} Replacement node
     */ replace(node) {
        if (node === this) {
            return this;
        }
        this.parentNode.childNodes.forEach((childNode, i)=>{
            if (childNode === this) {
                node.rootNode = this.rootNode;
                node.parentNode = this.parentNode;
                node._nodeId = this._nodeId;
                this.rootNode = this;
                this.parentNode = undefined;
                node.parentNode.childNodes[i] = node;
            }
        });
        return node;
    }
    /**
     * Removes current node from the mime tree
     *
     * @return {Object} removed node
     */ remove() {
        if (!this.parentNode) {
            return this;
        }
        for(let i = this.parentNode.childNodes.length - 1; i >= 0; i--){
            if (this.parentNode.childNodes[i] === this) {
                this.parentNode.childNodes.splice(i, 1);
                this.parentNode = undefined;
                this.rootNode = this;
                return this;
            }
        }
    }
    /**
     * Sets a header value. If the value for selected key exists, it is overwritten.
     * You can set multiple values as well by using [{key:'', value:''}] or
     * {key: 'value'} as the first argument.
     *
     * @param {String|Array|Object} key Header key or a list of key value pairs
     * @param {String} value Header value
     * @return {Object} current node
     */ setHeader(key, value) {
        let added = false, headerValue;
        // Allow setting multiple headers at once
        if (!value && key && typeof key === "object") {
            // allow {key:'content-type', value: 'text/plain'}
            if (key.key && "value" in key) {
                this.setHeader(key.key, key.value);
            } else if (Array.isArray(key)) {
                // allow [{key:'content-type', value: 'text/plain'}]
                key.forEach((i)=>{
                    this.setHeader(i.key, i.value);
                });
            } else {
                // allow {'content-type': 'text/plain'}
                Object.keys(key).forEach((i)=>{
                    this.setHeader(i, key[i]);
                });
            }
            return this;
        }
        key = this._normalizeHeaderKey(key);
        headerValue = {
            key,
            value
        };
        // Check if the value exists and overwrite
        for(let i = 0, len = this._headers.length; i < len; i++){
            if (this._headers[i].key === key) {
                if (!added) {
                    // replace the first match
                    this._headers[i] = headerValue;
                    added = true;
                } else {
                    // remove following matches
                    this._headers.splice(i, 1);
                    i--;
                    len--;
                }
            }
        }
        // match not found, append the value
        if (!added) {
            this._headers.push(headerValue);
        }
        return this;
    }
    /**
     * Adds a header value. If the value for selected key exists, the value is appended
     * as a new field and old one is not touched.
     * You can set multiple values as well by using [{key:'', value:''}] or
     * {key: 'value'} as the first argument.
     *
     * @param {String|Array|Object} key Header key or a list of key value pairs
     * @param {String} value Header value
     * @return {Object} current node
     */ addHeader(key, value) {
        // Allow setting multiple headers at once
        if (!value && key && typeof key === "object") {
            // allow {key:'content-type', value: 'text/plain'}
            if (key.key && key.value) {
                this.addHeader(key.key, key.value);
            } else if (Array.isArray(key)) {
                // allow [{key:'content-type', value: 'text/plain'}]
                key.forEach((i)=>{
                    this.addHeader(i.key, i.value);
                });
            } else {
                // allow {'content-type': 'text/plain'}
                Object.keys(key).forEach((i)=>{
                    this.addHeader(i, key[i]);
                });
            }
            return this;
        } else if (Array.isArray(value)) {
            value.forEach((val)=>{
                this.addHeader(key, val);
            });
            return this;
        }
        this._headers.push({
            key: this._normalizeHeaderKey(key),
            value
        });
        return this;
    }
    /**
     * Retrieves the first mathcing value of a selected key
     *
     * @param {String} key Key to search for
     * @retun {String} Value for the key
     */ getHeader(key) {
        key = this._normalizeHeaderKey(key);
        for(let i = 0, len = this._headers.length; i < len; i++){
            if (this._headers[i].key === key) {
                return this._headers[i].value;
            }
        }
    }
    /**
     * Sets body content for current node. If the value is a string, charset is added automatically
     * to Content-Type (if it is text/*). If the value is a Buffer, you need to specify
     * the charset yourself
     *
     * @param (String|Buffer) content Body content
     * @return {Object} current node
     */ setContent(content) {
        this.content = content;
        if (typeof this.content.pipe === "function") {
            // pre-stream handler. might be triggered if a stream is set as content
            // and 'error' fires before anything is done with this stream
            this._contentErrorHandler = (err)=>{
                this.content.removeListener("error", this._contentErrorHandler);
                this.content = err;
            };
            this.content.once("error", this._contentErrorHandler);
        } else if (typeof this.content === "string") {
            this._isPlainText = mimeFuncs.isPlainText(this.content);
            if (this._isPlainText && mimeFuncs.hasLongerLines(this.content, 76)) {
                // If there are lines longer than 76 symbols/bytes do not use 7bit
                this._hasLongLines = true;
            }
        }
        return this;
    }
    build(callback) {
        let promise;
        if (!callback) {
            promise = new Promise((resolve, reject)=>{
                callback = shared.callbackPromise(resolve, reject);
            });
        }
        let stream = this.createReadStream();
        let buf = [];
        let buflen = 0;
        let returned = false;
        stream.on("readable", ()=>{
            let chunk;
            while((chunk = stream.read()) !== null){
                buf.push(chunk);
                buflen += chunk.length;
            }
        });
        stream.once("error", (err)=>{
            if (returned) {
                return;
            }
            returned = true;
            return callback(err);
        });
        stream.once("end", (chunk)=>{
            if (returned) {
                return;
            }
            returned = true;
            if (chunk && chunk.length) {
                buf.push(chunk);
                buflen += chunk.length;
            }
            return callback(null, Buffer.concat(buf, buflen));
        });
        return promise;
    }
    getTransferEncoding() {
        let transferEncoding = false;
        let contentType = (this.getHeader("Content-Type") || "").toString().toLowerCase().trim();
        if (this.content) {
            transferEncoding = (this.getHeader("Content-Transfer-Encoding") || "").toString().toLowerCase().trim();
            if (!transferEncoding || ![
                "base64",
                "quoted-printable"
            ].includes(transferEncoding)) {
                if (/^text\//i.test(contentType)) {
                    // If there are no special symbols, no need to modify the text
                    if (this._isPlainText && !this._hasLongLines) {
                        transferEncoding = "7bit";
                    } else if (typeof this.content === "string" || this.content instanceof Buffer) {
                        // detect preferred encoding for string value
                        transferEncoding = this._getTextEncoding(this.content) === "Q" ? "quoted-printable" : "base64";
                    } else {
                        // we can not check content for a stream, so either use preferred encoding or fallback to QP
                        transferEncoding = this.textEncoding === "B" ? "base64" : "quoted-printable";
                    }
                } else if (!/^(multipart|message)\//i.test(contentType)) {
                    transferEncoding = transferEncoding || "base64";
                }
            }
        }
        return transferEncoding;
    }
    /**
     * Builds the header block for the mime node. Append \r\n\r\n before writing the content
     *
     * @returns {String} Headers
     */ buildHeaders() {
        let transferEncoding = this.getTransferEncoding();
        let headers = [];
        if (transferEncoding) {
            this.setHeader("Content-Transfer-Encoding", transferEncoding);
        }
        if (this.filename && !this.getHeader("Content-Disposition")) {
            this.setHeader("Content-Disposition", "attachment");
        }
        // Ensure mandatory header fields
        if (this.rootNode === this) {
            if (!this.getHeader("Date")) {
                this.setHeader("Date", this.date.toUTCString().replace(/GMT/, "+0000"));
            }
            // ensure that Message-Id is present
            this.messageId();
            if (!this.getHeader("MIME-Version")) {
                this.setHeader("MIME-Version", "1.0");
            }
        }
        this._headers.forEach((header)=>{
            let key = header.key;
            let value = header.value;
            let structured;
            let param;
            let options = {};
            let formattedHeaders = [
                "From",
                "Sender",
                "To",
                "Cc",
                "Bcc",
                "Reply-To",
                "Date",
                "References"
            ];
            if (value && typeof value === "object" && !formattedHeaders.includes(key)) {
                Object.keys(value).forEach((key)=>{
                    if (key !== "value") {
                        options[key] = value[key];
                    }
                });
                value = (value.value || "").toString();
                if (!value.trim()) {
                    return;
                }
            }
            if (options.prepared) {
                // header value is
                if (options.foldLines) {
                    headers.push(mimeFuncs.foldLines(key + ": " + value));
                } else {
                    headers.push(key + ": " + value);
                }
                return;
            }
            switch(header.key){
                case "Content-Disposition":
                    structured = mimeFuncs.parseHeaderValue(value);
                    if (this.filename) {
                        structured.params.filename = this.filename;
                    }
                    value = mimeFuncs.buildHeaderValue(structured);
                    break;
                case "Content-Type":
                    structured = mimeFuncs.parseHeaderValue(value);
                    this._handleContentType(structured);
                    if (structured.value.match(/^text\/plain\b/) && typeof this.content === "string" && /[\u0080-\uFFFF]/.test(this.content)) {
                        structured.params.charset = "utf-8";
                    }
                    value = mimeFuncs.buildHeaderValue(structured);
                    if (this.filename) {
                        // add support for non-compliant clients like QQ webmail
                        // we can't build the value with buildHeaderValue as the value is non standard and
                        // would be converted to parameter continuation encoding that we do not want
                        param = this._encodeWords(this.filename);
                        if (param !== this.filename || /[\s'"\\;:/=(),<>@[\]?]|^-/.test(param)) {
                            // include value in quotes if needed
                            param = '"' + param + '"';
                        }
                        value += "; name=" + param;
                    }
                    break;
                case "Bcc":
                    if (!this.keepBcc) {
                        // skip BCC values
                        return;
                    }
                    break;
            }
            value = this._encodeHeaderValue(key, value);
            // skip empty lines
            if (!(value || "").toString().trim()) {
                return;
            }
            if (typeof this.normalizeHeaderKey === "function") {
                let normalized = this.normalizeHeaderKey(key, value);
                if (normalized && typeof normalized === "string" && normalized.length) {
                    key = normalized;
                }
            }
            headers.push(mimeFuncs.foldLines(key + ": " + value, 76));
        });
        return headers.join("\r\n");
    }
    /**
     * Streams the rfc2822 message from the current node. If this is a root node,
     * mandatory header fields are set if missing (Date, Message-Id, MIME-Version)
     *
     * @return {String} Compiled message
     */ createReadStream(options) {
        options = options || {};
        let stream = new PassThrough(options);
        let outputStream = stream;
        let transform;
        this.stream(stream, options, (err)=>{
            if (err) {
                outputStream.emit("error", err);
                return;
            }
            stream.end();
        });
        for(let i = 0, len = this._transforms.length; i < len; i++){
            transform = typeof this._transforms[i] === "function" ? this._transforms[i]() : this._transforms[i];
            outputStream.once("error", (err)=>{
                transform.emit("error", err);
            });
            outputStream = outputStream.pipe(transform);
        }
        // ensure terminating newline after possible user transforms
        transform = new LastNewline();
        outputStream.once("error", (err)=>{
            transform.emit("error", err);
        });
        outputStream = outputStream.pipe(transform);
        // dkim and stuff
        for(let i1 = 0, len1 = this._processFuncs.length; i1 < len1; i1++){
            transform = this._processFuncs[i1];
            outputStream = transform(outputStream);
        }
        if (this.newline) {
            const winbreak = [
                "win",
                "windows",
                "dos",
                "\r\n"
            ].includes(this.newline.toString().toLowerCase());
            const newlineTransform = winbreak ? new LeWindows() : new LeUnix();
            const stream1 = outputStream.pipe(newlineTransform);
            outputStream.on("error", (err)=>stream1.emit("error", err));
            return stream1;
        }
        return outputStream;
    }
    /**
     * Appends a transform stream object to the transforms list. Final output
     * is passed through this stream before exposing
     *
     * @param {Object} transform Read-Write stream
     */ transform(transform) {
        this._transforms.push(transform);
    }
    /**
     * Appends a post process function. The functon is run after transforms and
     * uses the following syntax
     *
     *   processFunc(input) -> outputStream
     *
     * @param {Object} processFunc Read-Write stream
     */ processFunc(processFunc) {
        this._processFuncs.push(processFunc);
    }
    stream(outputStream, options, done) {
        let transferEncoding = this.getTransferEncoding();
        let contentStream;
        let localStream;
        // protect actual callback against multiple triggering
        let returned = false;
        let callback = (err)=>{
            if (returned) {
                return;
            }
            returned = true;
            done(err);
        };
        // for multipart nodes, push child nodes
        // for content nodes end the stream
        let finalize = ()=>{
            let childId = 0;
            let processChildNode = ()=>{
                if (childId >= this.childNodes.length) {
                    outputStream.write("\r\n--" + this.boundary + "--\r\n");
                    return callback();
                }
                let child = this.childNodes[childId++];
                outputStream.write((childId > 1 ? "\r\n" : "") + "--" + this.boundary + "\r\n");
                child.stream(outputStream, options, (err)=>{
                    if (err) {
                        return callback(err);
                    }
                    setImmediate(processChildNode);
                });
            };
            if (this.multipart) {
                setImmediate(processChildNode);
            } else {
                return callback();
            }
        };
        // pushes node content
        let sendContent = ()=>{
            if (this.content) {
                if (Object.prototype.toString.call(this.content) === "[object Error]") {
                    // content is already errored
                    return callback(this.content);
                }
                if (typeof this.content.pipe === "function") {
                    this.content.removeListener("error", this._contentErrorHandler);
                    this._contentErrorHandler = (err)=>callback(err);
                    this.content.once("error", this._contentErrorHandler);
                }
                let createStream = ()=>{
                    if ([
                        "quoted-printable",
                        "base64"
                    ].includes(transferEncoding)) {
                        contentStream = new (transferEncoding === "base64" ? base64 : qp).Encoder(options);
                        contentStream.pipe(outputStream, {
                            end: false
                        });
                        contentStream.once("end", finalize);
                        contentStream.once("error", (err)=>callback(err));
                        localStream = this._getStream(this.content);
                        localStream.pipe(contentStream);
                    } else {
                        // anything that is not QP or Base54 passes as-is
                        localStream = this._getStream(this.content);
                        localStream.pipe(outputStream, {
                            end: false
                        });
                        localStream.once("end", finalize);
                    }
                    localStream.once("error", (err)=>callback(err));
                };
                if (this.content._resolve) {
                    let chunks = [];
                    let chunklen = 0;
                    let returned = false;
                    let sourceStream = this._getStream(this.content);
                    sourceStream.on("error", (err)=>{
                        if (returned) {
                            return;
                        }
                        returned = true;
                        callback(err);
                    });
                    sourceStream.on("readable", ()=>{
                        let chunk;
                        while((chunk = sourceStream.read()) !== null){
                            chunks.push(chunk);
                            chunklen += chunk.length;
                        }
                    });
                    sourceStream.on("end", ()=>{
                        if (returned) {
                            return;
                        }
                        returned = true;
                        this.content._resolve = false;
                        this.content._resolvedValue = Buffer.concat(chunks, chunklen);
                        setImmediate(createStream);
                    });
                } else {
                    setImmediate(createStream);
                }
                return;
            } else {
                return setImmediate(finalize);
            }
        };
        if (this._raw) {
            setImmediate(()=>{
                if (Object.prototype.toString.call(this._raw) === "[object Error]") {
                    // content is already errored
                    return callback(this._raw);
                }
                // remove default error handler (if set)
                if (typeof this._raw.pipe === "function") {
                    this._raw.removeListener("error", this._contentErrorHandler);
                }
                let raw = this._getStream(this._raw);
                raw.pipe(outputStream, {
                    end: false
                });
                raw.on("error", (err)=>outputStream.emit("error", err));
                raw.on("end", finalize);
            });
        } else {
            outputStream.write(this.buildHeaders() + "\r\n\r\n");
            setImmediate(sendContent);
        }
    }
    /**
     * Sets envelope to be used instead of the generated one
     *
     * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}
     */ setEnvelope(envelope) {
        let list;
        this._envelope = {
            from: false,
            to: []
        };
        if (envelope.from) {
            list = [];
            this._convertAddresses(this._parseAddresses(envelope.from), list);
            list = list.filter((address)=>address && address.address);
            if (list.length && list[0]) {
                this._envelope.from = list[0].address;
            }
        }
        [
            "to",
            "cc",
            "bcc"
        ].forEach((key)=>{
            if (envelope[key]) {
                this._convertAddresses(this._parseAddresses(envelope[key]), this._envelope.to);
            }
        });
        this._envelope.to = this._envelope.to.map((to)=>to.address).filter((address)=>address);
        let standardFields = [
            "to",
            "cc",
            "bcc",
            "from"
        ];
        Object.keys(envelope).forEach((key)=>{
            if (!standardFields.includes(key)) {
                this._envelope[key] = envelope[key];
            }
        });
        return this;
    }
    /**
     * Generates and returns an object with parsed address fields
     *
     * @return {Object} Address object
     */ getAddresses() {
        let addresses = {};
        this._headers.forEach((header)=>{
            let key = header.key.toLowerCase();
            if ([
                "from",
                "sender",
                "reply-to",
                "to",
                "cc",
                "bcc"
            ].includes(key)) {
                if (!Array.isArray(addresses[key])) {
                    addresses[key] = [];
                }
                this._convertAddresses(this._parseAddresses(header.value), addresses[key]);
            }
        });
        return addresses;
    }
    /**
     * Generates and returns SMTP envelope with the sender address and a list of recipients addresses
     *
     * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}
     */ getEnvelope() {
        if (this._envelope) {
            return this._envelope;
        }
        let envelope = {
            from: false,
            to: []
        };
        this._headers.forEach((header)=>{
            let list = [];
            if (header.key === "From" || !envelope.from && [
                "Reply-To",
                "Sender"
            ].includes(header.key)) {
                this._convertAddresses(this._parseAddresses(header.value), list);
                if (list.length && list[0]) {
                    envelope.from = list[0].address;
                }
            } else if ([
                "To",
                "Cc",
                "Bcc"
            ].includes(header.key)) {
                this._convertAddresses(this._parseAddresses(header.value), envelope.to);
            }
        });
        envelope.to = envelope.to.map((to)=>to.address);
        return envelope;
    }
    /**
     * Returns Message-Id value. If it does not exist, then creates one
     *
     * @return {String} Message-Id value
     */ messageId() {
        let messageId = this.getHeader("Message-ID");
        // You really should define your own Message-Id field!
        if (!messageId) {
            messageId = this._generateMessageId();
            this.setHeader("Message-ID", messageId);
        }
        return messageId;
    }
    /**
     * Sets pregenerated content that will be used as the output of this node
     *
     * @param {String|Buffer|Stream} Raw MIME contents
     */ setRaw(raw) {
        this._raw = raw;
        if (this._raw && typeof this._raw.pipe === "function") {
            // pre-stream handler. might be triggered if a stream is set as content
            // and 'error' fires before anything is done with this stream
            this._contentErrorHandler = (err)=>{
                this._raw.removeListener("error", this._contentErrorHandler);
                this._raw = err;
            };
            this._raw.once("error", this._contentErrorHandler);
        }
        return this;
    }
    /////// PRIVATE METHODS
    /**
     * Detects and returns handle to a stream related with the content.
     *
     * @param {Mixed} content Node content
     * @returns {Object} Stream object
     */ _getStream(content) {
        let contentStream;
        if (content._resolvedValue) {
            // pass string or buffer content as a stream
            contentStream = new PassThrough();
            setImmediate(()=>contentStream.end(content._resolvedValue));
            return contentStream;
        } else if (typeof content.pipe === "function") {
            // assume as stream
            return content;
        } else if (content && typeof content.path === "string" && !content.href) {
            if (this.disableFileAccess) {
                contentStream = new PassThrough();
                setImmediate(()=>contentStream.emit("error", new Error("File access rejected for " + content.path)));
                return contentStream;
            }
            // read file
            return fs.createReadStream(content.path);
        } else if (content && typeof content.href === "string") {
            if (this.disableUrlAccess) {
                contentStream = new PassThrough();
                setImmediate(()=>contentStream.emit("error", new Error("Url access rejected for " + content.href)));
                return contentStream;
            }
            // fetch URL
            return nmfetch(content.href, {
                headers: content.httpHeaders
            });
        } else {
            // pass string or buffer content as a stream
            contentStream = new PassThrough();
            setImmediate(()=>contentStream.end(content || ""));
            return contentStream;
        }
    }
    /**
     * Parses addresses. Takes in a single address or an array or an
     * array of address arrays (eg. To: [[first group], [second group],...])
     *
     * @param {Mixed} addresses Addresses to be parsed
     * @return {Array} An array of address objects
     */ _parseAddresses(addresses) {
        return [].concat.apply([], [].concat(addresses).map((address)=>{
            // eslint-disable-line prefer-spread
            if (address && address.address) {
                address.address = this._normalizeAddress(address.address);
                address.name = address.name || "";
                return [
                    address
                ];
            }
            return addressparser(address);
        }));
    }
    /**
     * Normalizes a header key, uses Camel-Case form, except for uppercase MIME-
     *
     * @param {String} key Key to be normalized
     * @return {String} key in Camel-Case form
     */ _normalizeHeaderKey(key) {
        key = (key || "").toString()// no newlines in keys
        .replace(/\r?\n|\r/g, " ").trim().toLowerCase()// use uppercase words, except MIME
        .replace(/^X-SMTPAPI$|^(MIME|DKIM|ARC|BIMI)\b|^[a-z]|-(SPF|FBL|ID|MD5)$|-[a-z]/gi, (c)=>c.toUpperCase())// special case
        .replace(/^Content-Features$/i, "Content-features");
        return key;
    }
    /**
     * Checks if the content type is multipart and defines boundary if needed.
     * Doesn't return anything, modifies object argument instead.
     *
     * @param {Object} structured Parsed header value for 'Content-Type' key
     */ _handleContentType(structured) {
        this.contentType = structured.value.trim().toLowerCase();
        this.multipart = /^multipart\//i.test(this.contentType) ? this.contentType.substr(this.contentType.indexOf("/") + 1) : false;
        if (this.multipart) {
            this.boundary = structured.params.boundary = structured.params.boundary || this.boundary || this._generateBoundary();
        } else {
            this.boundary = false;
        }
    }
    /**
     * Generates a multipart boundary value
     *
     * @return {String} boundary value
     */ _generateBoundary() {
        return this.rootNode.boundaryPrefix + "-" + this.rootNode.baseBoundary + "-Part_" + this._nodeId;
    }
    /**
     * Encodes a header value for use in the generated rfc2822 email.
     *
     * @param {String} key Header key
     * @param {String} value Header value
     */ _encodeHeaderValue(key, value) {
        key = this._normalizeHeaderKey(key);
        switch(key){
            // Structured headers
            case "From":
            case "Sender":
            case "To":
            case "Cc":
            case "Bcc":
            case "Reply-To":
                return this._convertAddresses(this._parseAddresses(value));
            // values enclosed in <>
            case "Message-ID":
            case "In-Reply-To":
            case "Content-Id":
                value = (value || "").toString().replace(/\r?\n|\r/g, " ");
                if (value.charAt(0) !== "<") {
                    value = "<" + value;
                }
                if (value.charAt(value.length - 1) !== ">") {
                    value = value + ">";
                }
                return value;
            // space separated list of values enclosed in <>
            case "References":
                value = [].concat.apply([], [].concat(value || "").map((elm)=>{
                    // eslint-disable-line prefer-spread
                    elm = (elm || "").toString().replace(/\r?\n|\r/g, " ").trim();
                    return elm.replace(/<[^>]*>/g, (str)=>str.replace(/\s/g, "")).split(/\s+/);
                })).map((elm)=>{
                    if (elm.charAt(0) !== "<") {
                        elm = "<" + elm;
                    }
                    if (elm.charAt(elm.length - 1) !== ">") {
                        elm = elm + ">";
                    }
                    return elm;
                });
                return value.join(" ").trim();
            case "Date":
                if (Object.prototype.toString.call(value) === "[object Date]") {
                    return value.toUTCString().replace(/GMT/, "+0000");
                }
                value = (value || "").toString().replace(/\r?\n|\r/g, " ");
                return this._encodeWords(value);
            case "Content-Type":
            case "Content-Disposition":
                // if it includes a filename then it is already encoded
                return (value || "").toString().replace(/\r?\n|\r/g, " ");
            default:
                value = (value || "").toString().replace(/\r?\n|\r/g, " ");
                // encodeWords only encodes if needed, otherwise the original string is returned
                return this._encodeWords(value);
        }
    }
    /**
     * Rebuilds address object using punycode and other adjustments
     *
     * @param {Array} addresses An array of address objects
     * @param {Array} [uniqueList] An array to be populated with addresses
     * @return {String} address string
     */ _convertAddresses(addresses, uniqueList) {
        let values = [];
        uniqueList = uniqueList || [];
        [].concat(addresses || []).forEach((address)=>{
            if (address.address) {
                address.address = this._normalizeAddress(address.address);
                if (!address.name) {
                    values.push(address.address.indexOf(" ") >= 0 ? `<${address.address}>` : `${address.address}`);
                } else if (address.name) {
                    values.push(`${this._encodeAddressName(address.name)} <${address.address}>`);
                }
                if (address.address) {
                    if (!uniqueList.filter((a)=>a.address === address.address).length) {
                        uniqueList.push(address);
                    }
                }
            } else if (address.group) {
                let groupListAddresses = (address.group.length ? this._convertAddresses(address.group, uniqueList) : "").trim();
                values.push(`${this._encodeAddressName(address.name)}:${groupListAddresses};`);
            }
        });
        return values.join(", ");
    }
    /**
     * Normalizes an email address
     *
     * @param {Array} address An array of address objects
     * @return {String} address string
     */ _normalizeAddress(address) {
        address = (address || "").toString().replace(/[\x00-\x1F<>]+/g, " ") // remove unallowed characters
        .trim();
        let lastAt = address.lastIndexOf("@");
        if (lastAt < 0) {
            // Bare username
            return address;
        }
        let user = address.substr(0, lastAt);
        let domain = address.substr(lastAt + 1);
        // Usernames are not touched and are kept as is even if these include unicode
        // Domains are punycoded by default
        // 'jõgeva.ee' will be converted to 'xn--jgeva-dua.ee'
        // non-unicode domains are left as is
        let encodedDomain;
        try {
            encodedDomain = punycode.toASCII(domain.toLowerCase());
        } catch (err) {
        // keep as is?
        }
        if (user.indexOf(" ") >= 0) {
            if (user.charAt(0) !== '"') {
                user = '"' + user;
            }
            if (user.substr(-1) !== '"') {
                user = user + '"';
            }
        }
        return `${user}@${encodedDomain}`;
    }
    /**
     * If needed, mime encodes the name part
     *
     * @param {String} name Name part of an address
     * @returns {String} Mime word encoded string if needed
     */ _encodeAddressName(name) {
        if (!/^[\w ']*$/.test(name)) {
            if (/^[\x20-\x7e]*$/.test(name)) {
                return '"' + name.replace(/([\\"])/g, "\\$1") + '"';
            } else {
                return mimeFuncs.encodeWord(name, this._getTextEncoding(name), 52);
            }
        }
        return name;
    }
    /**
     * If needed, mime encodes the name part
     *
     * @param {String} name Name part of an address
     * @returns {String} Mime word encoded string if needed
     */ _encodeWords(value) {
        // set encodeAll parameter to true even though it is against the recommendation of RFC2047,
        // by default only words that include non-ascii should be converted into encoded words
        // but some clients (eg. Zimbra) do not handle it properly and remove surrounding whitespace
        return mimeFuncs.encodeWords(value, this._getTextEncoding(value), 52, true);
    }
    /**
     * Detects best mime encoding for a text value
     *
     * @param {String} value Value to check for
     * @return {String} either 'Q' or 'B'
     */ _getTextEncoding(value) {
        value = (value || "").toString();
        let encoding = this.textEncoding;
        let latinLen;
        let nonLatinLen;
        if (!encoding) {
            // count latin alphabet symbols and 8-bit range symbols + control symbols
            // if there are more latin characters, then use quoted-printable
            // encoding, otherwise use base64
            nonLatinLen = (value.match(/[\x00-\x08\x0B\x0C\x0E-\x1F\u0080-\uFFFF]/g) || []).length; // eslint-disable-line no-control-regex
            latinLen = (value.match(/[a-z]/gi) || []).length;
            // if there are more latin symbols than binary/unicode, then prefer Q, otherwise B
            encoding = nonLatinLen < latinLen ? "Q" : "B";
        }
        return encoding;
    }
    /**
     * Generates a message id
     *
     * @return {String} Random Message-ID value
     */ _generateMessageId() {
        return "<" + [
            2,
            2,
            2,
            6
        ].reduce(// crux to generate UUID-like random strings
        (prev, len)=>prev + "-" + crypto.randomBytes(len).toString("hex"), crypto.randomBytes(4).toString("hex")) + "@" + // try to use the domain of the FROM address or fallback to server hostname
        (this.getEnvelope().from || this.hostname || "localhost").split("@").pop() + ">";
    }
}
module.exports = MimeNode;


/***/ }),

/***/ 10873:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const Transform = (__webpack_require__(12781).Transform);
class LastNewline extends Transform {
    constructor(){
        super();
        this.lastByte = false;
    }
    _transform(chunk, encoding, done) {
        if (chunk.length) {
            this.lastByte = chunk[chunk.length - 1];
        }
        this.push(chunk);
        done();
    }
    _flush(done) {
        if (this.lastByte === 0x0a) {
            return done();
        }
        if (this.lastByte === 0x0d) {
            this.push(Buffer.from("\n"));
            return done();
        }
        this.push(Buffer.from("\r\n"));
        return done();
    }
}
module.exports = LastNewline;


/***/ }),

/***/ 67386:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const stream = __webpack_require__(12781);
const Transform = stream.Transform;
/**
 * Ensures that only <LF> is used for linebreaks
 *
 * @param {Object} options Stream options
 */ class LeWindows extends Transform {
    constructor(options){
        super(options);
        // init Transform
        this.options = options || {};
    }
    /**
     * Escapes dots
     */ _transform(chunk, encoding, done) {
        let buf;
        let lastPos = 0;
        for(let i = 0, len = chunk.length; i < len; i++){
            if (chunk[i] === 0x0d) {
                // \n
                buf = chunk.slice(lastPos, i);
                lastPos = i + 1;
                this.push(buf);
            }
        }
        if (lastPos && lastPos < chunk.length) {
            buf = chunk.slice(lastPos);
            this.push(buf);
        } else if (!lastPos) {
            this.push(chunk);
        }
        done();
    }
}
module.exports = LeWindows;


/***/ }),

/***/ 36974:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const stream = __webpack_require__(12781);
const Transform = stream.Transform;
/**
 * Ensures that only <CR><LF> sequences are used for linebreaks
 *
 * @param {Object} options Stream options
 */ class LeWindows extends Transform {
    constructor(options){
        super(options);
        // init Transform
        this.options = options || {};
        this.lastByte = false;
    }
    /**
     * Escapes dots
     */ _transform(chunk, encoding, done) {
        let buf;
        let lastPos = 0;
        for(let i = 0, len = chunk.length; i < len; i++){
            if (chunk[i] === 0x0a) {
                // \n
                if (i && chunk[i - 1] !== 0x0d || !i && this.lastByte !== 0x0d) {
                    if (i > lastPos) {
                        buf = chunk.slice(lastPos, i);
                        this.push(buf);
                    }
                    this.push(Buffer.from("\r\n"));
                    lastPos = i + 1;
                }
            }
        }
        if (lastPos && lastPos < chunk.length) {
            buf = chunk.slice(lastPos);
            this.push(buf);
        } else if (!lastPos) {
            this.push(chunk);
        }
        this.lastByte = chunk[chunk.length - 1];
        done();
    }
}
module.exports = LeWindows;


/***/ }),

/***/ 87795:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const Mailer = __webpack_require__(61469);
const shared = __webpack_require__(74741);
const SMTPPool = __webpack_require__(161);
const SMTPTransport = __webpack_require__(86928);
const SendmailTransport = __webpack_require__(94493);
const StreamTransport = __webpack_require__(71430);
const JSONTransport = __webpack_require__(48261);
const SESTransport = __webpack_require__(60308);
const nmfetch = __webpack_require__(23872);
const packageData = __webpack_require__(98350);
const ETHEREAL_API = (process.env.ETHEREAL_API || "https://api.nodemailer.com").replace(/\/+$/, "");
const ETHEREAL_WEB = (process.env.ETHEREAL_WEB || "https://ethereal.email").replace(/\/+$/, "");
const ETHEREAL_CACHE = [
    "true",
    "yes",
    "y",
    "1"
].includes((process.env.ETHEREAL_CACHE || "yes").toString().trim().toLowerCase());
let testAccount = false;
module.exports.createTransport = function(transporter, defaults) {
    let urlConfig;
    let options;
    let mailer;
    if (// provided transporter is a configuration object, not transporter plugin
    typeof transporter === "object" && typeof transporter.send !== "function" || // provided transporter looks like a connection url
    typeof transporter === "string" && /^(smtps?|direct):/i.test(transporter)) {
        if (urlConfig = typeof transporter === "string" ? transporter : transporter.url) {
            // parse a configuration URL into configuration options
            options = shared.parseConnectionUrl(urlConfig);
        } else {
            options = transporter;
        }
        if (options.pool) {
            transporter = new SMTPPool(options);
        } else if (options.sendmail) {
            transporter = new SendmailTransport(options);
        } else if (options.streamTransport) {
            transporter = new StreamTransport(options);
        } else if (options.jsonTransport) {
            transporter = new JSONTransport(options);
        } else if (options.SES) {
            transporter = new SESTransport(options);
        } else {
            transporter = new SMTPTransport(options);
        }
    }
    mailer = new Mailer(transporter, options, defaults);
    return mailer;
};
module.exports.createTestAccount = function(apiUrl, callback) {
    let promise;
    if (!callback && typeof apiUrl === "function") {
        callback = apiUrl;
        apiUrl = false;
    }
    if (!callback) {
        promise = new Promise((resolve, reject)=>{
            callback = shared.callbackPromise(resolve, reject);
        });
    }
    if (ETHEREAL_CACHE && testAccount) {
        setImmediate(()=>callback(null, testAccount));
        return promise;
    }
    apiUrl = apiUrl || ETHEREAL_API;
    let chunks = [];
    let chunklen = 0;
    let req = nmfetch(apiUrl + "/user", {
        contentType: "application/json",
        method: "POST",
        body: Buffer.from(JSON.stringify({
            requestor: packageData.name,
            version: packageData.version
        }))
    });
    req.on("readable", ()=>{
        let chunk;
        while((chunk = req.read()) !== null){
            chunks.push(chunk);
            chunklen += chunk.length;
        }
    });
    req.once("error", (err)=>callback(err));
    req.once("end", ()=>{
        let res = Buffer.concat(chunks, chunklen);
        let data;
        let err;
        try {
            data = JSON.parse(res.toString());
        } catch (E) {
            err = E;
        }
        if (err) {
            return callback(err);
        }
        if (data.status !== "success" || data.error) {
            return callback(new Error(data.error || "Request failed"));
        }
        delete data.status;
        testAccount = data;
        callback(null, testAccount);
    });
    return promise;
};
module.exports.getTestMessageUrl = function(info) {
    if (!info || !info.response) {
        return false;
    }
    let infoProps = new Map();
    info.response.replace(/\[([^\]]+)\]$/, (m, props)=>{
        props.replace(/\b([A-Z0-9]+)=([^\s]+)/g, (m, key, value)=>{
            infoProps.set(key, value);
        });
    });
    if (infoProps.has("STATUS") && infoProps.has("MSGID")) {
        return (testAccount.web || ETHEREAL_WEB) + "/message/" + infoProps.get("MSGID");
    }
    return false;
};


/***/ }),

/***/ 9050:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const Transform = (__webpack_require__(12781).Transform);
/**
 * Encodes a Buffer into a Quoted-Printable encoded string
 *
 * @param {Buffer} buffer Buffer to convert
 * @returns {String} Quoted-Printable encoded string
 */ function encode(buffer) {
    if (typeof buffer === "string") {
        buffer = Buffer.from(buffer, "utf-8");
    }
    // usable characters that do not need encoding
    let ranges = [
        // https://tools.ietf.org/html/rfc2045#section-6.7
        [
            0x09
        ],
        [
            0x0a
        ],
        [
            0x0d
        ],
        [
            0x20,
            0x3c
        ],
        [
            0x3e,
            0x7e
        ] // >?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}
    ];
    let result = "";
    let ord;
    for(let i = 0, len = buffer.length; i < len; i++){
        ord = buffer[i];
        // if the char is in allowed range, then keep as is, unless it is a WS in the end of a line
        if (checkRanges(ord, ranges) && !((ord === 0x20 || ord === 0x09) && (i === len - 1 || buffer[i + 1] === 0x0a || buffer[i + 1] === 0x0d))) {
            result += String.fromCharCode(ord);
            continue;
        }
        result += "=" + (ord < 0x10 ? "0" : "") + ord.toString(16).toUpperCase();
    }
    return result;
}
/**
 * Adds soft line breaks to a Quoted-Printable string
 *
 * @param {String} str Quoted-Printable encoded string that might need line wrapping
 * @param {Number} [lineLength=76] Maximum allowed length for a line
 * @returns {String} Soft-wrapped Quoted-Printable encoded string
 */ function wrap(str, lineLength) {
    str = (str || "").toString();
    lineLength = lineLength || 76;
    if (str.length <= lineLength) {
        return str;
    }
    let pos = 0;
    let len = str.length;
    let match, code, line;
    let lineMargin = Math.floor(lineLength / 3);
    let result = "";
    // insert soft linebreaks where needed
    while(pos < len){
        line = str.substr(pos, lineLength);
        if (match = line.match(/\r\n/)) {
            line = line.substr(0, match.index + match[0].length);
            result += line;
            pos += line.length;
            continue;
        }
        if (line.substr(-1) === "\n") {
            // nothing to change here
            result += line;
            pos += line.length;
            continue;
        } else if (match = line.substr(-lineMargin).match(/\n.*?$/)) {
            // truncate to nearest line break
            line = line.substr(0, line.length - (match[0].length - 1));
            result += line;
            pos += line.length;
            continue;
        } else if (line.length > lineLength - lineMargin && (match = line.substr(-lineMargin).match(/[ \t.,!?][^ \t.,!?]*$/))) {
            // truncate to nearest space
            line = line.substr(0, line.length - (match[0].length - 1));
        } else if (line.match(/[=][\da-f]{0,2}$/i)) {
            // push incomplete encoding sequences to the next line
            if (match = line.match(/[=][\da-f]{0,1}$/i)) {
                line = line.substr(0, line.length - match[0].length);
            }
            // ensure that utf-8 sequences are not split
            while(line.length > 3 && line.length < len - pos && !line.match(/^(?:=[\da-f]{2}){1,4}$/i) && (match = line.match(/[=][\da-f]{2}$/gi))){
                code = parseInt(match[0].substr(1, 2), 16);
                if (code < 128) {
                    break;
                }
                line = line.substr(0, line.length - 3);
                if (code >= 0xc0) {
                    break;
                }
            }
        }
        if (pos + line.length < len && line.substr(-1) !== "\n") {
            if (line.length === lineLength && line.match(/[=][\da-f]{2}$/i)) {
                line = line.substr(0, line.length - 3);
            } else if (line.length === lineLength) {
                line = line.substr(0, line.length - 1);
            }
            pos += line.length;
            line += "=\r\n";
        } else {
            pos += line.length;
        }
        result += line;
    }
    return result;
}
/**
 * Helper function to check if a number is inside provided ranges
 *
 * @param {Number} nr Number to check for
 * @param {Array} ranges An Array of allowed values
 * @returns {Boolean} True if the value was found inside allowed ranges, false otherwise
 */ function checkRanges(nr, ranges) {
    for(let i = ranges.length - 1; i >= 0; i--){
        if (!ranges[i].length) {
            continue;
        }
        if (ranges[i].length === 1 && nr === ranges[i][0]) {
            return true;
        }
        if (ranges[i].length === 2 && nr >= ranges[i][0] && nr <= ranges[i][1]) {
            return true;
        }
    }
    return false;
}
/**
 * Creates a transform stream for encoding data to Quoted-Printable encoding
 *
 * @constructor
 * @param {Object} options Stream options
 * @param {Number} [options.lineLength=76] Maximum length for lines, set to false to disable wrapping
 */ class Encoder extends Transform {
    constructor(options){
        super();
        // init Transform
        this.options = options || {};
        if (this.options.lineLength !== false) {
            this.options.lineLength = this.options.lineLength || 76;
        }
        this._curLine = "";
        this.inputBytes = 0;
        this.outputBytes = 0;
    }
    _transform(chunk, encoding, done) {
        let qp;
        if (encoding !== "buffer") {
            chunk = Buffer.from(chunk, encoding);
        }
        if (!chunk || !chunk.length) {
            return done();
        }
        this.inputBytes += chunk.length;
        if (this.options.lineLength) {
            qp = this._curLine + encode(chunk);
            qp = wrap(qp, this.options.lineLength);
            qp = qp.replace(/(^|\n)([^\n]*)$/, (match, lineBreak, lastLine)=>{
                this._curLine = lastLine;
                return lineBreak;
            });
            if (qp) {
                this.outputBytes += qp.length;
                this.push(qp);
            }
        } else {
            qp = encode(chunk);
            this.outputBytes += qp.length;
            this.push(qp, "ascii");
        }
        done();
    }
    _flush(done) {
        if (this._curLine) {
            this.outputBytes += this._curLine.length;
            this.push(this._curLine, "ascii");
        }
        done();
    }
}
// expose to the world
module.exports = {
    encode,
    wrap,
    Encoder
};


/***/ }),

/***/ 94493:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const spawn = (__webpack_require__(32081).spawn);
const packageData = __webpack_require__(98350);
const shared = __webpack_require__(74741);
/**
 * Generates a Transport object for Sendmail
 *
 * Possible options can be the following:
 *
 *  * **path** optional path to sendmail binary
 *  * **newline** either 'windows' or 'unix'
 *  * **args** an array of arguments for the sendmail binary
 *
 * @constructor
 * @param {Object} optional config parameter for Sendmail
 */ class SendmailTransport {
    constructor(options){
        options = options || {};
        // use a reference to spawn for mocking purposes
        this._spawn = spawn;
        this.options = options || {};
        this.name = "Sendmail";
        this.version = packageData.version;
        this.path = "sendmail";
        this.args = false;
        this.winbreak = false;
        this.logger = shared.getLogger(this.options, {
            component: this.options.component || "sendmail"
        });
        if (options) {
            if (typeof options === "string") {
                this.path = options;
            } else if (typeof options === "object") {
                if (options.path) {
                    this.path = options.path;
                }
                if (Array.isArray(options.args)) {
                    this.args = options.args;
                }
                this.winbreak = [
                    "win",
                    "windows",
                    "dos",
                    "\r\n"
                ].includes((options.newline || "").toString().toLowerCase());
            }
        }
    }
    /**
     * <p>Compiles a mailcomposer message and forwards it to handler that sends it.</p>
     *
     * @param {Object} emailMessage MailComposer object
     * @param {Function} callback Callback function to run when the sending is completed
     */ send(mail, done) {
        // Sendmail strips this header line by itself
        mail.message.keepBcc = true;
        let envelope = mail.data.envelope || mail.message.getEnvelope();
        let messageId = mail.message.messageId();
        let args;
        let sendmail;
        let returned;
        const hasInvalidAddresses = [].concat(envelope.from || []).concat(envelope.to || []).some((addr)=>/^-/.test(addr));
        if (hasInvalidAddresses) {
            return done(new Error("Can not send mail. Invalid envelope addresses."));
        }
        if (this.args) {
            // force -i to keep single dots
            args = [
                "-i"
            ].concat(this.args).concat(envelope.to);
        } else {
            args = [
                "-i"
            ].concat(envelope.from ? [
                "-f",
                envelope.from
            ] : []).concat(envelope.to);
        }
        let callback = (err)=>{
            if (returned) {
                // ignore any additional responses, already done
                return;
            }
            returned = true;
            if (typeof done === "function") {
                if (err) {
                    return done(err);
                } else {
                    return done(null, {
                        envelope: mail.data.envelope || mail.message.getEnvelope(),
                        messageId,
                        response: "Messages queued for delivery"
                    });
                }
            }
        };
        try {
            sendmail = this._spawn(this.path, args);
        } catch (E) {
            this.logger.error({
                err: E,
                tnx: "spawn",
                messageId
            }, "Error occurred while spawning sendmail. %s", E.message);
            return callback(E);
        }
        if (sendmail) {
            sendmail.on("error", (err)=>{
                this.logger.error({
                    err,
                    tnx: "spawn",
                    messageId
                }, "Error occurred when sending message %s. %s", messageId, err.message);
                callback(err);
            });
            sendmail.once("exit", (code)=>{
                if (!code) {
                    return callback();
                }
                let err;
                if (code === 127) {
                    err = new Error("Sendmail command not found, process exited with code " + code);
                } else {
                    err = new Error("Sendmail exited with code " + code);
                }
                this.logger.error({
                    err,
                    tnx: "stdin",
                    messageId
                }, "Error sending message %s to sendmail. %s", messageId, err.message);
                callback(err);
            });
            sendmail.once("close", callback);
            sendmail.stdin.on("error", (err)=>{
                this.logger.error({
                    err,
                    tnx: "stdin",
                    messageId
                }, "Error occurred when piping message %s to sendmail. %s", messageId, err.message);
                callback(err);
            });
            let recipients = [].concat(envelope.to || []);
            if (recipients.length > 3) {
                recipients.push("...and " + recipients.splice(2).length + " more");
            }
            this.logger.info({
                tnx: "send",
                messageId
            }, "Sending message %s to <%s>", messageId, recipients.join(", "));
            let sourceStream = mail.message.createReadStream();
            sourceStream.once("error", (err)=>{
                this.logger.error({
                    err,
                    tnx: "stdin",
                    messageId
                }, "Error occurred when generating message %s. %s", messageId, err.message);
                sendmail.kill("SIGINT"); // do not deliver the message
                callback(err);
            });
            sourceStream.pipe(sendmail.stdin);
        } else {
            return callback(new Error("sendmail was not found"));
        }
    }
}
module.exports = SendmailTransport;


/***/ }),

/***/ 60308:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const EventEmitter = __webpack_require__(82361);
const packageData = __webpack_require__(98350);
const shared = __webpack_require__(74741);
const LeWindows = __webpack_require__(36974);
/**
 * Generates a Transport object for AWS SES
 *
 * Possible options can be the following:
 *
 *  * **sendingRate** optional Number specifying how many messages per second should be delivered to SES
 *  * **maxConnections** optional Number specifying max number of parallel connections to SES
 *
 * @constructor
 * @param {Object} optional config parameter
 */ class SESTransport extends EventEmitter {
    constructor(options){
        super();
        options = options || {};
        this.options = options || {};
        this.ses = this.options.SES;
        this.name = "SESTransport";
        this.version = packageData.version;
        this.logger = shared.getLogger(this.options, {
            component: this.options.component || "ses-transport"
        });
        // parallel sending connections
        this.maxConnections = Number(this.options.maxConnections) || Infinity;
        this.connections = 0;
        // max messages per second
        this.sendingRate = Number(this.options.sendingRate) || Infinity;
        this.sendingRateTTL = null;
        this.rateInterval = 1000; // milliseconds
        this.rateMessages = [];
        this.pending = [];
        this.idling = true;
        setImmediate(()=>{
            if (this.idling) {
                this.emit("idle");
            }
        });
    }
    /**
     * Schedules a sending of a message
     *
     * @param {Object} emailMessage MailComposer object
     * @param {Function} callback Callback function to run when the sending is completed
     */ send(mail, callback) {
        if (this.connections >= this.maxConnections) {
            this.idling = false;
            return this.pending.push({
                mail,
                callback
            });
        }
        if (!this._checkSendingRate()) {
            this.idling = false;
            return this.pending.push({
                mail,
                callback
            });
        }
        this._send(mail, (...args)=>{
            setImmediate(()=>callback(...args));
            this._sent();
        });
    }
    _checkRatedQueue() {
        if (this.connections >= this.maxConnections || !this._checkSendingRate()) {
            return;
        }
        if (!this.pending.length) {
            if (!this.idling) {
                this.idling = true;
                this.emit("idle");
            }
            return;
        }
        let next = this.pending.shift();
        this._send(next.mail, (...args)=>{
            setImmediate(()=>next.callback(...args));
            this._sent();
        });
    }
    _checkSendingRate() {
        clearTimeout(this.sendingRateTTL);
        let now = Date.now();
        let oldest = false;
        // delete older messages
        for(let i = this.rateMessages.length - 1; i >= 0; i--){
            if (this.rateMessages[i].ts >= now - this.rateInterval && (!oldest || this.rateMessages[i].ts < oldest)) {
                oldest = this.rateMessages[i].ts;
            }
            if (this.rateMessages[i].ts < now - this.rateInterval && !this.rateMessages[i].pending) {
                this.rateMessages.splice(i, 1);
            }
        }
        if (this.rateMessages.length < this.sendingRate) {
            return true;
        }
        let delay = Math.max(oldest + 1001, now + 20);
        this.sendingRateTTL = setTimeout(()=>this._checkRatedQueue(), now - delay);
        try {
            this.sendingRateTTL.unref();
        } catch (E) {
        // Ignore. Happens on envs with non-node timer implementation
        }
        return false;
    }
    _sent() {
        this.connections--;
        this._checkRatedQueue();
    }
    /**
     * Returns true if there are free slots in the queue
     */ isIdle() {
        return this.idling;
    }
    /**
     * Compiles a mailcomposer message and forwards it to SES
     *
     * @param {Object} emailMessage MailComposer object
     * @param {Function} callback Callback function to run when the sending is completed
     */ _send(mail, callback) {
        let statObject = {
            ts: Date.now(),
            pending: true
        };
        this.connections++;
        this.rateMessages.push(statObject);
        let envelope = mail.data.envelope || mail.message.getEnvelope();
        let messageId = mail.message.messageId();
        let recipients = [].concat(envelope.to || []);
        if (recipients.length > 3) {
            recipients.push("...and " + recipients.splice(2).length + " more");
        }
        this.logger.info({
            tnx: "send",
            messageId
        }, "Sending message %s to <%s>", messageId, recipients.join(", "));
        let getRawMessage = (next)=>{
            // do not use Message-ID and Date in DKIM signature
            if (!mail.data._dkim) {
                mail.data._dkim = {};
            }
            if (mail.data._dkim.skipFields && typeof mail.data._dkim.skipFields === "string") {
                mail.data._dkim.skipFields += ":date:message-id";
            } else {
                mail.data._dkim.skipFields = "date:message-id";
            }
            let sourceStream = mail.message.createReadStream();
            let stream = sourceStream.pipe(new LeWindows());
            let chunks = [];
            let chunklen = 0;
            stream.on("readable", ()=>{
                let chunk;
                while((chunk = stream.read()) !== null){
                    chunks.push(chunk);
                    chunklen += chunk.length;
                }
            });
            sourceStream.once("error", (err)=>stream.emit("error", err));
            stream.once("error", (err)=>{
                next(err);
            });
            stream.once("end", ()=>next(null, Buffer.concat(chunks, chunklen)));
        };
        setImmediate(()=>getRawMessage((err, raw)=>{
                if (err) {
                    this.logger.error({
                        err,
                        tnx: "send",
                        messageId
                    }, "Failed creating message for %s. %s", messageId, err.message);
                    statObject.pending = false;
                    return callback(err);
                }
                let sesMessage = {
                    RawMessage: {
                        // required
                        Data: raw // required
                    },
                    Source: envelope.from,
                    Destinations: envelope.to
                };
                Object.keys(mail.data.ses || {}).forEach((key)=>{
                    sesMessage[key] = mail.data.ses[key];
                });
                let ses = (this.ses.aws ? this.ses.ses : this.ses) || {};
                let aws = this.ses.aws || {};
                let getRegion = (cb)=>{
                    if (ses.config && typeof ses.config.region === "function") {
                        // promise
                        return ses.config.region().then((region)=>cb(null, region)).catch((err)=>cb(err));
                    }
                    return cb(null, ses.config && ses.config.region || "us-east-1");
                };
                getRegion((err, region)=>{
                    if (err || !region) {
                        region = "us-east-1";
                    }
                    let sendPromise;
                    if (typeof ses.send === "function" && aws.SendRawEmailCommand) {
                        // v3 API
                        sendPromise = ses.send(new aws.SendRawEmailCommand(sesMessage));
                    } else {
                        // v2 API
                        sendPromise = ses.sendRawEmail(sesMessage).promise();
                    }
                    sendPromise.then((data)=>{
                        if (region === "us-east-1") {
                            region = "email";
                        }
                        statObject.pending = false;
                        callback(null, {
                            envelope: {
                                from: envelope.from,
                                to: envelope.to
                            },
                            messageId: "<" + data.MessageId + (!/@/.test(data.MessageId) ? "@" + region + ".amazonses.com" : "") + ">",
                            response: data.MessageId,
                            raw
                        });
                    }).catch((err)=>{
                        this.logger.error({
                            err,
                            tnx: "send"
                        }, "Send error for %s: %s", messageId, err.message);
                        statObject.pending = false;
                        callback(err);
                    });
                });
            }));
    }
    /**
     * Verifies SES configuration
     *
     * @param {Function} callback Callback function
     */ verify(callback) {
        let promise;
        let ses = (this.ses.aws ? this.ses.ses : this.ses) || {};
        let aws = this.ses.aws || {};
        const sesMessage = {
            RawMessage: {
                // required
                Data: "From: invalid@invalid\r\nTo: invalid@invalid\r\n Subject: Invalid\r\n\r\nInvalid"
            },
            Source: "invalid@invalid",
            Destinations: [
                "invalid@invalid"
            ]
        };
        if (!callback) {
            promise = new Promise((resolve, reject)=>{
                callback = shared.callbackPromise(resolve, reject);
            });
        }
        const cb = (err)=>{
            if (err && (err.code || err.Code) !== "InvalidParameterValue") {
                return callback(err);
            }
            return callback(null, true);
        };
        if (typeof ses.send === "function" && aws.SendRawEmailCommand) {
            // v3 API
            sesMessage.RawMessage.Data = Buffer.from(sesMessage.RawMessage.Data);
            ses.send(new aws.SendRawEmailCommand(sesMessage), cb);
        } else {
            // v2 API
            ses.sendRawEmail(sesMessage, cb);
        }
        return promise;
    }
}
module.exports = SESTransport;


/***/ }),

/***/ 74741:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-console: 0 */ 
const urllib = __webpack_require__(57310);
const util = __webpack_require__(73837);
const fs = __webpack_require__(57147);
const nmfetch = __webpack_require__(23872);
const dns = __webpack_require__(9523);
const net = __webpack_require__(41808);
const os = __webpack_require__(22037);
const DNS_TTL = 5 * 60 * 1000;
let networkInterfaces;
try {
    networkInterfaces = os.networkInterfaces();
} catch (err) {
// fails on some systems
}
module.exports.networkInterfaces = networkInterfaces;
const isFamilySupported = (family, allowInternal)=>{
    let networkInterfaces = module.exports.networkInterfaces;
    if (!networkInterfaces) {
        // hope for the best
        return true;
    }
    const familySupported = // crux that replaces Object.values(networkInterfaces) as Object.values is not supported in nodejs v6
    Object.keys(networkInterfaces).map((key)=>networkInterfaces[key])// crux that replaces .flat() as it is not supported in older Node versions (v10 and older)
    .reduce((acc, val)=>acc.concat(val), []).filter((i)=>!i.internal || allowInternal).filter((i)=>i.family === "IPv" + family || i.family === family).length > 0;
    return familySupported;
};
const resolver = (family, hostname, options, callback)=>{
    options = options || {};
    const familySupported = isFamilySupported(family, options.allowInternalNetworkInterfaces);
    if (!familySupported) {
        return callback(null, []);
    }
    const resolver = dns.Resolver ? new dns.Resolver(options) : dns;
    resolver["resolve" + family](hostname, (err, addresses)=>{
        if (err) {
            switch(err.code){
                case dns.NODATA:
                case dns.NOTFOUND:
                case dns.NOTIMP:
                case dns.SERVFAIL:
                case dns.CONNREFUSED:
                case dns.REFUSED:
                case "EAI_AGAIN":
                    return callback(null, []);
            }
            return callback(err);
        }
        return callback(null, Array.isArray(addresses) ? addresses : [].concat(addresses || []));
    });
};
const dnsCache = module.exports.dnsCache = new Map();
const formatDNSValue = (value, extra)=>{
    if (!value) {
        return Object.assign({}, extra || {});
    }
    return Object.assign({
        servername: value.servername,
        host: !value.addresses || !value.addresses.length ? null : value.addresses.length === 1 ? value.addresses[0] : value.addresses[Math.floor(Math.random() * value.addresses.length)]
    }, extra || {});
};
module.exports.resolveHostname = (options, callback)=>{
    options = options || {};
    if (!options.host && options.servername) {
        options.host = options.servername;
    }
    if (!options.host || net.isIP(options.host)) {
        // nothing to do here
        let value = {
            addresses: [
                options.host
            ],
            servername: options.servername || false
        };
        return callback(null, formatDNSValue(value, {
            cached: false
        }));
    }
    let cached;
    if (dnsCache.has(options.host)) {
        cached = dnsCache.get(options.host);
        if (!cached.expires || cached.expires >= Date.now()) {
            return callback(null, formatDNSValue(cached.value, {
                cached: true
            }));
        }
    }
    resolver(4, options.host, options, (err, addresses)=>{
        if (err) {
            if (cached) {
                // ignore error, use expired value
                return callback(null, formatDNSValue(cached.value, {
                    cached: true,
                    error: err
                }));
            }
            return callback(err);
        }
        if (addresses && addresses.length) {
            let value = {
                addresses,
                servername: options.servername || options.host
            };
            dnsCache.set(options.host, {
                value,
                expires: Date.now() + (options.dnsTtl || DNS_TTL)
            });
            return callback(null, formatDNSValue(value, {
                cached: false
            }));
        }
        resolver(6, options.host, options, (err, addresses)=>{
            if (err) {
                if (cached) {
                    // ignore error, use expired value
                    return callback(null, formatDNSValue(cached.value, {
                        cached: true,
                        error: err
                    }));
                }
                return callback(err);
            }
            if (addresses && addresses.length) {
                let value = {
                    addresses,
                    servername: options.servername || options.host
                };
                dnsCache.set(options.host, {
                    value,
                    expires: Date.now() + (options.dnsTtl || DNS_TTL)
                });
                return callback(null, formatDNSValue(value, {
                    cached: false
                }));
            }
            try {
                dns.lookup(options.host, {
                    all: true
                }, (err, addresses)=>{
                    if (err) {
                        if (cached) {
                            // ignore error, use expired value
                            return callback(null, formatDNSValue(cached.value, {
                                cached: true,
                                error: err
                            }));
                        }
                        return callback(err);
                    }
                    let address = addresses ? addresses.filter((addr)=>isFamilySupported(addr.family)).map((addr)=>addr.address).shift() : false;
                    if (addresses && addresses.length && !address) {
                        // there are addresses but none can be used
                        let err1 = new Error(`Can not use IPv${addresses[0].family} addresses with current network`);
                        return callback(err1);
                    }
                    if (!address && cached) {
                        // nothing was found, fallback to cached value
                        return callback(null, formatDNSValue(cached.value, {
                            cached: true
                        }));
                    }
                    let value = {
                        addresses: address ? [
                            address
                        ] : [
                            options.host
                        ],
                        servername: options.servername || options.host
                    };
                    dnsCache.set(options.host, {
                        value,
                        expires: Date.now() + (options.dnsTtl || DNS_TTL)
                    });
                    return callback(null, formatDNSValue(value, {
                        cached: false
                    }));
                });
            } catch (err1) {
                if (cached) {
                    // ignore error, use expired value
                    return callback(null, formatDNSValue(cached.value, {
                        cached: true,
                        error: err1
                    }));
                }
                return callback(err1);
            }
        });
    });
};
/**
 * Parses connection url to a structured configuration object
 *
 * @param {String} str Connection url
 * @return {Object} Configuration object
 */ module.exports.parseConnectionUrl = (str)=>{
    str = str || "";
    let options = {};
    [
        urllib.parse(str, true)
    ].forEach((url)=>{
        let auth;
        switch(url.protocol){
            case "smtp:":
                options.secure = false;
                break;
            case "smtps:":
                options.secure = true;
                break;
            case "direct:":
                options.direct = true;
                break;
        }
        if (!isNaN(url.port) && Number(url.port)) {
            options.port = Number(url.port);
        }
        if (url.hostname) {
            options.host = url.hostname;
        }
        if (url.auth) {
            auth = url.auth.split(":");
            if (!options.auth) {
                options.auth = {};
            }
            options.auth.user = auth.shift();
            options.auth.pass = auth.join(":");
        }
        Object.keys(url.query || {}).forEach((key)=>{
            let obj = options;
            let lKey = key;
            let value = url.query[key];
            if (!isNaN(value)) {
                value = Number(value);
            }
            switch(value){
                case "true":
                    value = true;
                    break;
                case "false":
                    value = false;
                    break;
            }
            // tls is nested object
            if (key.indexOf("tls.") === 0) {
                lKey = key.substr(4);
                if (!options.tls) {
                    options.tls = {};
                }
                obj = options.tls;
            } else if (key.indexOf(".") >= 0) {
                // ignore nested properties besides tls
                return;
            }
            if (!(lKey in obj)) {
                obj[lKey] = value;
            }
        });
    });
    return options;
};
module.exports._logFunc = (logger, level, defaults, data, message, ...args)=>{
    let entry = {};
    Object.keys(defaults || {}).forEach((key)=>{
        if (key !== "level") {
            entry[key] = defaults[key];
        }
    });
    Object.keys(data || {}).forEach((key)=>{
        if (key !== "level") {
            entry[key] = data[key];
        }
    });
    logger[level](entry, message, ...args);
};
/**
 * Returns a bunyan-compatible logger interface. Uses either provided logger or
 * creates a default console logger
 *
 * @param {Object} [options] Options object that might include 'logger' value
 * @return {Object} bunyan compatible logger
 */ module.exports.getLogger = (options, defaults)=>{
    options = options || {};
    let response = {};
    let levels = [
        "trace",
        "debug",
        "info",
        "warn",
        "error",
        "fatal"
    ];
    if (!options.logger) {
        // use vanity logger
        levels.forEach((level)=>{
            response[level] = ()=>false;
        });
        return response;
    }
    let logger = options.logger;
    if (options.logger === true) {
        // create console logger
        logger = createDefaultLogger(levels);
    }
    levels.forEach((level)=>{
        response[level] = (data, message, ...args)=>{
            module.exports._logFunc(logger, level, defaults, data, message, ...args);
        };
    });
    return response;
};
/**
 * Wrapper for creating a callback that either resolves or rejects a promise
 * based on input
 *
 * @param {Function} resolve Function to run if callback is called
 * @param {Function} reject Function to run if callback ends with an error
 */ module.exports.callbackPromise = (resolve, reject)=>function() {
        let args = Array.from(arguments);
        let err = args.shift();
        if (err) {
            reject(err);
        } else {
            resolve(...args);
        }
    };
/**
 * Resolves a String or a Buffer value for content value. Useful if the value
 * is a Stream or a file or an URL. If the value is a Stream, overwrites
 * the stream object with the resolved value (you can't stream a value twice).
 *
 * This is useful when you want to create a plugin that needs a content value,
 * for example the `html` or `text` value as a String or a Buffer but not as
 * a file path or an URL.
 *
 * @param {Object} data An object or an Array you want to resolve an element for
 * @param {String|Number} key Property name or an Array index
 * @param {Function} callback Callback function with (err, value)
 */ module.exports.resolveContent = (data, key, callback)=>{
    let promise;
    if (!callback) {
        promise = new Promise((resolve, reject)=>{
            callback = module.exports.callbackPromise(resolve, reject);
        });
    }
    let content = data && data[key] && data[key].content || data[key];
    let contentStream;
    let encoding = (typeof data[key] === "object" && data[key].encoding || "utf8").toString().toLowerCase().replace(/[-_\s]/g, "");
    if (!content) {
        return callback(null, content);
    }
    if (typeof content === "object") {
        if (typeof content.pipe === "function") {
            return resolveStream(content, (err, value)=>{
                if (err) {
                    return callback(err);
                }
                // we can't stream twice the same content, so we need
                // to replace the stream object with the streaming result
                if (data[key].content) {
                    data[key].content = value;
                } else {
                    data[key] = value;
                }
                callback(null, value);
            });
        } else if (/^https?:\/\//i.test(content.path || content.href)) {
            contentStream = nmfetch(content.path || content.href);
            return resolveStream(contentStream, callback);
        } else if (/^data:/i.test(content.path || content.href)) {
            let parts = (content.path || content.href).match(/^data:((?:[^;]*;)*(?:[^,]*)),(.*)$/i);
            if (!parts) {
                return callback(null, Buffer.from(0));
            }
            return callback(null, /\bbase64$/i.test(parts[1]) ? Buffer.from(parts[2], "base64") : Buffer.from(decodeURIComponent(parts[2])));
        } else if (content.path) {
            return resolveStream(fs.createReadStream(content.path), callback);
        }
    }
    if (typeof data[key].content === "string" && ![
        "utf8",
        "usascii",
        "ascii"
    ].includes(encoding)) {
        content = Buffer.from(data[key].content, encoding);
    }
    // default action, return as is
    setImmediate(()=>callback(null, content));
    return promise;
};
/**
 * Copies properties from source objects to target objects
 */ module.exports.assign = function() {
    let args = Array.from(arguments);
    let target = args.shift() || {};
    args.forEach((source)=>{
        Object.keys(source || {}).forEach((key)=>{
            if ([
                "tls",
                "auth"
            ].includes(key) && source[key] && typeof source[key] === "object") {
                // tls and auth are special keys that need to be enumerated separately
                // other objects are passed as is
                if (!target[key]) {
                    // ensure that target has this key
                    target[key] = {};
                }
                Object.keys(source[key]).forEach((subKey)=>{
                    target[key][subKey] = source[key][subKey];
                });
            } else {
                target[key] = source[key];
            }
        });
    });
    return target;
};
module.exports.encodeXText = (str)=>{
    // ! 0x21
    // + 0x2B
    // = 0x3D
    // ~ 0x7E
    if (!/[^\x21-\x2A\x2C-\x3C\x3E-\x7E]/.test(str)) {
        return str;
    }
    let buf = Buffer.from(str);
    let result = "";
    for(let i = 0, len = buf.length; i < len; i++){
        let c = buf[i];
        if (c < 0x21 || c > 0x7e || c === 0x2b || c === 0x3d) {
            result += "+" + (c < 0x10 ? "0" : "") + c.toString(16).toUpperCase();
        } else {
            result += String.fromCharCode(c);
        }
    }
    return result;
};
/**
 * Streams a stream value into a Buffer
 *
 * @param {Object} stream Readable stream
 * @param {Function} callback Callback function with (err, value)
 */ function resolveStream(stream, callback) {
    let responded = false;
    let chunks = [];
    let chunklen = 0;
    stream.on("error", (err)=>{
        if (responded) {
            return;
        }
        responded = true;
        callback(err);
    });
    stream.on("readable", ()=>{
        let chunk;
        while((chunk = stream.read()) !== null){
            chunks.push(chunk);
            chunklen += chunk.length;
        }
    });
    stream.on("end", ()=>{
        if (responded) {
            return;
        }
        responded = true;
        let value;
        try {
            value = Buffer.concat(chunks, chunklen);
        } catch (E) {
            return callback(E);
        }
        callback(null, value);
    });
}
/**
 * Generates a bunyan-like logger that prints to console
 *
 * @returns {Object} Bunyan logger instance
 */ function createDefaultLogger(levels) {
    let levelMaxLen = 0;
    let levelNames = new Map();
    levels.forEach((level)=>{
        if (level.length > levelMaxLen) {
            levelMaxLen = level.length;
        }
    });
    levels.forEach((level)=>{
        let levelName = level.toUpperCase();
        if (levelName.length < levelMaxLen) {
            levelName += " ".repeat(levelMaxLen - levelName.length);
        }
        levelNames.set(level, levelName);
    });
    let print = (level, entry, message, ...args)=>{
        let prefix = "";
        if (entry) {
            if (entry.tnx === "server") {
                prefix = "S: ";
            } else if (entry.tnx === "client") {
                prefix = "C: ";
            }
            if (entry.sid) {
                prefix = "[" + entry.sid + "] " + prefix;
            }
            if (entry.cid) {
                prefix = "[#" + entry.cid + "] " + prefix;
            }
        }
        message = util.format(message, ...args);
        message.split(/\r?\n/).forEach((line)=>{
            console.log("[%s] %s %s", new Date().toISOString().substr(0, 19).replace(/T/, " "), levelNames.get(level), prefix + line);
        });
    };
    let logger = {};
    levels.forEach((level)=>{
        logger[level] = print.bind(null, level);
    });
    return logger;
}


/***/ }),

/***/ 99682:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const stream = __webpack_require__(12781);
const Transform = stream.Transform;
/**
 * Escapes dots in the beginning of lines. Ends the stream with <CR><LF>.<CR><LF>
 * Also makes sure that only <CR><LF> sequences are used for linebreaks
 *
 * @param {Object} options Stream options
 */ class DataStream extends Transform {
    constructor(options){
        super(options);
        // init Transform
        this.options = options || {};
        this._curLine = "";
        this.inByteCount = 0;
        this.outByteCount = 0;
        this.lastByte = false;
    }
    /**
     * Escapes dots
     */ _transform(chunk, encoding, done) {
        let chunks = [];
        let chunklen = 0;
        let i, len, lastPos = 0;
        let buf;
        if (!chunk || !chunk.length) {
            return done();
        }
        if (typeof chunk === "string") {
            chunk = Buffer.from(chunk);
        }
        this.inByteCount += chunk.length;
        for(i = 0, len = chunk.length; i < len; i++){
            if (chunk[i] === 0x2e) {
                // .
                if (i && chunk[i - 1] === 0x0a || !i && (!this.lastByte || this.lastByte === 0x0a)) {
                    buf = chunk.slice(lastPos, i + 1);
                    chunks.push(buf);
                    chunks.push(Buffer.from("."));
                    chunklen += buf.length + 1;
                    lastPos = i + 1;
                }
            } else if (chunk[i] === 0x0a) {
                // .
                if (i && chunk[i - 1] !== 0x0d || !i && this.lastByte !== 0x0d) {
                    if (i > lastPos) {
                        buf = chunk.slice(lastPos, i);
                        chunks.push(buf);
                        chunklen += buf.length + 2;
                    } else {
                        chunklen += 2;
                    }
                    chunks.push(Buffer.from("\r\n"));
                    lastPos = i + 1;
                }
            }
        }
        if (chunklen) {
            // add last piece
            if (lastPos < chunk.length) {
                buf = chunk.slice(lastPos);
                chunks.push(buf);
                chunklen += buf.length;
            }
            this.outByteCount += chunklen;
            this.push(Buffer.concat(chunks, chunklen));
        } else {
            this.outByteCount += chunk.length;
            this.push(chunk);
        }
        this.lastByte = chunk[chunk.length - 1];
        done();
    }
    /**
     * Finalizes the stream with a dot on a single line
     */ _flush(done) {
        let buf;
        if (this.lastByte === 0x0a) {
            buf = Buffer.from(".\r\n");
        } else if (this.lastByte === 0x0d) {
            buf = Buffer.from("\n.\r\n");
        } else {
            buf = Buffer.from("\r\n.\r\n");
        }
        this.outByteCount += buf.length;
        this.push(buf);
        done();
    }
}
module.exports = DataStream;


/***/ }),

/***/ 43992:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/**
 * Minimal HTTP/S proxy client
 */ const net = __webpack_require__(41808);
const tls = __webpack_require__(24404);
const urllib = __webpack_require__(57310);
/**
 * Establishes proxied connection to destinationPort
 *
 * httpProxyClient("http://localhost:3128/", 80, "google.com", function(err, socket){
 *     socket.write("GET / HTTP/1.0\r\n\r\n");
 * });
 *
 * @param {String} proxyUrl proxy configuration, etg "http://proxy.host:3128/"
 * @param {Number} destinationPort Port to open in destination host
 * @param {String} destinationHost Destination hostname
 * @param {Function} callback Callback to run with the rocket object once connection is established
 */ function httpProxyClient(proxyUrl, destinationPort, destinationHost, callback) {
    let proxy = urllib.parse(proxyUrl);
    // create a socket connection to the proxy server
    let options;
    let connect;
    let socket;
    options = {
        host: proxy.hostname,
        port: Number(proxy.port) ? Number(proxy.port) : proxy.protocol === "https:" ? 443 : 80
    };
    if (proxy.protocol === "https:") {
        // we can use untrusted proxies as long as we verify actual SMTP certificates
        options.rejectUnauthorized = false;
        connect = tls.connect.bind(tls);
    } else {
        connect = net.connect.bind(net);
    }
    // Error harness for initial connection. Once connection is established, the responsibility
    // to handle errors is passed to whoever uses this socket
    let finished = false;
    let tempSocketErr = (err)=>{
        if (finished) {
            return;
        }
        finished = true;
        try {
            socket.destroy();
        } catch (E) {
        // ignore
        }
        callback(err);
    };
    let timeoutErr = ()=>{
        let err = new Error("Proxy socket timed out");
        err.code = "ETIMEDOUT";
        tempSocketErr(err);
    };
    socket = connect(options, ()=>{
        if (finished) {
            return;
        }
        let reqHeaders = {
            Host: destinationHost + ":" + destinationPort,
            Connection: "close"
        };
        if (proxy.auth) {
            reqHeaders["Proxy-Authorization"] = "Basic " + Buffer.from(proxy.auth).toString("base64");
        }
        socket.write(// HTTP method
        "CONNECT " + destinationHost + ":" + destinationPort + " HTTP/1.1\r\n" + // HTTP request headers
        Object.keys(reqHeaders).map((key)=>key + ": " + reqHeaders[key]).join("\r\n") + // End request
        "\r\n\r\n");
        let headers = "";
        let onSocketData = (chunk)=>{
            let match;
            let remainder;
            if (finished) {
                return;
            }
            headers += chunk.toString("binary");
            if (match = headers.match(/\r\n\r\n/)) {
                socket.removeListener("data", onSocketData);
                remainder = headers.substr(match.index + match[0].length);
                headers = headers.substr(0, match.index);
                if (remainder) {
                    socket.unshift(Buffer.from(remainder, "binary"));
                }
                // proxy connection is now established
                finished = true;
                // check response code
                match = headers.match(/^HTTP\/\d+\.\d+ (\d+)/i);
                if (!match || (match[1] || "").charAt(0) !== "2") {
                    try {
                        socket.destroy();
                    } catch (E) {
                    // ignore
                    }
                    return callback(new Error("Invalid response from proxy" + (match && ": " + match[1] || "")));
                }
                socket.removeListener("error", tempSocketErr);
                socket.removeListener("timeout", timeoutErr);
                socket.setTimeout(0);
                return callback(null, socket);
            }
        };
        socket.on("data", onSocketData);
    });
    socket.setTimeout(httpProxyClient.timeout || 30 * 1000);
    socket.on("timeout", timeoutErr);
    socket.once("error", tempSocketErr);
}
module.exports = httpProxyClient;


/***/ }),

/***/ 18425:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const packageInfo = __webpack_require__(98350);
const EventEmitter = (__webpack_require__(82361).EventEmitter);
const net = __webpack_require__(41808);
const tls = __webpack_require__(24404);
const os = __webpack_require__(22037);
const crypto = __webpack_require__(6113);
const DataStream = __webpack_require__(99682);
const PassThrough = (__webpack_require__(12781).PassThrough);
const shared = __webpack_require__(74741);
// default timeout values in ms
const CONNECTION_TIMEOUT = 2 * 60 * 1000; // how much to wait for the connection to be established
const SOCKET_TIMEOUT = 10 * 60 * 1000; // how much to wait for socket inactivity before disconnecting the client
const GREETING_TIMEOUT = 30 * 1000; // how much to wait after connection is established but SMTP greeting is not receieved
const DNS_TIMEOUT = 30 * 1000; // how much to wait for resolveHostname 
/**
 * Generates a SMTP connection object
 *
 * Optional options object takes the following possible properties:
 *
 *  * **port** - is the port to connect to (defaults to 587 or 465)
 *  * **host** - is the hostname or IP address to connect to (defaults to 'localhost')
 *  * **secure** - use SSL
 *  * **ignoreTLS** - ignore server support for STARTTLS
 *  * **requireTLS** - forces the client to use STARTTLS
 *  * **name** - the name of the client server
 *  * **localAddress** - outbound address to bind to (see: http://nodejs.org/api/net.html#net_net_connect_options_connectionlistener)
 *  * **greetingTimeout** - Time to wait in ms until greeting message is received from the server (defaults to 10000)
 *  * **connectionTimeout** - how many milliseconds to wait for the connection to establish
 *  * **socketTimeout** - Time of inactivity until the connection is closed (defaults to 1 hour)
 *  * **dnsTimeout** - Time to wait in ms for the DNS requests to be resolved (defaults to 30 seconds)
 *  * **lmtp** - if true, uses LMTP instead of SMTP protocol
 *  * **logger** - bunyan compatible logger interface
 *  * **debug** - if true pass SMTP traffic to the logger
 *  * **tls** - options for createCredentials
 *  * **socket** - existing socket to use instead of creating a new one (see: http://nodejs.org/api/net.html#net_class_net_socket)
 *  * **secured** - boolean indicates that the provided socket has already been upgraded to tls
 *
 * @constructor
 * @namespace SMTP Client module
 * @param {Object} [options] Option properties
 */ class SMTPConnection extends EventEmitter {
    constructor(options){
        super(options);
        this.id = crypto.randomBytes(8).toString("base64").replace(/\W/g, "");
        this.stage = "init";
        this.options = options || {};
        this.secureConnection = !!this.options.secure;
        this.alreadySecured = !!this.options.secured;
        this.port = Number(this.options.port) || (this.secureConnection ? 465 : 587);
        this.host = this.options.host || "localhost";
        this.allowInternalNetworkInterfaces = this.options.allowInternalNetworkInterfaces || false;
        if (typeof this.options.secure === "undefined" && this.port === 465) {
            // if secure option is not set but port is 465, then default to secure
            this.secureConnection = true;
        }
        this.name = this.options.name || this._getHostname();
        this.logger = shared.getLogger(this.options, {
            component: this.options.component || "smtp-connection",
            sid: this.id
        });
        this.customAuth = new Map();
        Object.keys(this.options.customAuth || {}).forEach((key)=>{
            let mapKey = (key || "").toString().trim().toUpperCase();
            if (!mapKey) {
                return;
            }
            this.customAuth.set(mapKey, this.options.customAuth[key]);
        });
        /**
         * Expose version nr, just for the reference
         * @type {String}
         */ this.version = packageInfo.version;
        /**
         * If true, then the user is authenticated
         * @type {Boolean}
         */ this.authenticated = false;
        /**
         * If set to true, this instance is no longer active
         * @private
         */ this.destroyed = false;
        /**
         * Defines if the current connection is secure or not. If not,
         * STARTTLS can be used if available
         * @private
         */ this.secure = !!this.secureConnection;
        /**
         * Store incomplete messages coming from the server
         * @private
         */ this._remainder = "";
        /**
         * Unprocessed responses from the server
         * @type {Array}
         */ this._responseQueue = [];
        this.lastServerResponse = false;
        /**
         * The socket connecting to the server
         * @publick
         */ this._socket = false;
        /**
         * Lists supported auth mechanisms
         * @private
         */ this._supportedAuth = [];
        /**
         * Set to true, if EHLO response includes "AUTH".
         * If false then authentication is not tried
         */ this.allowsAuth = false;
        /**
         * Includes current envelope (from, to)
         * @private
         */ this._envelope = false;
        /**
         * Lists supported extensions
         * @private
         */ this._supportedExtensions = [];
        /**
         * Defines the maximum allowed size for a single message
         * @private
         */ this._maxAllowedSize = 0;
        /**
         * Function queue to run if a data chunk comes from the server
         * @private
         */ this._responseActions = [];
        this._recipientQueue = [];
        /**
         * Timeout variable for waiting the greeting
         * @private
         */ this._greetingTimeout = false;
        /**
         * Timeout variable for waiting the connection to start
         * @private
         */ this._connectionTimeout = false;
        /**
         * If the socket is deemed already closed
         * @private
         */ this._destroyed = false;
        /**
         * If the socket is already being closed
         * @private
         */ this._closing = false;
        /**
         * Callbacks for socket's listeners
         */ this._onSocketData = (chunk)=>this._onData(chunk);
        this._onSocketError = (error)=>this._onError(error, "ESOCKET", false, "CONN");
        this._onSocketClose = ()=>this._onClose();
        this._onSocketEnd = ()=>this._onEnd();
        this._onSocketTimeout = ()=>this._onTimeout();
    }
    /**
     * Creates a connection to a SMTP server and sets up connection
     * listener
     */ connect(connectCallback) {
        if (typeof connectCallback === "function") {
            this.once("connect", ()=>{
                this.logger.debug({
                    tnx: "smtp"
                }, "SMTP handshake finished");
                connectCallback();
            });
            const isDestroyedMessage = this._isDestroyedMessage("connect");
            if (isDestroyedMessage) {
                return connectCallback(this._formatError(isDestroyedMessage, "ECONNECTION", false, "CONN"));
            }
        }
        let opts = {
            port: this.port,
            host: this.host,
            allowInternalNetworkInterfaces: this.allowInternalNetworkInterfaces,
            timeout: this.options.dnsTimeout || DNS_TIMEOUT
        };
        if (this.options.localAddress) {
            opts.localAddress = this.options.localAddress;
        }
        let setupConnectionHandlers = ()=>{
            this._connectionTimeout = setTimeout(()=>{
                this._onError("Connection timeout", "ETIMEDOUT", false, "CONN");
            }, this.options.connectionTimeout || CONNECTION_TIMEOUT);
            this._socket.on("error", this._onSocketError);
        };
        if (this.options.connection) {
            // connection is already opened
            this._socket = this.options.connection;
            if (this.secureConnection && !this.alreadySecured) {
                setImmediate(()=>this._upgradeConnection((err)=>{
                        if (err) {
                            this._onError(new Error("Error initiating TLS - " + (err.message || err)), "ETLS", false, "CONN");
                            return;
                        }
                        this._onConnect();
                    }));
            } else {
                setImmediate(()=>this._onConnect());
            }
            return;
        } else if (this.options.socket) {
            // socket object is set up but not yet connected
            this._socket = this.options.socket;
            return shared.resolveHostname(opts, (err, resolved)=>{
                if (err) {
                    return setImmediate(()=>this._onError(err, "EDNS", false, "CONN"));
                }
                this.logger.debug({
                    tnx: "dns",
                    source: opts.host,
                    resolved: resolved.host,
                    cached: !!resolved.cached
                }, "Resolved %s as %s [cache %s]", opts.host, resolved.host, resolved.cached ? "hit" : "miss");
                Object.keys(resolved).forEach((key)=>{
                    if (key.charAt(0) !== "_" && resolved[key]) {
                        opts[key] = resolved[key];
                    }
                });
                try {
                    this._socket.connect(this.port, this.host, ()=>{
                        this._socket.setKeepAlive(true);
                        this._onConnect();
                    });
                    setupConnectionHandlers();
                } catch (E) {
                    return setImmediate(()=>this._onError(E, "ECONNECTION", false, "CONN"));
                }
            });
        } else if (this.secureConnection) {
            // connect using tls
            if (this.options.tls) {
                Object.keys(this.options.tls).forEach((key)=>{
                    opts[key] = this.options.tls[key];
                });
            }
            return shared.resolveHostname(opts, (err, resolved)=>{
                if (err) {
                    return setImmediate(()=>this._onError(err, "EDNS", false, "CONN"));
                }
                this.logger.debug({
                    tnx: "dns",
                    source: opts.host,
                    resolved: resolved.host,
                    cached: !!resolved.cached
                }, "Resolved %s as %s [cache %s]", opts.host, resolved.host, resolved.cached ? "hit" : "miss");
                Object.keys(resolved).forEach((key)=>{
                    if (key.charAt(0) !== "_" && resolved[key]) {
                        opts[key] = resolved[key];
                    }
                });
                try {
                    this._socket = tls.connect(opts, ()=>{
                        this._socket.setKeepAlive(true);
                        this._onConnect();
                    });
                    setupConnectionHandlers();
                } catch (E) {
                    return setImmediate(()=>this._onError(E, "ECONNECTION", false, "CONN"));
                }
            });
        } else {
            // connect using plaintext
            return shared.resolveHostname(opts, (err, resolved)=>{
                if (err) {
                    return setImmediate(()=>this._onError(err, "EDNS", false, "CONN"));
                }
                this.logger.debug({
                    tnx: "dns",
                    source: opts.host,
                    resolved: resolved.host,
                    cached: !!resolved.cached
                }, "Resolved %s as %s [cache %s]", opts.host, resolved.host, resolved.cached ? "hit" : "miss");
                Object.keys(resolved).forEach((key)=>{
                    if (key.charAt(0) !== "_" && resolved[key]) {
                        opts[key] = resolved[key];
                    }
                });
                try {
                    this._socket = net.connect(opts, ()=>{
                        this._socket.setKeepAlive(true);
                        this._onConnect();
                    });
                    setupConnectionHandlers();
                } catch (E) {
                    return setImmediate(()=>this._onError(E, "ECONNECTION", false, "CONN"));
                }
            });
        }
    }
    /**
     * Sends QUIT
     */ quit() {
        this._sendCommand("QUIT");
        this._responseActions.push(this.close);
    }
    /**
     * Closes the connection to the server
     */ close() {
        clearTimeout(this._connectionTimeout);
        clearTimeout(this._greetingTimeout);
        this._responseActions = [];
        // allow to run this function only once
        if (this._closing) {
            return;
        }
        this._closing = true;
        let closeMethod = "end";
        if (this.stage === "init") {
            // Close the socket immediately when connection timed out
            closeMethod = "destroy";
        }
        this.logger.debug({
            tnx: "smtp"
        }, 'Closing connection to the server using "%s"', closeMethod);
        let socket = this._socket && this._socket.socket || this._socket;
        if (socket && !socket.destroyed) {
            try {
                this._socket[closeMethod]();
            } catch (E) {
            // just ignore
            }
        }
        this._destroy();
    }
    /**
     * Authenticate user
     */ login(authData, callback) {
        const isDestroyedMessage = this._isDestroyedMessage("login");
        if (isDestroyedMessage) {
            return callback(this._formatError(isDestroyedMessage, "ECONNECTION", false, "API"));
        }
        this._auth = authData || {};
        // Select SASL authentication method
        this._authMethod = (this._auth.method || "").toString().trim().toUpperCase() || false;
        if (!this._authMethod && this._auth.oauth2 && !this._auth.credentials) {
            this._authMethod = "XOAUTH2";
        } else if (!this._authMethod || this._authMethod === "XOAUTH2" && !this._auth.oauth2) {
            // use first supported
            this._authMethod = (this._supportedAuth[0] || "PLAIN").toUpperCase().trim();
        }
        if (this._authMethod !== "XOAUTH2" && (!this._auth.credentials || !this._auth.credentials.user || !this._auth.credentials.pass)) {
            if (this._auth.user && this._auth.pass) {
                this._auth.credentials = {
                    user: this._auth.user,
                    pass: this._auth.pass,
                    options: this._auth.options
                };
            } else {
                return callback(this._formatError('Missing credentials for "' + this._authMethod + '"', "EAUTH", false, "API"));
            }
        }
        if (this.customAuth.has(this._authMethod)) {
            let handler = this.customAuth.get(this._authMethod);
            let lastResponse;
            let returned = false;
            let resolve = ()=>{
                if (returned) {
                    return;
                }
                returned = true;
                this.logger.info({
                    tnx: "smtp",
                    username: this._auth.user,
                    action: "authenticated",
                    method: this._authMethod
                }, "User %s authenticated", JSON.stringify(this._auth.user));
                this.authenticated = true;
                callback(null, true);
            };
            let reject = (err)=>{
                if (returned) {
                    return;
                }
                returned = true;
                callback(this._formatError(err, "EAUTH", lastResponse, "AUTH " + this._authMethod));
            };
            let handlerResponse = handler({
                auth: this._auth,
                method: this._authMethod,
                extensions: [].concat(this._supportedExtensions),
                authMethods: [].concat(this._supportedAuth),
                maxAllowedSize: this._maxAllowedSize || false,
                sendCommand: (cmd, done)=>{
                    let promise;
                    if (!done) {
                        promise = new Promise((resolve, reject)=>{
                            done = shared.callbackPromise(resolve, reject);
                        });
                    }
                    this._responseActions.push((str)=>{
                        lastResponse = str;
                        let codes = str.match(/^(\d+)(?:\s(\d+\.\d+\.\d+))?\s/);
                        let data = {
                            command: cmd,
                            response: str
                        };
                        if (codes) {
                            data.status = Number(codes[1]) || 0;
                            if (codes[2]) {
                                data.code = codes[2];
                            }
                            data.text = str.substr(codes[0].length);
                        } else {
                            data.text = str;
                            data.status = 0; // just in case we need to perform numeric comparisons
                        }
                        done(null, data);
                    });
                    setImmediate(()=>this._sendCommand(cmd));
                    return promise;
                },
                resolve,
                reject
            });
            if (handlerResponse && typeof handlerResponse.catch === "function") {
                // a promise was returned
                handlerResponse.then(resolve).catch(reject);
            }
            return;
        }
        switch(this._authMethod){
            case "XOAUTH2":
                this._handleXOauth2Token(false, callback);
                return;
            case "LOGIN":
                this._responseActions.push((str)=>{
                    this._actionAUTH_LOGIN_USER(str, callback);
                });
                this._sendCommand("AUTH LOGIN");
                return;
            case "PLAIN":
                this._responseActions.push((str)=>{
                    this._actionAUTHComplete(str, callback);
                });
                this._sendCommand("AUTH PLAIN " + Buffer.from(//this._auth.user+'\u0000'+
                "\0" + // skip authorization identity as it causes problems with some servers
                this._auth.credentials.user + "\0" + this._auth.credentials.pass, "utf-8").toString("base64"), // log entry without passwords
                "AUTH PLAIN " + Buffer.from(//this._auth.user+'\u0000'+
                "\0" + // skip authorization identity as it causes problems with some servers
                this._auth.credentials.user + "\0" + "/* secret */", "utf-8").toString("base64"));
                return;
            case "CRAM-MD5":
                this._responseActions.push((str)=>{
                    this._actionAUTH_CRAM_MD5(str, callback);
                });
                this._sendCommand("AUTH CRAM-MD5");
                return;
        }
        return callback(this._formatError('Unknown authentication method "' + this._authMethod + '"', "EAUTH", false, "API"));
    }
    /**
     * Sends a message
     *
     * @param {Object} envelope Envelope object, {from: addr, to: [addr]}
     * @param {Object} message String, Buffer or a Stream
     * @param {Function} callback Callback to return once sending is completed
     */ send(envelope, message, done) {
        if (!message) {
            return done(this._formatError("Empty message", "EMESSAGE", false, "API"));
        }
        const isDestroyedMessage = this._isDestroyedMessage("send message");
        if (isDestroyedMessage) {
            return done(this._formatError(isDestroyedMessage, "ECONNECTION", false, "API"));
        }
        // reject larger messages than allowed
        if (this._maxAllowedSize && envelope.size > this._maxAllowedSize) {
            return setImmediate(()=>{
                done(this._formatError("Message size larger than allowed " + this._maxAllowedSize, "EMESSAGE", false, "MAIL FROM"));
            });
        }
        // ensure that callback is only called once
        let returned = false;
        let callback = function() {
            if (returned) {
                return;
            }
            returned = true;
            done(...arguments);
        };
        if (typeof message.on === "function") {
            message.on("error", (err)=>callback(this._formatError(err, "ESTREAM", false, "API")));
        }
        let startTime = Date.now();
        this._setEnvelope(envelope, (err, info)=>{
            if (err) {
                return callback(err);
            }
            let envelopeTime = Date.now();
            let stream = this._createSendStream((err, str)=>{
                if (err) {
                    return callback(err);
                }
                info.envelopeTime = envelopeTime - startTime;
                info.messageTime = Date.now() - envelopeTime;
                info.messageSize = stream.outByteCount;
                info.response = str;
                return callback(null, info);
            });
            if (typeof message.pipe === "function") {
                message.pipe(stream);
            } else {
                stream.write(message);
                stream.end();
            }
        });
    }
    /**
     * Resets connection state
     *
     * @param {Function} callback Callback to return once connection is reset
     */ reset(callback) {
        this._sendCommand("RSET");
        this._responseActions.push((str)=>{
            if (str.charAt(0) !== "2") {
                return callback(this._formatError("Could not reset session state. response=" + str, "EPROTOCOL", str, "RSET"));
            }
            this._envelope = false;
            return callback(null, true);
        });
    }
    /**
     * Connection listener that is run when the connection to
     * the server is opened
     *
     * @event
     */ _onConnect() {
        clearTimeout(this._connectionTimeout);
        this.logger.info({
            tnx: "network",
            localAddress: this._socket.localAddress,
            localPort: this._socket.localPort,
            remoteAddress: this._socket.remoteAddress,
            remotePort: this._socket.remotePort
        }, "%s established to %s:%s", this.secure ? "Secure connection" : "Connection", this._socket.remoteAddress, this._socket.remotePort);
        if (this._destroyed) {
            // Connection was established after we already had canceled it
            this.close();
            return;
        }
        this.stage = "connected";
        // clear existing listeners for the socket
        this._socket.removeListener("data", this._onSocketData);
        this._socket.removeListener("timeout", this._onSocketTimeout);
        this._socket.removeListener("close", this._onSocketClose);
        this._socket.removeListener("end", this._onSocketEnd);
        this._socket.on("data", this._onSocketData);
        this._socket.once("close", this._onSocketClose);
        this._socket.once("end", this._onSocketEnd);
        this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT);
        this._socket.on("timeout", this._onSocketTimeout);
        this._greetingTimeout = setTimeout(()=>{
            // if still waiting for greeting, give up
            if (this._socket && !this._destroyed && this._responseActions[0] === this._actionGreeting) {
                this._onError("Greeting never received", "ETIMEDOUT", false, "CONN");
            }
        }, this.options.greetingTimeout || GREETING_TIMEOUT);
        this._responseActions.push(this._actionGreeting);
        // we have a 'data' listener set up so resume socket if it was paused
        this._socket.resume();
    }
    /**
     * 'data' listener for data coming from the server
     *
     * @event
     * @param {Buffer} chunk Data chunk coming from the server
     */ _onData(chunk) {
        if (this._destroyed || !chunk || !chunk.length) {
            return;
        }
        let data = (chunk || "").toString("binary");
        let lines = (this._remainder + data).split(/\r?\n/);
        let lastline;
        this._remainder = lines.pop();
        for(let i = 0, len = lines.length; i < len; i++){
            if (this._responseQueue.length) {
                lastline = this._responseQueue[this._responseQueue.length - 1];
                if (/^\d+-/.test(lastline.split("\n").pop())) {
                    this._responseQueue[this._responseQueue.length - 1] += "\n" + lines[i];
                    continue;
                }
            }
            this._responseQueue.push(lines[i]);
        }
        if (this._responseQueue.length) {
            lastline = this._responseQueue[this._responseQueue.length - 1];
            if (/^\d+-/.test(lastline.split("\n").pop())) {
                return;
            }
        }
        this._processResponse();
    }
    /**
     * 'error' listener for the socket
     *
     * @event
     * @param {Error} err Error object
     * @param {String} type Error name
     */ _onError(err, type, data, command) {
        clearTimeout(this._connectionTimeout);
        clearTimeout(this._greetingTimeout);
        if (this._destroyed) {
            // just ignore, already closed
            // this might happen when a socket is canceled because of reached timeout
            // but the socket timeout error itself receives only after
            return;
        }
        err = this._formatError(err, type, data, command);
        this.logger.error(data, err.message);
        this.emit("error", err);
        this.close();
    }
    _formatError(message, type, response, command) {
        let err;
        if (/Error\]$/i.test(Object.prototype.toString.call(message))) {
            err = message;
        } else {
            err = new Error(message);
        }
        if (type && type !== "Error") {
            err.code = type;
        }
        if (response) {
            err.response = response;
            err.message += ": " + response;
        }
        let responseCode = typeof response === "string" && Number((response.match(/^\d+/) || [])[0]) || false;
        if (responseCode) {
            err.responseCode = responseCode;
        }
        if (command) {
            err.command = command;
        }
        return err;
    }
    /**
     * 'close' listener for the socket
     *
     * @event
     */ _onClose() {
        this.logger.info({
            tnx: "network"
        }, "Connection closed");
        if (this.upgrading && !this._destroyed) {
            return this._onError(new Error("Connection closed unexpectedly"), "ETLS", false, "CONN");
        } else if (![
            this._actionGreeting,
            this.close
        ].includes(this._responseActions[0]) && !this._destroyed) {
            return this._onError(new Error("Connection closed unexpectedly"), "ECONNECTION", false, "CONN");
        }
        this._destroy();
    }
    /**
     * 'end' listener for the socket
     *
     * @event
     */ _onEnd() {
        if (this._socket && !this._socket.destroyed) {
            this._socket.destroy();
        }
    }
    /**
     * 'timeout' listener for the socket
     *
     * @event
     */ _onTimeout() {
        return this._onError(new Error("Timeout"), "ETIMEDOUT", false, "CONN");
    }
    /**
     * Destroys the client, emits 'end'
     */ _destroy() {
        if (this._destroyed) {
            return;
        }
        this._destroyed = true;
        this.emit("end");
    }
    /**
     * Upgrades the connection to TLS
     *
     * @param {Function} callback Callback function to run when the connection
     *        has been secured
     */ _upgradeConnection(callback) {
        // do not remove all listeners or it breaks node v0.10 as there's
        // apparently a 'finish' event set that would be cleared as well
        // we can safely keep 'error', 'end', 'close' etc. events
        this._socket.removeListener("data", this._onSocketData); // incoming data is going to be gibberish from this point onwards
        this._socket.removeListener("timeout", this._onSocketTimeout); // timeout will be re-set for the new socket object
        let socketPlain = this._socket;
        let opts = {
            socket: this._socket,
            host: this.host
        };
        Object.keys(this.options.tls || {}).forEach((key)=>{
            opts[key] = this.options.tls[key];
        });
        this.upgrading = true;
        // tls.connect is not an asynchronous function however it may still throw errors and requires to be wrapped with try/catch
        try {
            this._socket = tls.connect(opts, ()=>{
                this.secure = true;
                this.upgrading = false;
                this._socket.on("data", this._onSocketData);
                socketPlain.removeListener("close", this._onSocketClose);
                socketPlain.removeListener("end", this._onSocketEnd);
                return callback(null, true);
            });
        } catch (err) {
            return callback(err);
        }
        this._socket.on("error", this._onSocketError);
        this._socket.once("close", this._onSocketClose);
        this._socket.once("end", this._onSocketEnd);
        this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT); // 10 min.
        this._socket.on("timeout", this._onSocketTimeout);
        // resume in case the socket was paused
        socketPlain.resume();
    }
    /**
     * Processes queued responses from the server
     *
     * @param {Boolean} force If true, ignores _processing flag
     */ _processResponse() {
        if (!this._responseQueue.length) {
            return false;
        }
        let str = this.lastServerResponse = (this._responseQueue.shift() || "").toString();
        if (/^\d+-/.test(str.split("\n").pop())) {
            // keep waiting for the final part of multiline response
            return;
        }
        if (this.options.debug || this.options.transactionLog) {
            this.logger.debug({
                tnx: "server"
            }, str.replace(/\r?\n$/, ""));
        }
        if (!str.trim()) {
            // skip unexpected empty lines
            setImmediate(()=>this._processResponse(true));
        }
        let action = this._responseActions.shift();
        if (typeof action === "function") {
            action.call(this, str);
            setImmediate(()=>this._processResponse(true));
        } else {
            return this._onError(new Error("Unexpected Response"), "EPROTOCOL", str, "CONN");
        }
    }
    /**
     * Send a command to the server, append \r\n
     *
     * @param {String} str String to be sent to the server
     * @param {String} logStr Optional string to be used for logging instead of the actual string
     */ _sendCommand(str, logStr) {
        if (this._destroyed) {
            // Connection already closed, can't send any more data
            return;
        }
        if (this._socket.destroyed) {
            return this.close();
        }
        if (this.options.debug || this.options.transactionLog) {
            this.logger.debug({
                tnx: "client"
            }, (logStr || str || "").toString().replace(/\r?\n$/, ""));
        }
        this._socket.write(Buffer.from(str + "\r\n", "utf-8"));
    }
    /**
     * Initiates a new message by submitting envelope data, starting with
     * MAIL FROM: command
     *
     * @param {Object} envelope Envelope object in the form of
     *        {from:'...', to:['...']}
     *        or
     *        {from:{address:'...',name:'...'}, to:[address:'...',name:'...']}
     */ _setEnvelope(envelope, callback) {
        let args = [];
        let useSmtpUtf8 = false;
        this._envelope = envelope || {};
        this._envelope.from = (this._envelope.from && this._envelope.from.address || this._envelope.from || "").toString().trim();
        this._envelope.to = [].concat(this._envelope.to || []).map((to)=>(to && to.address || to || "").toString().trim());
        if (!this._envelope.to.length) {
            return callback(this._formatError("No recipients defined", "EENVELOPE", false, "API"));
        }
        if (this._envelope.from && /[\r\n<>]/.test(this._envelope.from)) {
            return callback(this._formatError("Invalid sender " + JSON.stringify(this._envelope.from), "EENVELOPE", false, "API"));
        }
        // check if the sender address uses only ASCII characters,
        // otherwise require usage of SMTPUTF8 extension
        if (/[\x80-\uFFFF]/.test(this._envelope.from)) {
            useSmtpUtf8 = true;
        }
        for(let i = 0, len = this._envelope.to.length; i < len; i++){
            if (!this._envelope.to[i] || /[\r\n<>]/.test(this._envelope.to[i])) {
                return callback(this._formatError("Invalid recipient " + JSON.stringify(this._envelope.to[i]), "EENVELOPE", false, "API"));
            }
            // check if the recipients addresses use only ASCII characters,
            // otherwise require usage of SMTPUTF8 extension
            if (/[\x80-\uFFFF]/.test(this._envelope.to[i])) {
                useSmtpUtf8 = true;
            }
        }
        // clone the recipients array for latter manipulation
        this._envelope.rcptQueue = JSON.parse(JSON.stringify(this._envelope.to || []));
        this._envelope.rejected = [];
        this._envelope.rejectedErrors = [];
        this._envelope.accepted = [];
        if (this._envelope.dsn) {
            try {
                this._envelope.dsn = this._setDsnEnvelope(this._envelope.dsn);
            } catch (err) {
                return callback(this._formatError("Invalid DSN " + err.message, "EENVELOPE", false, "API"));
            }
        }
        this._responseActions.push((str)=>{
            this._actionMAIL(str, callback);
        });
        // If the server supports SMTPUTF8 and the envelope includes an internationalized
        // email address then append SMTPUTF8 keyword to the MAIL FROM command
        if (useSmtpUtf8 && this._supportedExtensions.includes("SMTPUTF8")) {
            args.push("SMTPUTF8");
            this._usingSmtpUtf8 = true;
        }
        // If the server supports 8BITMIME and the message might contain non-ascii bytes
        // then append the 8BITMIME keyword to the MAIL FROM command
        if (this._envelope.use8BitMime && this._supportedExtensions.includes("8BITMIME")) {
            args.push("BODY=8BITMIME");
            this._using8BitMime = true;
        }
        if (this._envelope.size && this._supportedExtensions.includes("SIZE")) {
            args.push("SIZE=" + this._envelope.size);
        }
        // If the server supports DSN and the envelope includes an DSN prop
        // then append DSN params to the MAIL FROM command
        if (this._envelope.dsn && this._supportedExtensions.includes("DSN")) {
            if (this._envelope.dsn.ret) {
                args.push("RET=" + shared.encodeXText(this._envelope.dsn.ret));
            }
            if (this._envelope.dsn.envid) {
                args.push("ENVID=" + shared.encodeXText(this._envelope.dsn.envid));
            }
        }
        this._sendCommand("MAIL FROM:<" + this._envelope.from + ">" + (args.length ? " " + args.join(" ") : ""));
    }
    _setDsnEnvelope(params) {
        let ret = (params.ret || params.return || "").toString().toUpperCase() || null;
        if (ret) {
            switch(ret){
                case "HDRS":
                case "HEADERS":
                    ret = "HDRS";
                    break;
                case "FULL":
                case "BODY":
                    ret = "FULL";
                    break;
            }
        }
        if (ret && ![
            "FULL",
            "HDRS"
        ].includes(ret)) {
            throw new Error("ret: " + JSON.stringify(ret));
        }
        let envid = (params.envid || params.id || "").toString() || null;
        let notify = params.notify || null;
        if (notify) {
            if (typeof notify === "string") {
                notify = notify.split(",");
            }
            notify = notify.map((n)=>n.trim().toUpperCase());
            let validNotify = [
                "NEVER",
                "SUCCESS",
                "FAILURE",
                "DELAY"
            ];
            let invaliNotify = notify.filter((n)=>!validNotify.includes(n));
            if (invaliNotify.length || notify.length > 1 && notify.includes("NEVER")) {
                throw new Error("notify: " + JSON.stringify(notify.join(",")));
            }
            notify = notify.join(",");
        }
        let orcpt = (params.recipient || params.orcpt || "").toString() || null;
        if (orcpt && orcpt.indexOf(";") < 0) {
            orcpt = "rfc822;" + orcpt;
        }
        return {
            ret,
            envid,
            notify,
            orcpt
        };
    }
    _getDsnRcptToArgs() {
        let args = [];
        // If the server supports DSN and the envelope includes an DSN prop
        // then append DSN params to the RCPT TO command
        if (this._envelope.dsn && this._supportedExtensions.includes("DSN")) {
            if (this._envelope.dsn.notify) {
                args.push("NOTIFY=" + shared.encodeXText(this._envelope.dsn.notify));
            }
            if (this._envelope.dsn.orcpt) {
                args.push("ORCPT=" + shared.encodeXText(this._envelope.dsn.orcpt));
            }
        }
        return args.length ? " " + args.join(" ") : "";
    }
    _createSendStream(callback) {
        let dataStream = new DataStream();
        let logStream;
        if (this.options.lmtp) {
            this._envelope.accepted.forEach((recipient, i)=>{
                let final = i === this._envelope.accepted.length - 1;
                this._responseActions.push((str)=>{
                    this._actionLMTPStream(recipient, final, str, callback);
                });
            });
        } else {
            this._responseActions.push((str)=>{
                this._actionSMTPStream(str, callback);
            });
        }
        dataStream.pipe(this._socket, {
            end: false
        });
        if (this.options.debug) {
            logStream = new PassThrough();
            logStream.on("readable", ()=>{
                let chunk;
                while(chunk = logStream.read()){
                    this.logger.debug({
                        tnx: "message"
                    }, chunk.toString("binary").replace(/\r?\n$/, ""));
                }
            });
            dataStream.pipe(logStream);
        }
        dataStream.once("end", ()=>{
            this.logger.info({
                tnx: "message",
                inByteCount: dataStream.inByteCount,
                outByteCount: dataStream.outByteCount
            }, "<%s bytes encoded mime message (source size %s bytes)>", dataStream.outByteCount, dataStream.inByteCount);
        });
        return dataStream;
    }
    /** ACTIONS **/ /**
     * Will be run after the connection is created and the server sends
     * a greeting. If the incoming message starts with 220 initiate
     * SMTP session by sending EHLO command
     *
     * @param {String} str Message from the server
     */ _actionGreeting(str) {
        clearTimeout(this._greetingTimeout);
        if (str.substr(0, 3) !== "220") {
            this._onError(new Error("Invalid greeting. response=" + str), "EPROTOCOL", str, "CONN");
            return;
        }
        if (this.options.lmtp) {
            this._responseActions.push(this._actionLHLO);
            this._sendCommand("LHLO " + this.name);
        } else {
            this._responseActions.push(this._actionEHLO);
            this._sendCommand("EHLO " + this.name);
        }
    }
    /**
     * Handles server response for LHLO command. If it yielded in
     * error, emit 'error', otherwise treat this as an EHLO response
     *
     * @param {String} str Message from the server
     */ _actionLHLO(str) {
        if (str.charAt(0) !== "2") {
            this._onError(new Error("Invalid LHLO. response=" + str), "EPROTOCOL", str, "LHLO");
            return;
        }
        this._actionEHLO(str);
    }
    /**
     * Handles server response for EHLO command. If it yielded in
     * error, try HELO instead, otherwise initiate TLS negotiation
     * if STARTTLS is supported by the server or move into the
     * authentication phase.
     *
     * @param {String} str Message from the server
     */ _actionEHLO(str) {
        let match;
        if (str.substr(0, 3) === "421") {
            this._onError(new Error("Server terminates connection. response=" + str), "ECONNECTION", str, "EHLO");
            return;
        }
        if (str.charAt(0) !== "2") {
            if (this.options.requireTLS) {
                this._onError(new Error("EHLO failed but HELO does not support required STARTTLS. response=" + str), "ECONNECTION", str, "EHLO");
                return;
            }
            // Try HELO instead
            this._responseActions.push(this._actionHELO);
            this._sendCommand("HELO " + this.name);
            return;
        }
        // Detect if the server supports STARTTLS
        if (!this.secure && !this.options.ignoreTLS && (/[ -]STARTTLS\b/im.test(str) || this.options.requireTLS)) {
            this._sendCommand("STARTTLS");
            this._responseActions.push(this._actionSTARTTLS);
            return;
        }
        // Detect if the server supports SMTPUTF8
        if (/[ -]SMTPUTF8\b/im.test(str)) {
            this._supportedExtensions.push("SMTPUTF8");
        }
        // Detect if the server supports DSN
        if (/[ -]DSN\b/im.test(str)) {
            this._supportedExtensions.push("DSN");
        }
        // Detect if the server supports 8BITMIME
        if (/[ -]8BITMIME\b/im.test(str)) {
            this._supportedExtensions.push("8BITMIME");
        }
        // Detect if the server supports PIPELINING
        if (/[ -]PIPELINING\b/im.test(str)) {
            this._supportedExtensions.push("PIPELINING");
        }
        // Detect if the server supports AUTH
        if (/[ -]AUTH\b/i.test(str)) {
            this.allowsAuth = true;
        }
        // Detect if the server supports PLAIN auth
        if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)PLAIN/i.test(str)) {
            this._supportedAuth.push("PLAIN");
        }
        // Detect if the server supports LOGIN auth
        if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)LOGIN/i.test(str)) {
            this._supportedAuth.push("LOGIN");
        }
        // Detect if the server supports CRAM-MD5 auth
        if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)CRAM-MD5/i.test(str)) {
            this._supportedAuth.push("CRAM-MD5");
        }
        // Detect if the server supports XOAUTH2 auth
        if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)XOAUTH2/i.test(str)) {
            this._supportedAuth.push("XOAUTH2");
        }
        // Detect if the server supports SIZE extensions (and the max allowed size)
        if (match = str.match(/[ -]SIZE(?:[ \t]+(\d+))?/im)) {
            this._supportedExtensions.push("SIZE");
            this._maxAllowedSize = Number(match[1]) || 0;
        }
        this.emit("connect");
    }
    /**
     * Handles server response for HELO command. If it yielded in
     * error, emit 'error', otherwise move into the authentication phase.
     *
     * @param {String} str Message from the server
     */ _actionHELO(str) {
        if (str.charAt(0) !== "2") {
            this._onError(new Error("Invalid HELO. response=" + str), "EPROTOCOL", str, "HELO");
            return;
        }
        // assume that authentication is enabled (most probably is not though)
        this.allowsAuth = true;
        this.emit("connect");
    }
    /**
     * Handles server response for STARTTLS command. If there's an error
     * try HELO instead, otherwise initiate TLS upgrade. If the upgrade
     * succeedes restart the EHLO
     *
     * @param {String} str Message from the server
     */ _actionSTARTTLS(str) {
        if (str.charAt(0) !== "2") {
            if (this.options.opportunisticTLS) {
                this.logger.info({
                    tnx: "smtp"
                }, "Failed STARTTLS upgrade, continuing unencrypted");
                return this.emit("connect");
            }
            this._onError(new Error("Error upgrading connection with STARTTLS"), "ETLS", str, "STARTTLS");
            return;
        }
        this._upgradeConnection((err, secured)=>{
            if (err) {
                this._onError(new Error("Error initiating TLS - " + (err.message || err)), "ETLS", false, "STARTTLS");
                return;
            }
            this.logger.info({
                tnx: "smtp"
            }, "Connection upgraded with STARTTLS");
            if (secured) {
                // restart session
                if (this.options.lmtp) {
                    this._responseActions.push(this._actionLHLO);
                    this._sendCommand("LHLO " + this.name);
                } else {
                    this._responseActions.push(this._actionEHLO);
                    this._sendCommand("EHLO " + this.name);
                }
            } else {
                this.emit("connect");
            }
        });
    }
    /**
     * Handle the response for AUTH LOGIN command. We are expecting
     * '334 VXNlcm5hbWU6' (base64 for 'Username:'). Data to be sent as
     * response needs to be base64 encoded username. We do not need
     * exact match but settle with 334 response in general as some
     * hosts invalidly use a longer message than VXNlcm5hbWU6
     *
     * @param {String} str Message from the server
     */ _actionAUTH_LOGIN_USER(str, callback) {
        if (!/^334[ -]/.test(str)) {
            // expecting '334 VXNlcm5hbWU6'
            callback(this._formatError('Invalid login sequence while waiting for "334 VXNlcm5hbWU6"', "EAUTH", str, "AUTH LOGIN"));
            return;
        }
        this._responseActions.push((str)=>{
            this._actionAUTH_LOGIN_PASS(str, callback);
        });
        this._sendCommand(Buffer.from(this._auth.credentials.user + "", "utf-8").toString("base64"));
    }
    /**
     * Handle the response for AUTH CRAM-MD5 command. We are expecting
     * '334 <challenge string>'. Data to be sent as response needs to be
     * base64 decoded challenge string, MD5 hashed using the password as
     * a HMAC key, prefixed by the username and a space, and finally all
     * base64 encoded again.
     *
     * @param {String} str Message from the server
     */ _actionAUTH_CRAM_MD5(str, callback) {
        let challengeMatch = str.match(/^334\s+(.+)$/);
        let challengeString = "";
        if (!challengeMatch) {
            return callback(this._formatError("Invalid login sequence while waiting for server challenge string", "EAUTH", str, "AUTH CRAM-MD5"));
        } else {
            challengeString = challengeMatch[1];
        }
        // Decode from base64
        let base64decoded = Buffer.from(challengeString, "base64").toString("ascii"), hmacMD5 = crypto.createHmac("md5", this._auth.credentials.pass);
        hmacMD5.update(base64decoded);
        let prepended = this._auth.credentials.user + " " + hmacMD5.digest("hex");
        this._responseActions.push((str)=>{
            this._actionAUTH_CRAM_MD5_PASS(str, callback);
        });
        this._sendCommand(Buffer.from(prepended).toString("base64"), // hidden hash for logs
        Buffer.from(this._auth.credentials.user + " /* secret */").toString("base64"));
    }
    /**
     * Handles the response to CRAM-MD5 authentication, if there's no error,
     * the user can be considered logged in. Start waiting for a message to send
     *
     * @param {String} str Message from the server
     */ _actionAUTH_CRAM_MD5_PASS(str, callback) {
        if (!str.match(/^235\s+/)) {
            return callback(this._formatError('Invalid login sequence while waiting for "235"', "EAUTH", str, "AUTH CRAM-MD5"));
        }
        this.logger.info({
            tnx: "smtp",
            username: this._auth.user,
            action: "authenticated",
            method: this._authMethod
        }, "User %s authenticated", JSON.stringify(this._auth.user));
        this.authenticated = true;
        callback(null, true);
    }
    /**
     * Handle the response for AUTH LOGIN command. We are expecting
     * '334 UGFzc3dvcmQ6' (base64 for 'Password:'). Data to be sent as
     * response needs to be base64 encoded password.
     *
     * @param {String} str Message from the server
     */ _actionAUTH_LOGIN_PASS(str, callback) {
        if (!/^334[ -]/.test(str)) {
            // expecting '334 UGFzc3dvcmQ6'
            return callback(this._formatError('Invalid login sequence while waiting for "334 UGFzc3dvcmQ6"', "EAUTH", str, "AUTH LOGIN"));
        }
        this._responseActions.push((str)=>{
            this._actionAUTHComplete(str, callback);
        });
        this._sendCommand(Buffer.from((this._auth.credentials.pass || "").toString(), "utf-8").toString("base64"), // Hidden pass for logs
        Buffer.from("/* secret */", "utf-8").toString("base64"));
    }
    /**
     * Handles the response for authentication, if there's no error,
     * the user can be considered logged in. Start waiting for a message to send
     *
     * @param {String} str Message from the server
     */ _actionAUTHComplete(str, isRetry, callback) {
        if (!callback && typeof isRetry === "function") {
            callback = isRetry;
            isRetry = false;
        }
        if (str.substr(0, 3) === "334") {
            this._responseActions.push((str)=>{
                if (isRetry || this._authMethod !== "XOAUTH2") {
                    this._actionAUTHComplete(str, true, callback);
                } else {
                    // fetch a new OAuth2 access token
                    setImmediate(()=>this._handleXOauth2Token(true, callback));
                }
            });
            this._sendCommand("");
            return;
        }
        if (str.charAt(0) !== "2") {
            this.logger.info({
                tnx: "smtp",
                username: this._auth.user,
                action: "authfail",
                method: this._authMethod
            }, "User %s failed to authenticate", JSON.stringify(this._auth.user));
            return callback(this._formatError("Invalid login", "EAUTH", str, "AUTH " + this._authMethod));
        }
        this.logger.info({
            tnx: "smtp",
            username: this._auth.user,
            action: "authenticated",
            method: this._authMethod
        }, "User %s authenticated", JSON.stringify(this._auth.user));
        this.authenticated = true;
        callback(null, true);
    }
    /**
     * Handle response for a MAIL FROM: command
     *
     * @param {String} str Message from the server
     */ _actionMAIL(str, callback) {
        let message, curRecipient;
        if (Number(str.charAt(0)) !== 2) {
            if (this._usingSmtpUtf8 && /^550 /.test(str) && /[\x80-\uFFFF]/.test(this._envelope.from)) {
                message = "Internationalized mailbox name not allowed";
            } else {
                message = "Mail command failed";
            }
            return callback(this._formatError(message, "EENVELOPE", str, "MAIL FROM"));
        }
        if (!this._envelope.rcptQueue.length) {
            return callback(this._formatError("Can't send mail - no recipients defined", "EENVELOPE", false, "API"));
        } else {
            this._recipientQueue = [];
            if (this._supportedExtensions.includes("PIPELINING")) {
                while(this._envelope.rcptQueue.length){
                    curRecipient = this._envelope.rcptQueue.shift();
                    this._recipientQueue.push(curRecipient);
                    this._responseActions.push((str)=>{
                        this._actionRCPT(str, callback);
                    });
                    this._sendCommand("RCPT TO:<" + curRecipient + ">" + this._getDsnRcptToArgs());
                }
            } else {
                curRecipient = this._envelope.rcptQueue.shift();
                this._recipientQueue.push(curRecipient);
                this._responseActions.push((str)=>{
                    this._actionRCPT(str, callback);
                });
                this._sendCommand("RCPT TO:<" + curRecipient + ">" + this._getDsnRcptToArgs());
            }
        }
    }
    /**
     * Handle response for a RCPT TO: command
     *
     * @param {String} str Message from the server
     */ _actionRCPT(str, callback) {
        let message, err, curRecipient = this._recipientQueue.shift();
        if (Number(str.charAt(0)) !== 2) {
            // this is a soft error
            if (this._usingSmtpUtf8 && /^553 /.test(str) && /[\x80-\uFFFF]/.test(curRecipient)) {
                message = "Internationalized mailbox name not allowed";
            } else {
                message = "Recipient command failed";
            }
            this._envelope.rejected.push(curRecipient);
            // store error for the failed recipient
            err = this._formatError(message, "EENVELOPE", str, "RCPT TO");
            err.recipient = curRecipient;
            this._envelope.rejectedErrors.push(err);
        } else {
            this._envelope.accepted.push(curRecipient);
        }
        if (!this._envelope.rcptQueue.length && !this._recipientQueue.length) {
            if (this._envelope.rejected.length < this._envelope.to.length) {
                this._responseActions.push((str)=>{
                    this._actionDATA(str, callback);
                });
                this._sendCommand("DATA");
            } else {
                err = this._formatError("Can't send mail - all recipients were rejected", "EENVELOPE", str, "RCPT TO");
                err.rejected = this._envelope.rejected;
                err.rejectedErrors = this._envelope.rejectedErrors;
                return callback(err);
            }
        } else if (this._envelope.rcptQueue.length) {
            curRecipient = this._envelope.rcptQueue.shift();
            this._recipientQueue.push(curRecipient);
            this._responseActions.push((str)=>{
                this._actionRCPT(str, callback);
            });
            this._sendCommand("RCPT TO:<" + curRecipient + ">" + this._getDsnRcptToArgs());
        }
    }
    /**
     * Handle response for a DATA command
     *
     * @param {String} str Message from the server
     */ _actionDATA(str, callback) {
        // response should be 354 but according to this issue https://github.com/eleith/emailjs/issues/24
        // some servers might use 250 instead, so lets check for 2 or 3 as the first digit
        if (!/^[23]/.test(str)) {
            return callback(this._formatError("Data command failed", "EENVELOPE", str, "DATA"));
        }
        let response = {
            accepted: this._envelope.accepted,
            rejected: this._envelope.rejected
        };
        if (this._envelope.rejectedErrors.length) {
            response.rejectedErrors = this._envelope.rejectedErrors;
        }
        callback(null, response);
    }
    /**
     * Handle response for a DATA stream when using SMTP
     * We expect a single response that defines if the sending succeeded or failed
     *
     * @param {String} str Message from the server
     */ _actionSMTPStream(str, callback) {
        if (Number(str.charAt(0)) !== 2) {
            // Message failed
            return callback(this._formatError("Message failed", "EMESSAGE", str, "DATA"));
        } else {
            // Message sent succesfully
            return callback(null, str);
        }
    }
    /**
     * Handle response for a DATA stream
     * We expect a separate response for every recipient. All recipients can either
     * succeed or fail separately
     *
     * @param {String} recipient The recipient this response applies to
     * @param {Boolean} final Is this the final recipient?
     * @param {String} str Message from the server
     */ _actionLMTPStream(recipient, final, str, callback) {
        let err;
        if (Number(str.charAt(0)) !== 2) {
            // Message failed
            err = this._formatError("Message failed for recipient " + recipient, "EMESSAGE", str, "DATA");
            err.recipient = recipient;
            this._envelope.rejected.push(recipient);
            this._envelope.rejectedErrors.push(err);
            for(let i = 0, len = this._envelope.accepted.length; i < len; i++){
                if (this._envelope.accepted[i] === recipient) {
                    this._envelope.accepted.splice(i, 1);
                }
            }
        }
        if (final) {
            return callback(null, str);
        }
    }
    _handleXOauth2Token(isRetry, callback) {
        this._auth.oauth2.getToken(isRetry, (err, accessToken)=>{
            if (err) {
                this.logger.info({
                    tnx: "smtp",
                    username: this._auth.user,
                    action: "authfail",
                    method: this._authMethod
                }, "User %s failed to authenticate", JSON.stringify(this._auth.user));
                return callback(this._formatError(err, "EAUTH", false, "AUTH XOAUTH2"));
            }
            this._responseActions.push((str)=>{
                this._actionAUTHComplete(str, isRetry, callback);
            });
            this._sendCommand("AUTH XOAUTH2 " + this._auth.oauth2.buildXOAuth2Token(accessToken), //  Hidden for logs
            "AUTH XOAUTH2 " + this._auth.oauth2.buildXOAuth2Token("/* secret */"));
        });
    }
    /**
     *
     * @param {string} command
     * @private
     */ _isDestroyedMessage(command) {
        if (this._destroyed) {
            return "Cannot " + command + " - smtp connection is already destroyed.";
        }
        if (this._socket) {
            if (this._socket.destroyed) {
                return "Cannot " + command + " - smtp connection socket is already destroyed.";
            }
            if (!this._socket.writable) {
                return "Cannot " + command + " - smtp connection socket is already half-closed.";
            }
        }
    }
    _getHostname() {
        // defaul hostname is machine hostname or [IP]
        let defaultHostname;
        try {
            defaultHostname = os.hostname() || "";
        } catch (err) {
            // fails on windows 7
            defaultHostname = "localhost";
        }
        // ignore if not FQDN
        if (!defaultHostname || defaultHostname.indexOf(".") < 0) {
            defaultHostname = "[127.0.0.1]";
        }
        // IP should be enclosed in []
        if (defaultHostname.match(/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/)) {
            defaultHostname = "[" + defaultHostname + "]";
        }
        return defaultHostname;
    }
}
module.exports = SMTPConnection;


/***/ }),

/***/ 161:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const EventEmitter = __webpack_require__(82361);
const PoolResource = __webpack_require__(89229);
const SMTPConnection = __webpack_require__(18425);
const wellKnown = __webpack_require__(65789);
const shared = __webpack_require__(74741);
const packageData = __webpack_require__(98350);
/**
 * Creates a SMTP pool transport object for Nodemailer
 *
 * @constructor
 * @param {Object} options SMTP Connection options
 */ class SMTPPool extends EventEmitter {
    constructor(options){
        super();
        options = options || {};
        if (typeof options === "string") {
            options = {
                url: options
            };
        }
        let urlData;
        let service = options.service;
        if (typeof options.getSocket === "function") {
            this.getSocket = options.getSocket;
        }
        if (options.url) {
            urlData = shared.parseConnectionUrl(options.url);
            service = service || urlData.service;
        }
        this.options = shared.assign(false, options, urlData, service && wellKnown(service) // wellknown options
        );
        this.options.maxConnections = this.options.maxConnections || 5;
        this.options.maxMessages = this.options.maxMessages || 100;
        this.logger = shared.getLogger(this.options, {
            component: this.options.component || "smtp-pool"
        });
        // temporary object
        let connection = new SMTPConnection(this.options);
        this.name = "SMTP (pool)";
        this.version = packageData.version + "[client:" + connection.version + "]";
        this._rateLimit = {
            counter: 0,
            timeout: null,
            waiting: [],
            checkpoint: false,
            delta: Number(this.options.rateDelta) || 1000,
            limit: Number(this.options.rateLimit) || 0
        };
        this._closed = false;
        this._queue = [];
        this._connections = [];
        this._connectionCounter = 0;
        this.idling = true;
        setImmediate(()=>{
            if (this.idling) {
                this.emit("idle");
            }
        });
    }
    /**
     * Placeholder function for creating proxy sockets. This method immediatelly returns
     * without a socket
     *
     * @param {Object} options Connection options
     * @param {Function} callback Callback function to run with the socket keys
     */ getSocket(options, callback) {
        // return immediatelly
        return setImmediate(()=>callback(null, false));
    }
    /**
     * Queues an e-mail to be sent using the selected settings
     *
     * @param {Object} mail Mail object
     * @param {Function} callback Callback function
     */ send(mail, callback) {
        if (this._closed) {
            return false;
        }
        this._queue.push({
            mail,
            requeueAttempts: 0,
            callback
        });
        if (this.idling && this._queue.length >= this.options.maxConnections) {
            this.idling = false;
        }
        setImmediate(()=>this._processMessages());
        return true;
    }
    /**
     * Closes all connections in the pool. If there is a message being sent, the connection
     * is closed later
     */ close() {
        let connection;
        let len = this._connections.length;
        this._closed = true;
        // clear rate limit timer if it exists
        clearTimeout(this._rateLimit.timeout);
        if (!len && !this._queue.length) {
            return;
        }
        // remove all available connections
        for(let i = len - 1; i >= 0; i--){
            if (this._connections[i] && this._connections[i].available) {
                connection = this._connections[i];
                connection.close();
                this.logger.info({
                    tnx: "connection",
                    cid: connection.id,
                    action: "removed"
                }, "Connection #%s removed", connection.id);
            }
        }
        if (len && !this._connections.length) {
            this.logger.debug({
                tnx: "connection"
            }, "All connections removed");
        }
        if (!this._queue.length) {
            return;
        }
        // make sure that entire queue would be cleaned
        let invokeCallbacks = ()=>{
            if (!this._queue.length) {
                this.logger.debug({
                    tnx: "connection"
                }, "Pending queue entries cleared");
                return;
            }
            let entry = this._queue.shift();
            if (entry && typeof entry.callback === "function") {
                try {
                    entry.callback(new Error("Connection pool was closed"));
                } catch (E) {
                    this.logger.error({
                        err: E,
                        tnx: "callback",
                        cid: connection.id
                    }, "Callback error for #%s: %s", connection.id, E.message);
                }
            }
            setImmediate(invokeCallbacks);
        };
        setImmediate(invokeCallbacks);
    }
    /**
     * Check the queue and available connections. If there is a message to be sent and there is
     * an available connection, then use this connection to send the mail
     */ _processMessages() {
        let connection;
        let i, len;
        // do nothing if already closed
        if (this._closed) {
            return;
        }
        // do nothing if queue is empty
        if (!this._queue.length) {
            if (!this.idling) {
                // no pending jobs
                this.idling = true;
                this.emit("idle");
            }
            return;
        }
        // find first available connection
        for(i = 0, len = this._connections.length; i < len; i++){
            if (this._connections[i].available) {
                connection = this._connections[i];
                break;
            }
        }
        if (!connection && this._connections.length < this.options.maxConnections) {
            connection = this._createConnection();
        }
        if (!connection) {
            // no more free connection slots available
            this.idling = false;
            return;
        }
        // check if there is free space in the processing queue
        if (!this.idling && this._queue.length < this.options.maxConnections) {
            this.idling = true;
            this.emit("idle");
        }
        let entry = connection.queueEntry = this._queue.shift();
        entry.messageId = (connection.queueEntry.mail.message.getHeader("message-id") || "").replace(/[<>\s]/g, "");
        connection.available = false;
        this.logger.debug({
            tnx: "pool",
            cid: connection.id,
            messageId: entry.messageId,
            action: "assign"
        }, "Assigned message <%s> to #%s (%s)", entry.messageId, connection.id, connection.messages + 1);
        if (this._rateLimit.limit) {
            this._rateLimit.counter++;
            if (!this._rateLimit.checkpoint) {
                this._rateLimit.checkpoint = Date.now();
            }
        }
        connection.send(entry.mail, (err, info)=>{
            // only process callback if current handler is not changed
            if (entry === connection.queueEntry) {
                try {
                    entry.callback(err, info);
                } catch (E) {
                    this.logger.error({
                        err: E,
                        tnx: "callback",
                        cid: connection.id
                    }, "Callback error for #%s: %s", connection.id, E.message);
                }
                connection.queueEntry = false;
            }
        });
    }
    /**
     * Creates a new pool resource
     */ _createConnection() {
        let connection = new PoolResource(this);
        connection.id = ++this._connectionCounter;
        this.logger.info({
            tnx: "pool",
            cid: connection.id,
            action: "conection"
        }, "Created new pool resource #%s", connection.id);
        // resource comes available
        connection.on("available", ()=>{
            this.logger.debug({
                tnx: "connection",
                cid: connection.id,
                action: "available"
            }, "Connection #%s became available", connection.id);
            if (this._closed) {
                // if already closed run close() that will remove this connections from connections list
                this.close();
            } else {
                // check if there's anything else to send
                this._processMessages();
            }
        });
        // resource is terminated with an error
        connection.once("error", (err)=>{
            if (err.code !== "EMAXLIMIT") {
                this.logger.error({
                    err,
                    tnx: "pool",
                    cid: connection.id
                }, "Pool Error for #%s: %s", connection.id, err.message);
            } else {
                this.logger.debug({
                    tnx: "pool",
                    cid: connection.id,
                    action: "maxlimit"
                }, "Max messages limit exchausted for #%s", connection.id);
            }
            if (connection.queueEntry) {
                try {
                    connection.queueEntry.callback(err);
                } catch (E) {
                    this.logger.error({
                        err: E,
                        tnx: "callback",
                        cid: connection.id
                    }, "Callback error for #%s: %s", connection.id, E.message);
                }
                connection.queueEntry = false;
            }
            // remove the erroneus connection from connections list
            this._removeConnection(connection);
            this._continueProcessing();
        });
        connection.once("close", ()=>{
            this.logger.info({
                tnx: "connection",
                cid: connection.id,
                action: "closed"
            }, "Connection #%s was closed", connection.id);
            this._removeConnection(connection);
            if (connection.queueEntry) {
                // If the connection closed when sending, add the message to the queue again
                // if max number of requeues is not reached yet
                // Note that we must wait a bit.. because the callback of the 'error' handler might be called
                // in the next event loop
                setTimeout(()=>{
                    if (connection.queueEntry) {
                        if (this._shouldRequeuOnConnectionClose(connection.queueEntry)) {
                            this._requeueEntryOnConnectionClose(connection);
                        } else {
                            this._failDeliveryOnConnectionClose(connection);
                        }
                    }
                    this._continueProcessing();
                }, 50);
            } else {
                this._continueProcessing();
            }
        });
        this._connections.push(connection);
        return connection;
    }
    _shouldRequeuOnConnectionClose(queueEntry) {
        if (this.options.maxRequeues === undefined || this.options.maxRequeues < 0) {
            return true;
        }
        return queueEntry.requeueAttempts < this.options.maxRequeues;
    }
    _failDeliveryOnConnectionClose(connection) {
        if (connection.queueEntry && connection.queueEntry.callback) {
            try {
                connection.queueEntry.callback(new Error("Reached maximum number of retries after connection was closed"));
            } catch (E) {
                this.logger.error({
                    err: E,
                    tnx: "callback",
                    messageId: connection.queueEntry.messageId,
                    cid: connection.id
                }, "Callback error for #%s: %s", connection.id, E.message);
            }
            connection.queueEntry = false;
        }
    }
    _requeueEntryOnConnectionClose(connection) {
        connection.queueEntry.requeueAttempts = connection.queueEntry.requeueAttempts + 1;
        this.logger.debug({
            tnx: "pool",
            cid: connection.id,
            messageId: connection.queueEntry.messageId,
            action: "requeue"
        }, "Re-queued message <%s> for #%s. Attempt: #%s", connection.queueEntry.messageId, connection.id, connection.queueEntry.requeueAttempts);
        this._queue.unshift(connection.queueEntry);
        connection.queueEntry = false;
    }
    /**
     * Continue to process message if the pool hasn't closed
     */ _continueProcessing() {
        if (this._closed) {
            this.close();
        } else {
            setTimeout(()=>this._processMessages(), 100);
        }
    }
    /**
     * Remove resource from pool
     *
     * @param {Object} connection The PoolResource to remove
     */ _removeConnection(connection) {
        let index = this._connections.indexOf(connection);
        if (index !== -1) {
            this._connections.splice(index, 1);
        }
    }
    /**
     * Checks if connections have hit current rate limit and if so, queues the availability callback
     *
     * @param {Function} callback Callback function to run once rate limiter has been cleared
     */ _checkRateLimit(callback) {
        if (!this._rateLimit.limit) {
            return callback();
        }
        let now = Date.now();
        if (this._rateLimit.counter < this._rateLimit.limit) {
            return callback();
        }
        this._rateLimit.waiting.push(callback);
        if (this._rateLimit.checkpoint <= now - this._rateLimit.delta) {
            return this._clearRateLimit();
        } else if (!this._rateLimit.timeout) {
            this._rateLimit.timeout = setTimeout(()=>this._clearRateLimit(), this._rateLimit.delta - (now - this._rateLimit.checkpoint));
            this._rateLimit.checkpoint = now;
        }
    }
    /**
     * Clears current rate limit limitation and runs paused callback
     */ _clearRateLimit() {
        clearTimeout(this._rateLimit.timeout);
        this._rateLimit.timeout = null;
        this._rateLimit.counter = 0;
        this._rateLimit.checkpoint = false;
        // resume all paused connections
        while(this._rateLimit.waiting.length){
            let cb = this._rateLimit.waiting.shift();
            setImmediate(cb);
        }
    }
    /**
     * Returns true if there are free slots in the queue
     */ isIdle() {
        return this.idling;
    }
    /**
     * Verifies SMTP configuration
     *
     * @param {Function} callback Callback function
     */ verify(callback) {
        let promise;
        if (!callback) {
            promise = new Promise((resolve, reject)=>{
                callback = shared.callbackPromise(resolve, reject);
            });
        }
        let auth = new PoolResource(this).auth;
        this.getSocket(this.options, (err, socketOptions)=>{
            if (err) {
                return callback(err);
            }
            let options = this.options;
            if (socketOptions && socketOptions.connection) {
                this.logger.info({
                    tnx: "proxy",
                    remoteAddress: socketOptions.connection.remoteAddress,
                    remotePort: socketOptions.connection.remotePort,
                    destHost: options.host || "",
                    destPort: options.port || "",
                    action: "connected"
                }, "Using proxied socket from %s:%s to %s:%s", socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || "", options.port || "");
                options = shared.assign(false, options);
                Object.keys(socketOptions).forEach((key)=>{
                    options[key] = socketOptions[key];
                });
            }
            let connection = new SMTPConnection(options);
            let returned = false;
            connection.once("error", (err)=>{
                if (returned) {
                    return;
                }
                returned = true;
                connection.close();
                return callback(err);
            });
            connection.once("end", ()=>{
                if (returned) {
                    return;
                }
                returned = true;
                return callback(new Error("Connection closed"));
            });
            let finalize = ()=>{
                if (returned) {
                    return;
                }
                returned = true;
                connection.quit();
                return callback(null, true);
            };
            connection.connect(()=>{
                if (returned) {
                    return;
                }
                if (auth && (connection.allowsAuth || options.forceAuth)) {
                    connection.login(auth, (err)=>{
                        if (returned) {
                            return;
                        }
                        if (err) {
                            returned = true;
                            connection.close();
                            return callback(err);
                        }
                        finalize();
                    });
                } else if (!auth && connection.allowsAuth && options.forceAuth) {
                    let err = new Error("Authentication info was not provided");
                    err.code = "NoAuth";
                    returned = true;
                    connection.close();
                    return callback(err);
                } else {
                    finalize();
                }
            });
        });
        return promise;
    }
}
// expose to the world
module.exports = SMTPPool;


/***/ }),

/***/ 89229:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const SMTPConnection = __webpack_require__(18425);
const assign = (__webpack_require__(74741).assign);
const XOAuth2 = __webpack_require__(87791);
const EventEmitter = __webpack_require__(82361);
/**
 * Creates an element for the pool
 *
 * @constructor
 * @param {Object} options SMTPPool instance
 */ class PoolResource extends EventEmitter {
    constructor(pool){
        super();
        this.pool = pool;
        this.options = pool.options;
        this.logger = this.pool.logger;
        if (this.options.auth) {
            switch((this.options.auth.type || "").toString().toUpperCase()){
                case "OAUTH2":
                    {
                        let oauth2 = new XOAuth2(this.options.auth, this.logger);
                        oauth2.provisionCallback = this.pool.mailer && this.pool.mailer.get("oauth2_provision_cb") || oauth2.provisionCallback;
                        this.auth = {
                            type: "OAUTH2",
                            user: this.options.auth.user,
                            oauth2,
                            method: "XOAUTH2"
                        };
                        oauth2.on("token", (token)=>this.pool.mailer.emit("token", token));
                        oauth2.on("error", (err)=>this.emit("error", err));
                        break;
                    }
                default:
                    if (!this.options.auth.user && !this.options.auth.pass) {
                        break;
                    }
                    this.auth = {
                        type: (this.options.auth.type || "").toString().toUpperCase() || "LOGIN",
                        user: this.options.auth.user,
                        credentials: {
                            user: this.options.auth.user || "",
                            pass: this.options.auth.pass,
                            options: this.options.auth.options
                        },
                        method: (this.options.auth.method || "").trim().toUpperCase() || this.options.authMethod || false
                    };
            }
        }
        this._connection = false;
        this._connected = false;
        this.messages = 0;
        this.available = true;
    }
    /**
     * Initiates a connection to the SMTP server
     *
     * @param {Function} callback Callback function to run once the connection is established or failed
     */ connect(callback) {
        this.pool.getSocket(this.options, (err, socketOptions)=>{
            if (err) {
                return callback(err);
            }
            let returned = false;
            let options = this.options;
            if (socketOptions && socketOptions.connection) {
                this.logger.info({
                    tnx: "proxy",
                    remoteAddress: socketOptions.connection.remoteAddress,
                    remotePort: socketOptions.connection.remotePort,
                    destHost: options.host || "",
                    destPort: options.port || "",
                    action: "connected"
                }, "Using proxied socket from %s:%s to %s:%s", socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || "", options.port || "");
                options = assign(false, options);
                Object.keys(socketOptions).forEach((key)=>{
                    options[key] = socketOptions[key];
                });
            }
            this.connection = new SMTPConnection(options);
            this.connection.once("error", (err)=>{
                this.emit("error", err);
                if (returned) {
                    return;
                }
                returned = true;
                return callback(err);
            });
            this.connection.once("end", ()=>{
                this.close();
                if (returned) {
                    return;
                }
                returned = true;
                let timer = setTimeout(()=>{
                    if (returned) {
                        return;
                    }
                    // still have not returned, this means we have an unexpected connection close
                    let err = new Error("Unexpected socket close");
                    if (this.connection && this.connection._socket && this.connection._socket.upgrading) {
                        // starttls connection errors
                        err.code = "ETLS";
                    }
                    callback(err);
                }, 1000);
                try {
                    timer.unref();
                } catch (E) {
                // Ignore. Happens on envs with non-node timer implementation
                }
            });
            this.connection.connect(()=>{
                if (returned) {
                    return;
                }
                if (this.auth && (this.connection.allowsAuth || options.forceAuth)) {
                    this.connection.login(this.auth, (err)=>{
                        if (returned) {
                            return;
                        }
                        returned = true;
                        if (err) {
                            this.connection.close();
                            this.emit("error", err);
                            return callback(err);
                        }
                        this._connected = true;
                        callback(null, true);
                    });
                } else {
                    returned = true;
                    this._connected = true;
                    return callback(null, true);
                }
            });
        });
    }
    /**
     * Sends an e-mail to be sent using the selected settings
     *
     * @param {Object} mail Mail object
     * @param {Function} callback Callback function
     */ send(mail, callback) {
        if (!this._connected) {
            return this.connect((err)=>{
                if (err) {
                    return callback(err);
                }
                return this.send(mail, callback);
            });
        }
        let envelope = mail.message.getEnvelope();
        let messageId = mail.message.messageId();
        let recipients = [].concat(envelope.to || []);
        if (recipients.length > 3) {
            recipients.push("...and " + recipients.splice(2).length + " more");
        }
        this.logger.info({
            tnx: "send",
            messageId,
            cid: this.id
        }, "Sending message %s using #%s to <%s>", messageId, this.id, recipients.join(", "));
        if (mail.data.dsn) {
            envelope.dsn = mail.data.dsn;
        }
        this.connection.send(envelope, mail.message.createReadStream(), (err, info)=>{
            this.messages++;
            if (err) {
                this.connection.close();
                this.emit("error", err);
                return callback(err);
            }
            info.envelope = {
                from: envelope.from,
                to: envelope.to
            };
            info.messageId = messageId;
            setImmediate(()=>{
                let err;
                if (this.messages >= this.options.maxMessages) {
                    err = new Error("Resource exhausted");
                    err.code = "EMAXLIMIT";
                    this.connection.close();
                    this.emit("error", err);
                } else {
                    this.pool._checkRateLimit(()=>{
                        this.available = true;
                        this.emit("available");
                    });
                }
            });
            callback(null, info);
        });
    }
    /**
     * Closes the connection
     */ close() {
        this._connected = false;
        if (this.auth && this.auth.oauth2) {
            this.auth.oauth2.removeAllListeners();
        }
        if (this.connection) {
            this.connection.close();
        }
        this.emit("close");
    }
}
module.exports = PoolResource;


/***/ }),

/***/ 86928:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const EventEmitter = __webpack_require__(82361);
const SMTPConnection = __webpack_require__(18425);
const wellKnown = __webpack_require__(65789);
const shared = __webpack_require__(74741);
const XOAuth2 = __webpack_require__(87791);
const packageData = __webpack_require__(98350);
/**
 * Creates a SMTP transport object for Nodemailer
 *
 * @constructor
 * @param {Object} options Connection options
 */ class SMTPTransport extends EventEmitter {
    constructor(options){
        super();
        options = options || {};
        if (typeof options === "string") {
            options = {
                url: options
            };
        }
        let urlData;
        let service = options.service;
        if (typeof options.getSocket === "function") {
            this.getSocket = options.getSocket;
        }
        if (options.url) {
            urlData = shared.parseConnectionUrl(options.url);
            service = service || urlData.service;
        }
        this.options = shared.assign(false, options, urlData, service && wellKnown(service) // wellknown options
        );
        this.logger = shared.getLogger(this.options, {
            component: this.options.component || "smtp-transport"
        });
        // temporary object
        let connection = new SMTPConnection(this.options);
        this.name = "SMTP";
        this.version = packageData.version + "[client:" + connection.version + "]";
        if (this.options.auth) {
            this.auth = this.getAuth({});
        }
    }
    /**
     * Placeholder function for creating proxy sockets. This method immediatelly returns
     * without a socket
     *
     * @param {Object} options Connection options
     * @param {Function} callback Callback function to run with the socket keys
     */ getSocket(options, callback) {
        // return immediatelly
        return setImmediate(()=>callback(null, false));
    }
    getAuth(authOpts) {
        if (!authOpts) {
            return this.auth;
        }
        let hasAuth = false;
        let authData = {};
        if (this.options.auth && typeof this.options.auth === "object") {
            Object.keys(this.options.auth).forEach((key)=>{
                hasAuth = true;
                authData[key] = this.options.auth[key];
            });
        }
        if (authOpts && typeof authOpts === "object") {
            Object.keys(authOpts).forEach((key)=>{
                hasAuth = true;
                authData[key] = authOpts[key];
            });
        }
        if (!hasAuth) {
            return false;
        }
        switch((authData.type || "").toString().toUpperCase()){
            case "OAUTH2":
                {
                    if (!authData.service && !authData.user) {
                        return false;
                    }
                    let oauth2 = new XOAuth2(authData, this.logger);
                    oauth2.provisionCallback = this.mailer && this.mailer.get("oauth2_provision_cb") || oauth2.provisionCallback;
                    oauth2.on("token", (token)=>this.mailer.emit("token", token));
                    oauth2.on("error", (err)=>this.emit("error", err));
                    return {
                        type: "OAUTH2",
                        user: authData.user,
                        oauth2,
                        method: "XOAUTH2"
                    };
                }
            default:
                return {
                    type: (authData.type || "").toString().toUpperCase() || "LOGIN",
                    user: authData.user,
                    credentials: {
                        user: authData.user || "",
                        pass: authData.pass,
                        options: authData.options
                    },
                    method: (authData.method || "").trim().toUpperCase() || this.options.authMethod || false
                };
        }
    }
    /**
     * Sends an e-mail using the selected settings
     *
     * @param {Object} mail Mail object
     * @param {Function} callback Callback function
     */ send(mail, callback) {
        this.getSocket(this.options, (err, socketOptions)=>{
            if (err) {
                return callback(err);
            }
            let returned = false;
            let options = this.options;
            if (socketOptions && socketOptions.connection) {
                this.logger.info({
                    tnx: "proxy",
                    remoteAddress: socketOptions.connection.remoteAddress,
                    remotePort: socketOptions.connection.remotePort,
                    destHost: options.host || "",
                    destPort: options.port || "",
                    action: "connected"
                }, "Using proxied socket from %s:%s to %s:%s", socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || "", options.port || "");
                // only copy options if we need to modify it
                options = shared.assign(false, options);
                Object.keys(socketOptions).forEach((key)=>{
                    options[key] = socketOptions[key];
                });
            }
            let connection = new SMTPConnection(options);
            connection.once("error", (err)=>{
                if (returned) {
                    return;
                }
                returned = true;
                connection.close();
                return callback(err);
            });
            connection.once("end", ()=>{
                if (returned) {
                    return;
                }
                let timer = setTimeout(()=>{
                    if (returned) {
                        return;
                    }
                    returned = true;
                    // still have not returned, this means we have an unexpected connection close
                    let err = new Error("Unexpected socket close");
                    if (connection && connection._socket && connection._socket.upgrading) {
                        // starttls connection errors
                        err.code = "ETLS";
                    }
                    callback(err);
                }, 1000);
                try {
                    timer.unref();
                } catch (E) {
                // Ignore. Happens on envs with non-node timer implementation
                }
            });
            let sendMessage = ()=>{
                let envelope = mail.message.getEnvelope();
                let messageId = mail.message.messageId();
                let recipients = [].concat(envelope.to || []);
                if (recipients.length > 3) {
                    recipients.push("...and " + recipients.splice(2).length + " more");
                }
                if (mail.data.dsn) {
                    envelope.dsn = mail.data.dsn;
                }
                this.logger.info({
                    tnx: "send",
                    messageId
                }, "Sending message %s to <%s>", messageId, recipients.join(", "));
                connection.send(envelope, mail.message.createReadStream(), (err, info)=>{
                    returned = true;
                    connection.close();
                    if (err) {
                        this.logger.error({
                            err,
                            tnx: "send"
                        }, "Send error for %s: %s", messageId, err.message);
                        return callback(err);
                    }
                    info.envelope = {
                        from: envelope.from,
                        to: envelope.to
                    };
                    info.messageId = messageId;
                    try {
                        return callback(null, info);
                    } catch (E) {
                        this.logger.error({
                            err: E,
                            tnx: "callback"
                        }, "Callback error for %s: %s", messageId, E.message);
                    }
                });
            };
            connection.connect(()=>{
                if (returned) {
                    return;
                }
                let auth = this.getAuth(mail.data.auth);
                if (auth && (connection.allowsAuth || options.forceAuth)) {
                    connection.login(auth, (err)=>{
                        if (auth && auth !== this.auth && auth.oauth2) {
                            auth.oauth2.removeAllListeners();
                        }
                        if (returned) {
                            return;
                        }
                        if (err) {
                            returned = true;
                            connection.close();
                            return callback(err);
                        }
                        sendMessage();
                    });
                } else {
                    sendMessage();
                }
            });
        });
    }
    /**
     * Verifies SMTP configuration
     *
     * @param {Function} callback Callback function
     */ verify(callback) {
        let promise;
        if (!callback) {
            promise = new Promise((resolve, reject)=>{
                callback = shared.callbackPromise(resolve, reject);
            });
        }
        this.getSocket(this.options, (err, socketOptions)=>{
            if (err) {
                return callback(err);
            }
            let options = this.options;
            if (socketOptions && socketOptions.connection) {
                this.logger.info({
                    tnx: "proxy",
                    remoteAddress: socketOptions.connection.remoteAddress,
                    remotePort: socketOptions.connection.remotePort,
                    destHost: options.host || "",
                    destPort: options.port || "",
                    action: "connected"
                }, "Using proxied socket from %s:%s to %s:%s", socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || "", options.port || "");
                options = shared.assign(false, options);
                Object.keys(socketOptions).forEach((key)=>{
                    options[key] = socketOptions[key];
                });
            }
            let connection = new SMTPConnection(options);
            let returned = false;
            connection.once("error", (err)=>{
                if (returned) {
                    return;
                }
                returned = true;
                connection.close();
                return callback(err);
            });
            connection.once("end", ()=>{
                if (returned) {
                    return;
                }
                returned = true;
                return callback(new Error("Connection closed"));
            });
            let finalize = ()=>{
                if (returned) {
                    return;
                }
                returned = true;
                connection.quit();
                return callback(null, true);
            };
            connection.connect(()=>{
                if (returned) {
                    return;
                }
                let authData = this.getAuth({});
                if (authData && (connection.allowsAuth || options.forceAuth)) {
                    connection.login(authData, (err)=>{
                        if (returned) {
                            return;
                        }
                        if (err) {
                            returned = true;
                            connection.close();
                            return callback(err);
                        }
                        finalize();
                    });
                } else if (!authData && connection.allowsAuth && options.forceAuth) {
                    let err = new Error("Authentication info was not provided");
                    err.code = "NoAuth";
                    returned = true;
                    connection.close();
                    return callback(err);
                } else {
                    finalize();
                }
            });
        });
        return promise;
    }
    /**
     * Releases resources
     */ close() {
        if (this.auth && this.auth.oauth2) {
            this.auth.oauth2.removeAllListeners();
        }
        this.emit("close");
    }
}
// expose to the world
module.exports = SMTPTransport;


/***/ }),

/***/ 71430:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const packageData = __webpack_require__(98350);
const shared = __webpack_require__(74741);
/**
 * Generates a Transport object for streaming
 *
 * Possible options can be the following:
 *
 *  * **buffer** if true, then returns the message as a Buffer object instead of a stream
 *  * **newline** either 'windows' or 'unix'
 *
 * @constructor
 * @param {Object} optional config parameter
 */ class StreamTransport {
    constructor(options){
        options = options || {};
        this.options = options || {};
        this.name = "StreamTransport";
        this.version = packageData.version;
        this.logger = shared.getLogger(this.options, {
            component: this.options.component || "stream-transport"
        });
        this.winbreak = [
            "win",
            "windows",
            "dos",
            "\r\n"
        ].includes((options.newline || "").toString().toLowerCase());
    }
    /**
     * Compiles a mailcomposer message and forwards it to handler that sends it
     *
     * @param {Object} emailMessage MailComposer object
     * @param {Function} callback Callback function to run when the sending is completed
     */ send(mail, done) {
        // We probably need this in the output
        mail.message.keepBcc = true;
        let envelope = mail.data.envelope || mail.message.getEnvelope();
        let messageId = mail.message.messageId();
        let recipients = [].concat(envelope.to || []);
        if (recipients.length > 3) {
            recipients.push("...and " + recipients.splice(2).length + " more");
        }
        this.logger.info({
            tnx: "send",
            messageId
        }, "Sending message %s to <%s> using %s line breaks", messageId, recipients.join(", "), this.winbreak ? "<CR><LF>" : "<LF>");
        setImmediate(()=>{
            let stream;
            try {
                stream = mail.message.createReadStream();
            } catch (E) {
                this.logger.error({
                    err: E,
                    tnx: "send",
                    messageId
                }, "Creating send stream failed for %s. %s", messageId, E.message);
                return done(E);
            }
            if (!this.options.buffer) {
                stream.once("error", (err)=>{
                    this.logger.error({
                        err,
                        tnx: "send",
                        messageId
                    }, "Failed creating message for %s. %s", messageId, err.message);
                });
                return done(null, {
                    envelope: mail.data.envelope || mail.message.getEnvelope(),
                    messageId,
                    message: stream
                });
            }
            let chunks = [];
            let chunklen = 0;
            stream.on("readable", ()=>{
                let chunk;
                while((chunk = stream.read()) !== null){
                    chunks.push(chunk);
                    chunklen += chunk.length;
                }
            });
            stream.once("error", (err)=>{
                this.logger.error({
                    err,
                    tnx: "send",
                    messageId
                }, "Failed creating message for %s. %s", messageId, err.message);
                return done(err);
            });
            stream.on("end", ()=>done(null, {
                    envelope: mail.data.envelope || mail.message.getEnvelope(),
                    messageId,
                    message: Buffer.concat(chunks, chunklen)
                }));
        });
    }
}
module.exports = StreamTransport;


/***/ }),

/***/ 65789:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const services = __webpack_require__(49766);
const normalized = {};
Object.keys(services).forEach((key)=>{
    let service = services[key];
    normalized[normalizeKey(key)] = normalizeService(service);
    [].concat(service.aliases || []).forEach((alias)=>{
        normalized[normalizeKey(alias)] = normalizeService(service);
    });
    [].concat(service.domains || []).forEach((domain)=>{
        normalized[normalizeKey(domain)] = normalizeService(service);
    });
});
function normalizeKey(key) {
    return key.replace(/[^a-zA-Z0-9.-]/g, "").toLowerCase();
}
function normalizeService(service) {
    let filter = [
        "domains",
        "aliases"
    ];
    let response = {};
    Object.keys(service).forEach((key)=>{
        if (filter.indexOf(key) < 0) {
            response[key] = service[key];
        }
    });
    return response;
}
/**
 * Resolves SMTP config for given key. Key can be a name (like 'Gmail'), alias (like 'Google Mail') or
 * an email address (like 'test@googlemail.com').
 *
 * @param {String} key [description]
 * @returns {Object} SMTP config or false if not found
 */ module.exports = function(key) {
    key = normalizeKey(key.split("@").pop());
    return normalized[key] || false;
};


/***/ }),

/***/ 87791:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const Stream = (__webpack_require__(12781).Stream);
const nmfetch = __webpack_require__(23872);
const crypto = __webpack_require__(6113);
const shared = __webpack_require__(74741);
/**
 * XOAUTH2 access_token generator for Gmail.
 * Create client ID for web applications in Google API console to use it.
 * See Offline Access for receiving the needed refreshToken for an user
 * https://developers.google.com/accounts/docs/OAuth2WebServer#offline
 *
 * Usage for generating access tokens with a custom method using provisionCallback:
 * provisionCallback(user, renew, callback)
 *   * user is the username to get the token for
 *   * renew is a boolean that if true indicates that existing token failed and needs to be renewed
 *   * callback is the callback to run with (error, accessToken [, expires])
 *     * accessToken is a string
 *     * expires is an optional expire time in milliseconds
 * If provisionCallback is used, then Nodemailer does not try to attempt generating the token by itself
 *
 * @constructor
 * @param {Object} options Client information for token generation
 * @param {String} options.user User e-mail address
 * @param {String} options.clientId Client ID value
 * @param {String} options.clientSecret Client secret value
 * @param {String} options.refreshToken Refresh token for an user
 * @param {String} options.accessUrl Endpoint for token generation, defaults to 'https://accounts.google.com/o/oauth2/token'
 * @param {String} options.accessToken An existing valid accessToken
 * @param {String} options.privateKey Private key for JSW
 * @param {Number} options.expires Optional Access Token expire time in ms
 * @param {Number} options.timeout Optional TTL for Access Token in seconds
 * @param {Function} options.provisionCallback Function to run when a new access token is required
 */ class XOAuth2 extends Stream {
    constructor(options, logger){
        super();
        this.options = options || {};
        if (options && options.serviceClient) {
            if (!options.privateKey || !options.user) {
                setImmediate(()=>this.emit("error", new Error('Options "privateKey" and "user" are required for service account!')));
                return;
            }
            let serviceRequestTimeout = Math.min(Math.max(Number(this.options.serviceRequestTimeout) || 0, 0), 3600);
            this.options.serviceRequestTimeout = serviceRequestTimeout || 5 * 60;
        }
        this.logger = shared.getLogger({
            logger
        }, {
            component: this.options.component || "OAuth2"
        });
        this.provisionCallback = typeof this.options.provisionCallback === "function" ? this.options.provisionCallback : false;
        this.options.accessUrl = this.options.accessUrl || "https://accounts.google.com/o/oauth2/token";
        this.options.customHeaders = this.options.customHeaders || {};
        this.options.customParams = this.options.customParams || {};
        this.accessToken = this.options.accessToken || false;
        if (this.options.expires && Number(this.options.expires)) {
            this.expires = this.options.expires;
        } else {
            let timeout = Math.max(Number(this.options.timeout) || 0, 0);
            this.expires = timeout && Date.now() + timeout * 1000 || 0;
        }
    }
    /**
     * Returns or generates (if previous has expired) a XOAuth2 token
     *
     * @param {Boolean} renew If false then use cached access token (if available)
     * @param {Function} callback Callback function with error object and token string
     */ getToken(renew, callback) {
        if (!renew && this.accessToken && (!this.expires || this.expires > Date.now())) {
            return callback(null, this.accessToken);
        }
        let generateCallback = (...args)=>{
            if (args[0]) {
                this.logger.error({
                    err: args[0],
                    tnx: "OAUTH2",
                    user: this.options.user,
                    action: "renew"
                }, "Failed generating new Access Token for %s", this.options.user);
            } else {
                this.logger.info({
                    tnx: "OAUTH2",
                    user: this.options.user,
                    action: "renew"
                }, "Generated new Access Token for %s", this.options.user);
            }
            callback(...args);
        };
        if (this.provisionCallback) {
            this.provisionCallback(this.options.user, !!renew, (err, accessToken, expires)=>{
                if (!err && accessToken) {
                    this.accessToken = accessToken;
                    this.expires = expires || 0;
                }
                generateCallback(err, accessToken);
            });
        } else {
            this.generateToken(generateCallback);
        }
    }
    /**
     * Updates token values
     *
     * @param {String} accessToken New access token
     * @param {Number} timeout Access token lifetime in seconds
     *
     * Emits 'token': { user: User email-address, accessToken: the new accessToken, timeout: TTL in seconds}
     */ updateToken(accessToken, timeout) {
        this.accessToken = accessToken;
        timeout = Math.max(Number(timeout) || 0, 0);
        this.expires = timeout && Date.now() + timeout * 1000 || 0;
        this.emit("token", {
            user: this.options.user,
            accessToken: accessToken || "",
            expires: this.expires
        });
    }
    /**
     * Generates a new XOAuth2 token with the credentials provided at initialization
     *
     * @param {Function} callback Callback function with error object and token string
     */ generateToken(callback) {
        let urlOptions;
        let loggedUrlOptions;
        if (this.options.serviceClient) {
            // service account - https://developers.google.com/identity/protocols/OAuth2ServiceAccount
            let iat = Math.floor(Date.now() / 1000); // unix time
            let tokenData = {
                iss: this.options.serviceClient,
                scope: this.options.scope || "https://mail.google.com/",
                sub: this.options.user,
                aud: this.options.accessUrl,
                iat,
                exp: iat + this.options.serviceRequestTimeout
            };
            let token;
            try {
                token = this.jwtSignRS256(tokenData);
            } catch (err) {
                return callback(new Error("Can't generate token. Check your auth options"));
            }
            urlOptions = {
                grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
                assertion: token
            };
            loggedUrlOptions = {
                grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
                assertion: tokenData
            };
        } else {
            if (!this.options.refreshToken) {
                return callback(new Error("Can't create new access token for user"));
            }
            // web app - https://developers.google.com/identity/protocols/OAuth2WebServer
            urlOptions = {
                client_id: this.options.clientId || "",
                client_secret: this.options.clientSecret || "",
                refresh_token: this.options.refreshToken,
                grant_type: "refresh_token"
            };
            loggedUrlOptions = {
                client_id: this.options.clientId || "",
                client_secret: (this.options.clientSecret || "").substr(0, 6) + "...",
                refresh_token: (this.options.refreshToken || "").substr(0, 6) + "...",
                grant_type: "refresh_token"
            };
        }
        Object.keys(this.options.customParams).forEach((key)=>{
            urlOptions[key] = this.options.customParams[key];
            loggedUrlOptions[key] = this.options.customParams[key];
        });
        this.logger.debug({
            tnx: "OAUTH2",
            user: this.options.user,
            action: "generate"
        }, "Requesting token using: %s", JSON.stringify(loggedUrlOptions));
        this.postRequest(this.options.accessUrl, urlOptions, this.options, (error, body)=>{
            let data;
            if (error) {
                return callback(error);
            }
            try {
                data = JSON.parse(body.toString());
            } catch (E) {
                return callback(E);
            }
            if (!data || typeof data !== "object") {
                this.logger.debug({
                    tnx: "OAUTH2",
                    user: this.options.user,
                    action: "post"
                }, "Response: %s", (body || "").toString());
                return callback(new Error("Invalid authentication response"));
            }
            let logData = {};
            Object.keys(data).forEach((key)=>{
                if (key !== "access_token") {
                    logData[key] = data[key];
                } else {
                    logData[key] = (data[key] || "").toString().substr(0, 6) + "...";
                }
            });
            this.logger.debug({
                tnx: "OAUTH2",
                user: this.options.user,
                action: "post"
            }, "Response: %s", JSON.stringify(logData));
            if (data.error) {
                // Error Response : https://tools.ietf.org/html/rfc6749#section-5.2
                let errorMessage = data.error;
                if (data.error_description) {
                    errorMessage += ": " + data.error_description;
                }
                if (data.error_uri) {
                    errorMessage += " (" + data.error_uri + ")";
                }
                return callback(new Error(errorMessage));
            }
            if (data.access_token) {
                this.updateToken(data.access_token, data.expires_in);
                return callback(null, this.accessToken);
            }
            return callback(new Error("No access token"));
        });
    }
    /**
     * Converts an access_token and user id into a base64 encoded XOAuth2 token
     *
     * @param {String} [accessToken] Access token string
     * @return {String} Base64 encoded token for IMAP or SMTP login
     */ buildXOAuth2Token(accessToken) {
        let authData = [
            "user=" + (this.options.user || ""),
            "auth=Bearer " + (accessToken || this.accessToken),
            "",
            ""
        ];
        return Buffer.from(authData.join("\x01"), "utf-8").toString("base64");
    }
    /**
     * Custom POST request handler.
     * This is only needed to keep paths short in Windows – usually this module
     * is a dependency of a dependency and if it tries to require something
     * like the request module the paths get way too long to handle for Windows.
     * As we do only a simple POST request we do not actually require complicated
     * logic support (no redirects, no nothing) anyway.
     *
     * @param {String} url Url to POST to
     * @param {String|Buffer} payload Payload to POST
     * @param {Function} callback Callback function with (err, buff)
     */ postRequest(url, payload, params, callback) {
        let returned = false;
        let chunks = [];
        let chunklen = 0;
        let req = nmfetch(url, {
            method: "post",
            headers: params.customHeaders,
            body: payload,
            allowErrorResponse: true
        });
        req.on("readable", ()=>{
            let chunk;
            while((chunk = req.read()) !== null){
                chunks.push(chunk);
                chunklen += chunk.length;
            }
        });
        req.once("error", (err)=>{
            if (returned) {
                return;
            }
            returned = true;
            return callback(err);
        });
        req.once("end", ()=>{
            if (returned) {
                return;
            }
            returned = true;
            return callback(null, Buffer.concat(chunks, chunklen));
        });
    }
    /**
     * Encodes a buffer or a string into Base64url format
     *
     * @param {Buffer|String} data The data to convert
     * @return {String} The encoded string
     */ toBase64URL(data) {
        if (typeof data === "string") {
            data = Buffer.from(data);
        }
        return data.toString("base64").replace(/[=]+/g, "") // remove '='s
        .replace(/\+/g, "-") // '+' → '-'
        .replace(/\//g, "_"); // '/' → '_'
    }
    /**
     * Creates a JSON Web Token signed with RS256 (SHA256 + RSA)
     *
     * @param {Object} payload The payload to include in the generated token
     * @return {String} The generated and signed token
     */ jwtSignRS256(payload) {
        payload = [
            '{"alg":"RS256","typ":"JWT"}',
            JSON.stringify(payload)
        ].map((val)=>this.toBase64URL(val)).join(".");
        let signature = crypto.createSign("RSA-SHA256").update(payload).sign(this.options.privateKey);
        return payload + "." + this.toBase64URL(signature);
    }
}
module.exports = XOAuth2;


/***/ }),

/***/ 1279:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.OAuth = __webpack_require__(70208).OAuth;
exports.OAuthEcho = __webpack_require__(70208).OAuthEcho;
exports.OAuth2 = __webpack_require__(38925).OAuth2;


/***/ }),

/***/ 4436:
/***/ ((module) => {

"use strict";
// Returns true if this is a host that closes *before* it ends?!?!

module.exports.isAnEarlyCloseHost = function(hostName) {
    return hostName && hostName.match(".*google(apis)?.com$");
};


/***/ }),

/***/ 70208:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var crypto = __webpack_require__(6113), sha1 = __webpack_require__(82875), http = __webpack_require__(13685), https = __webpack_require__(95687), URL = __webpack_require__(57310), querystring = __webpack_require__(63477), OAuthUtils = __webpack_require__(4436);
exports.OAuth = function(requestUrl, accessUrl, consumerKey, consumerSecret, version, authorize_callback, signatureMethod, nonceSize, customHeaders) {
    this._isEcho = false;
    this._requestUrl = requestUrl;
    this._accessUrl = accessUrl;
    this._consumerKey = consumerKey;
    this._consumerSecret = this._encodeData(consumerSecret);
    if (signatureMethod == "RSA-SHA1") {
        this._privateKey = consumerSecret;
    }
    this._version = version;
    if (authorize_callback === undefined) {
        this._authorize_callback = "oob";
    } else {
        this._authorize_callback = authorize_callback;
    }
    if (signatureMethod != "PLAINTEXT" && signatureMethod != "HMAC-SHA1" && signatureMethod != "RSA-SHA1") throw new Error("Un-supported signature method: " + signatureMethod);
    this._signatureMethod = signatureMethod;
    this._nonceSize = nonceSize || 32;
    this._headers = customHeaders || {
        "Accept": "*/*",
        "Connection": "close",
        "User-Agent": "Node authentication"
    };
    this._clientOptions = this._defaultClientOptions = {
        "requestTokenHttpMethod": "POST",
        "accessTokenHttpMethod": "POST",
        "followRedirects": true
    };
    this._oauthParameterSeperator = ",";
};
exports.OAuthEcho = function(realm, verify_credentials, consumerKey, consumerSecret, version, signatureMethod, nonceSize, customHeaders) {
    this._isEcho = true;
    this._realm = realm;
    this._verifyCredentials = verify_credentials;
    this._consumerKey = consumerKey;
    this._consumerSecret = this._encodeData(consumerSecret);
    if (signatureMethod == "RSA-SHA1") {
        this._privateKey = consumerSecret;
    }
    this._version = version;
    if (signatureMethod != "PLAINTEXT" && signatureMethod != "HMAC-SHA1" && signatureMethod != "RSA-SHA1") throw new Error("Un-supported signature method: " + signatureMethod);
    this._signatureMethod = signatureMethod;
    this._nonceSize = nonceSize || 32;
    this._headers = customHeaders || {
        "Accept": "*/*",
        "Connection": "close",
        "User-Agent": "Node authentication"
    };
    this._oauthParameterSeperator = ",";
};
exports.OAuthEcho.prototype = exports.OAuth.prototype;
exports.OAuth.prototype._getTimestamp = function() {
    return Math.floor(new Date().getTime() / 1000);
};
exports.OAuth.prototype._encodeData = function(toEncode) {
    if (toEncode == null || toEncode == "") return "";
    else {
        var result = encodeURIComponent(toEncode);
        // Fix the mismatch between OAuth's  RFC3986's and Javascript's beliefs in what is right and wrong ;)
        return result.replace(/\!/g, "%21").replace(/\'/g, "%27").replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/\*/g, "%2A");
    }
};
exports.OAuth.prototype._decodeData = function(toDecode) {
    if (toDecode != null) {
        toDecode = toDecode.replace(/\+/g, " ");
    }
    return decodeURIComponent(toDecode);
};
exports.OAuth.prototype._getSignature = function(method, url, parameters, tokenSecret) {
    var signatureBase = this._createSignatureBase(method, url, parameters);
    return this._createSignature(signatureBase, tokenSecret);
};
exports.OAuth.prototype._normalizeUrl = function(url) {
    var parsedUrl = URL.parse(url, true);
    var port = "";
    if (parsedUrl.port) {
        if (parsedUrl.protocol == "http:" && parsedUrl.port != "80" || parsedUrl.protocol == "https:" && parsedUrl.port != "443") {
            port = ":" + parsedUrl.port;
        }
    }
    if (!parsedUrl.pathname || parsedUrl.pathname == "") parsedUrl.pathname = "/";
    return parsedUrl.protocol + "//" + parsedUrl.hostname + port + parsedUrl.pathname;
};
// Is the parameter considered an OAuth parameter
exports.OAuth.prototype._isParameterNameAnOAuthParameter = function(parameter) {
    var m = parameter.match("^oauth_");
    if (m && m[0] === "oauth_") {
        return true;
    } else {
        return false;
    }
};
// build the OAuth request authorization header
exports.OAuth.prototype._buildAuthorizationHeaders = function(orderedParameters) {
    var authHeader = "OAuth ";
    if (this._isEcho) {
        authHeader += 'realm="' + this._realm + '",';
    }
    for(var i = 0; i < orderedParameters.length; i++){
        // Whilst the all the parameters should be included within the signature, only the oauth_ arguments
        // should appear within the authorization header.
        if (this._isParameterNameAnOAuthParameter(orderedParameters[i][0])) {
            authHeader += "" + this._encodeData(orderedParameters[i][0]) + '="' + this._encodeData(orderedParameters[i][1]) + '"' + this._oauthParameterSeperator;
        }
    }
    authHeader = authHeader.substring(0, authHeader.length - this._oauthParameterSeperator.length);
    return authHeader;
};
// Takes an object literal that represents the arguments, and returns an array
// of argument/value pairs.
exports.OAuth.prototype._makeArrayOfArgumentsHash = function(argumentsHash) {
    var argument_pairs = [];
    for(var key in argumentsHash){
        if (argumentsHash.hasOwnProperty(key)) {
            var value = argumentsHash[key];
            if (Array.isArray(value)) {
                for(var i = 0; i < value.length; i++){
                    argument_pairs[argument_pairs.length] = [
                        key,
                        value[i]
                    ];
                }
            } else {
                argument_pairs[argument_pairs.length] = [
                    key,
                    value
                ];
            }
        }
    }
    return argument_pairs;
};
// Sorts the encoded key value pairs by encoded name, then encoded value
exports.OAuth.prototype._sortRequestParams = function(argument_pairs) {
    // Sort by name, then value.
    argument_pairs.sort(function(a, b) {
        if (a[0] == b[0]) {
            return a[1] < b[1] ? -1 : 1;
        } else return a[0] < b[0] ? -1 : 1;
    });
    return argument_pairs;
};
exports.OAuth.prototype._normaliseRequestParams = function(args) {
    var argument_pairs = this._makeArrayOfArgumentsHash(args);
    // First encode them #3.4.1.3.2 .1
    for(var i = 0; i < argument_pairs.length; i++){
        argument_pairs[i][0] = this._encodeData(argument_pairs[i][0]);
        argument_pairs[i][1] = this._encodeData(argument_pairs[i][1]);
    }
    // Then sort them #3.4.1.3.2 .2
    argument_pairs = this._sortRequestParams(argument_pairs);
    // Then concatenate together #3.4.1.3.2 .3 & .4
    var args = "";
    for(var i = 0; i < argument_pairs.length; i++){
        args += argument_pairs[i][0];
        args += "=";
        args += argument_pairs[i][1];
        if (i < argument_pairs.length - 1) args += "&";
    }
    return args;
};
exports.OAuth.prototype._createSignatureBase = function(method, url, parameters) {
    url = this._encodeData(this._normalizeUrl(url));
    parameters = this._encodeData(parameters);
    return method.toUpperCase() + "&" + url + "&" + parameters;
};
exports.OAuth.prototype._createSignature = function(signatureBase, tokenSecret) {
    if (tokenSecret === undefined) var tokenSecret = "";
    else tokenSecret = this._encodeData(tokenSecret);
    // consumerSecret is already encoded
    var key = this._consumerSecret + "&" + tokenSecret;
    var hash = "";
    if (this._signatureMethod == "PLAINTEXT") {
        hash = key;
    } else if (this._signatureMethod == "RSA-SHA1") {
        key = this._privateKey || "";
        hash = crypto.createSign("RSA-SHA1").update(signatureBase).sign(key, "base64");
    } else {
        if (crypto.Hmac) {
            hash = crypto.createHmac("sha1", key).update(signatureBase).digest("base64");
        } else {
            hash = sha1.HMACSHA1(key, signatureBase);
        }
    }
    return hash;
};
exports.OAuth.prototype.NONCE_CHARS = [
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9"
];
exports.OAuth.prototype._getNonce = function(nonceSize) {
    var result = [];
    var chars = this.NONCE_CHARS;
    var char_pos;
    var nonce_chars_length = chars.length;
    for(var i = 0; i < nonceSize; i++){
        char_pos = Math.floor(Math.random() * nonce_chars_length);
        result[i] = chars[char_pos];
    }
    return result.join("");
};
exports.OAuth.prototype._createClient = function(port, hostname, method, path, headers, sslEnabled) {
    var options = {
        host: hostname,
        port: port,
        path: path,
        method: method,
        headers: headers
    };
    var httpModel;
    if (sslEnabled) {
        httpModel = https;
    } else {
        httpModel = http;
    }
    return httpModel.request(options);
};
exports.OAuth.prototype._prepareParameters = function(oauth_token, oauth_token_secret, method, url, extra_params) {
    var oauthParameters = {
        "oauth_timestamp": this._getTimestamp(),
        "oauth_nonce": this._getNonce(this._nonceSize),
        "oauth_version": this._version,
        "oauth_signature_method": this._signatureMethod,
        "oauth_consumer_key": this._consumerKey
    };
    if (oauth_token) {
        oauthParameters["oauth_token"] = oauth_token;
    }
    var sig;
    if (this._isEcho) {
        sig = this._getSignature("GET", this._verifyCredentials, this._normaliseRequestParams(oauthParameters), oauth_token_secret);
    } else {
        if (extra_params) {
            for(var key in extra_params){
                if (extra_params.hasOwnProperty(key)) oauthParameters[key] = extra_params[key];
            }
        }
        var parsedUrl = URL.parse(url, false);
        if (parsedUrl.query) {
            var key2;
            var extraParameters = querystring.parse(parsedUrl.query);
            for(var key in extraParameters){
                var value = extraParameters[key];
                if (typeof value == "object") {
                    // TODO: This probably should be recursive
                    for(key2 in value){
                        oauthParameters[key + "[" + key2 + "]"] = value[key2];
                    }
                } else {
                    oauthParameters[key] = value;
                }
            }
        }
        sig = this._getSignature(method, url, this._normaliseRequestParams(oauthParameters), oauth_token_secret);
    }
    var orderedParameters = this._sortRequestParams(this._makeArrayOfArgumentsHash(oauthParameters));
    orderedParameters[orderedParameters.length] = [
        "oauth_signature",
        sig
    ];
    return orderedParameters;
};
exports.OAuth.prototype._performSecureRequest = function(oauth_token, oauth_token_secret, method, url, extra_params, post_body, post_content_type, callback) {
    var orderedParameters = this._prepareParameters(oauth_token, oauth_token_secret, method, url, extra_params);
    if (!post_content_type) {
        post_content_type = "application/x-www-form-urlencoded";
    }
    var parsedUrl = URL.parse(url, false);
    if (parsedUrl.protocol == "http:" && !parsedUrl.port) parsedUrl.port = 80;
    if (parsedUrl.protocol == "https:" && !parsedUrl.port) parsedUrl.port = 443;
    var headers = {};
    var authorization = this._buildAuthorizationHeaders(orderedParameters);
    if (this._isEcho) {
        headers["X-Verify-Credentials-Authorization"] = authorization;
    } else {
        headers["Authorization"] = authorization;
    }
    headers["Host"] = parsedUrl.host;
    for(var key in this._headers){
        if (this._headers.hasOwnProperty(key)) {
            headers[key] = this._headers[key];
        }
    }
    // Filter out any passed extra_params that are really to do with OAuth
    for(var key in extra_params){
        if (this._isParameterNameAnOAuthParameter(key)) {
            delete extra_params[key];
        }
    }
    if ((method == "POST" || method == "PUT") && post_body == null && extra_params != null) {
        // Fix the mismatch between the output of querystring.stringify() and this._encodeData()
        post_body = querystring.stringify(extra_params).replace(/\!/g, "%21").replace(/\'/g, "%27").replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/\*/g, "%2A");
    }
    if (post_body) {
        if (Buffer.isBuffer(post_body)) {
            headers["Content-length"] = post_body.length;
        } else {
            headers["Content-length"] = Buffer.byteLength(post_body);
        }
    } else {
        headers["Content-length"] = 0;
    }
    headers["Content-Type"] = post_content_type;
    var path;
    if (!parsedUrl.pathname || parsedUrl.pathname == "") parsedUrl.pathname = "/";
    if (parsedUrl.query) path = parsedUrl.pathname + "?" + parsedUrl.query;
    else path = parsedUrl.pathname;
    var request;
    if (parsedUrl.protocol == "https:") {
        request = this._createClient(parsedUrl.port, parsedUrl.hostname, method, path, headers, true);
    } else {
        request = this._createClient(parsedUrl.port, parsedUrl.hostname, method, path, headers);
    }
    var clientOptions = this._clientOptions;
    if (callback) {
        var data = "";
        var self = this;
        // Some hosts *cough* google appear to close the connection early / send no content-length header
        // allow this behaviour.
        var allowEarlyClose = OAuthUtils.isAnEarlyCloseHost(parsedUrl.hostname);
        var callbackCalled = false;
        var passBackControl = function(response) {
            if (!callbackCalled) {
                callbackCalled = true;
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    callback(null, data, response);
                } else {
                    // Follow 301 or 302 redirects with Location HTTP header
                    if ((response.statusCode == 301 || response.statusCode == 302) && clientOptions.followRedirects && response.headers && response.headers.location) {
                        self._performSecureRequest(oauth_token, oauth_token_secret, method, response.headers.location, extra_params, post_body, post_content_type, callback);
                    } else {
                        callback({
                            statusCode: response.statusCode,
                            data: data
                        }, data, response);
                    }
                }
            }
        };
        request.on("response", function(response) {
            response.setEncoding("utf8");
            response.on("data", function(chunk) {
                data += chunk;
            });
            response.on("end", function() {
                passBackControl(response);
            });
            response.on("close", function() {
                if (allowEarlyClose) {
                    passBackControl(response);
                }
            });
        });
        request.on("error", function(err) {
            if (!callbackCalled) {
                callbackCalled = true;
                callback(err);
            }
        });
        if ((method == "POST" || method == "PUT") && post_body != null && post_body != "") {
            request.write(post_body);
        }
        request.end();
    } else {
        if ((method == "POST" || method == "PUT") && post_body != null && post_body != "") {
            request.write(post_body);
        }
        return request;
    }
    return;
};
exports.OAuth.prototype.setClientOptions = function(options) {
    var key, mergedOptions = {}, hasOwnProperty = Object.prototype.hasOwnProperty;
    for(key in this._defaultClientOptions){
        if (!hasOwnProperty.call(options, key)) {
            mergedOptions[key] = this._defaultClientOptions[key];
        } else {
            mergedOptions[key] = options[key];
        }
    }
    this._clientOptions = mergedOptions;
};
exports.OAuth.prototype.getOAuthAccessToken = function(oauth_token, oauth_token_secret, oauth_verifier, callback) {
    var extraParams = {};
    if (typeof oauth_verifier == "function") {
        callback = oauth_verifier;
    } else {
        extraParams.oauth_verifier = oauth_verifier;
    }
    this._performSecureRequest(oauth_token, oauth_token_secret, this._clientOptions.accessTokenHttpMethod, this._accessUrl, extraParams, null, null, function(error, data, response) {
        if (error) callback(error);
        else {
            var results = querystring.parse(data);
            var oauth_access_token = results["oauth_token"];
            delete results["oauth_token"];
            var oauth_access_token_secret = results["oauth_token_secret"];
            delete results["oauth_token_secret"];
            callback(null, oauth_access_token, oauth_access_token_secret, results);
        }
    });
};
// Deprecated
exports.OAuth.prototype.getProtectedResource = function(url, method, oauth_token, oauth_token_secret, callback) {
    this._performSecureRequest(oauth_token, oauth_token_secret, method, url, null, "", null, callback);
};
exports.OAuth.prototype["delete"] = function(url, oauth_token, oauth_token_secret, callback) {
    return this._performSecureRequest(oauth_token, oauth_token_secret, "DELETE", url, null, "", null, callback);
};
exports.OAuth.prototype.get = function(url, oauth_token, oauth_token_secret, callback) {
    return this._performSecureRequest(oauth_token, oauth_token_secret, "GET", url, null, "", null, callback);
};
exports.OAuth.prototype._putOrPost = function(method, url, oauth_token, oauth_token_secret, post_body, post_content_type, callback) {
    var extra_params = null;
    if (typeof post_content_type == "function") {
        callback = post_content_type;
        post_content_type = null;
    }
    if (typeof post_body != "string" && !Buffer.isBuffer(post_body)) {
        post_content_type = "application/x-www-form-urlencoded";
        extra_params = post_body;
        post_body = null;
    }
    return this._performSecureRequest(oauth_token, oauth_token_secret, method, url, extra_params, post_body, post_content_type, callback);
};
exports.OAuth.prototype.put = function(url, oauth_token, oauth_token_secret, post_body, post_content_type, callback) {
    return this._putOrPost("PUT", url, oauth_token, oauth_token_secret, post_body, post_content_type, callback);
};
exports.OAuth.prototype.post = function(url, oauth_token, oauth_token_secret, post_body, post_content_type, callback) {
    return this._putOrPost("POST", url, oauth_token, oauth_token_secret, post_body, post_content_type, callback);
};
/**
 * Gets a request token from the OAuth provider and passes that information back
 * to the calling code.
 *
 * The callback should expect a function of the following form:
 *
 * function(err, token, token_secret, parsedQueryString) {}
 *
 * This method has optional parameters so can be called in the following 2 ways:
 *
 * 1) Primary use case: Does a basic request with no extra parameters
 *  getOAuthRequestToken( callbackFunction )
 *
 * 2) As above but allows for provision of extra parameters to be sent as part of the query to the server.
 *  getOAuthRequestToken( extraParams, callbackFunction )
 *
 * N.B. This method will HTTP POST verbs by default, if you wish to override this behaviour you will
 * need to provide a requestTokenHttpMethod option when creating the client.
 *
 **/ exports.OAuth.prototype.getOAuthRequestToken = function(extraParams, callback) {
    if (typeof extraParams == "function") {
        callback = extraParams;
        extraParams = {};
    }
    // Callbacks are 1.0A related
    if (this._authorize_callback) {
        extraParams["oauth_callback"] = this._authorize_callback;
    }
    this._performSecureRequest(null, null, this._clientOptions.requestTokenHttpMethod, this._requestUrl, extraParams, null, null, function(error, data, response) {
        if (error) callback(error);
        else {
            var results = querystring.parse(data);
            var oauth_token = results["oauth_token"];
            var oauth_token_secret = results["oauth_token_secret"];
            delete results["oauth_token"];
            delete results["oauth_token_secret"];
            callback(null, oauth_token, oauth_token_secret, results);
        }
    });
};
exports.OAuth.prototype.signUrl = function(url, oauth_token, oauth_token_secret, method) {
    if (method === undefined) {
        var method = "GET";
    }
    var orderedParameters = this._prepareParameters(oauth_token, oauth_token_secret, method, url, {});
    var parsedUrl = URL.parse(url, false);
    var query = "";
    for(var i = 0; i < orderedParameters.length; i++){
        query += orderedParameters[i][0] + "=" + this._encodeData(orderedParameters[i][1]) + "&";
    }
    query = query.substring(0, query.length - 1);
    return parsedUrl.protocol + "//" + parsedUrl.host + parsedUrl.pathname + "?" + query;
};
exports.OAuth.prototype.authHeader = function(url, oauth_token, oauth_token_secret, method) {
    if (method === undefined) {
        var method = "GET";
    }
    var orderedParameters = this._prepareParameters(oauth_token, oauth_token_secret, method, url, {});
    return this._buildAuthorizationHeaders(orderedParameters);
};


/***/ }),

/***/ 38925:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var querystring = __webpack_require__(63477), crypto = __webpack_require__(6113), https = __webpack_require__(95687), http = __webpack_require__(13685), URL = __webpack_require__(57310), OAuthUtils = __webpack_require__(4436);
exports.OAuth2 = function(clientId, clientSecret, baseSite, authorizePath, accessTokenPath, customHeaders) {
    this._clientId = clientId;
    this._clientSecret = clientSecret;
    this._baseSite = baseSite;
    this._authorizeUrl = authorizePath || "/oauth/authorize";
    this._accessTokenUrl = accessTokenPath || "/oauth/access_token";
    this._accessTokenName = "access_token";
    this._authMethod = "Bearer";
    this._customHeaders = customHeaders || {};
    this._useAuthorizationHeaderForGET = false;
    //our agent
    this._agent = undefined;
};
// Allows you to set an agent to use instead of the default HTTP or
// HTTPS agents. Useful when dealing with your own certificates.
exports.OAuth2.prototype.setAgent = function(agent) {
    this._agent = agent;
};
// This 'hack' method is required for sites that don't use
// 'access_token' as the name of the access token (for requests).
// ( http://tools.ietf.org/html/draft-ietf-oauth-v2-16#section-7 )
// it isn't clear what the correct value should be atm, so allowing
// for specific (temporary?) override for now.
exports.OAuth2.prototype.setAccessTokenName = function(name) {
    this._accessTokenName = name;
};
// Sets the authorization method for Authorization header.
// e.g. Authorization: Bearer <token>  # "Bearer" is the authorization method.
exports.OAuth2.prototype.setAuthMethod = function(authMethod) {
    this._authMethod = authMethod;
};
// If you use the OAuth2 exposed 'get' method (and don't construct your own _request call )
// this will specify whether to use an 'Authorize' header instead of passing the access_token as a query parameter
exports.OAuth2.prototype.useAuthorizationHeaderforGET = function(useIt) {
    this._useAuthorizationHeaderForGET = useIt;
};
exports.OAuth2.prototype._getAccessTokenUrl = function() {
    return this._baseSite + this._accessTokenUrl; /* + "?" + querystring.stringify(params); */ 
};
// Build the authorization header. In particular, build the part after the colon.
// e.g. Authorization: Bearer <token>  # Build "Bearer <token>"
exports.OAuth2.prototype.buildAuthHeader = function(token) {
    return this._authMethod + " " + token;
};
exports.OAuth2.prototype._chooseHttpLibrary = function(parsedUrl) {
    var http_library = https;
    // As this is OAUth2, we *assume* https unless told explicitly otherwise.
    if (parsedUrl.protocol != "https:") {
        http_library = http;
    }
    return http_library;
};
exports.OAuth2.prototype._request = function(method, url, headers, post_body, access_token, callback) {
    var parsedUrl = URL.parse(url, true);
    if (parsedUrl.protocol == "https:" && !parsedUrl.port) {
        parsedUrl.port = 443;
    }
    var http_library = this._chooseHttpLibrary(parsedUrl);
    var realHeaders = {};
    for(var key in this._customHeaders){
        realHeaders[key] = this._customHeaders[key];
    }
    if (headers) {
        for(var key in headers){
            realHeaders[key] = headers[key];
        }
    }
    realHeaders["Host"] = parsedUrl.host;
    if (!realHeaders["User-Agent"]) {
        realHeaders["User-Agent"] = "Node-oauth";
    }
    if (post_body) {
        if (Buffer.isBuffer(post_body)) {
            realHeaders["Content-Length"] = post_body.length;
        } else {
            realHeaders["Content-Length"] = Buffer.byteLength(post_body);
        }
    } else {
        realHeaders["Content-length"] = 0;
    }
    if (access_token && !("Authorization" in realHeaders)) {
        if (!parsedUrl.query) parsedUrl.query = {};
        parsedUrl.query[this._accessTokenName] = access_token;
    }
    var queryStr = querystring.stringify(parsedUrl.query);
    if (queryStr) queryStr = "?" + queryStr;
    var options = {
        host: parsedUrl.hostname,
        port: parsedUrl.port,
        path: parsedUrl.pathname + queryStr,
        method: method,
        headers: realHeaders
    };
    this._executeRequest(http_library, options, post_body, callback);
};
exports.OAuth2.prototype._executeRequest = function(http_library, options, post_body, callback) {
    // Some hosts *cough* google appear to close the connection early / send no content-length header
    // allow this behaviour.
    var allowEarlyClose = OAuthUtils.isAnEarlyCloseHost(options.host);
    var callbackCalled = false;
    function passBackControl(response, result) {
        if (!callbackCalled) {
            callbackCalled = true;
            if (!(response.statusCode >= 200 && response.statusCode <= 299) && response.statusCode != 301 && response.statusCode != 302) {
                callback({
                    statusCode: response.statusCode,
                    data: result
                });
            } else {
                callback(null, result, response);
            }
        }
    }
    var result = "";
    //set the agent on the request options
    if (this._agent) {
        options.agent = this._agent;
    }
    var request = http_library.request(options);
    request.on("response", function(response) {
        response.on("data", function(chunk) {
            result += chunk;
        });
        response.on("close", function(err) {
            if (allowEarlyClose) {
                passBackControl(response, result);
            }
        });
        response.addListener("end", function() {
            passBackControl(response, result);
        });
    });
    request.on("error", function(e) {
        callbackCalled = true;
        callback(e);
    });
    if ((options.method == "POST" || options.method == "PUT") && post_body) {
        request.write(post_body);
    }
    request.end();
};
exports.OAuth2.prototype.getAuthorizeUrl = function(params) {
    var params = params || {};
    params["client_id"] = this._clientId;
    return this._baseSite + this._authorizeUrl + "?" + querystring.stringify(params);
};
exports.OAuth2.prototype.getOAuthAccessToken = function(code, params, callback) {
    var params = params || {};
    params["client_id"] = this._clientId;
    params["client_secret"] = this._clientSecret;
    var codeParam = params.grant_type === "refresh_token" ? "refresh_token" : "code";
    params[codeParam] = code;
    var post_data = querystring.stringify(params);
    var post_headers = {
        "Content-Type": "application/x-www-form-urlencoded"
    };
    this._request("POST", this._getAccessTokenUrl(), post_headers, post_data, null, function(error, data, response) {
        if (error) callback(error);
        else {
            var results;
            try {
                // As of http://tools.ietf.org/html/draft-ietf-oauth-v2-07
                // responses should be in JSON
                results = JSON.parse(data);
            } catch (e) {
                // .... However both Facebook + Github currently use rev05 of the spec
                // and neither seem to specify a content-type correctly in their response headers :(
                // clients of these services will suffer a *minor* performance cost of the exception
                // being thrown
                results = querystring.parse(data);
            }
            var access_token = results["access_token"];
            var refresh_token = results["refresh_token"];
            delete results["refresh_token"];
            callback(null, access_token, refresh_token, results); // callback results =-=
        }
    });
};
// Deprecated
exports.OAuth2.prototype.getProtectedResource = function(url, access_token, callback) {
    this._request("GET", url, {}, "", access_token, callback);
};
exports.OAuth2.prototype.get = function(url, access_token, callback) {
    if (this._useAuthorizationHeaderForGET) {
        var headers = {
            "Authorization": this.buildAuthHeader(access_token)
        };
        access_token = null;
    } else {
        headers = {};
    }
    this._request("GET", url, headers, "", access_token, callback);
};


/***/ }),

/***/ 82875:
/***/ ((__unused_webpack_module, exports) => {

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS 180-1
 * Version 2.2 Copyright Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */ /*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */ var hexcase = 1; /* hex output format. 0 - lowercase; 1 - uppercase        */ 
var b64pad = "="; /* base-64 pad character. "=" for strict RFC compliance   */ 
/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */ function hex_sha1(s) {
    return rstr2hex(rstr_sha1(str2rstr_utf8(s)));
}
function b64_sha1(s) {
    return rstr2b64(rstr_sha1(str2rstr_utf8(s)));
}
function any_sha1(s, e) {
    return rstr2any(rstr_sha1(str2rstr_utf8(s)), e);
}
function hex_hmac_sha1(k, d) {
    return rstr2hex(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d)));
}
function b64_hmac_sha1(k, d) {
    return rstr2b64(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d)));
}
function any_hmac_sha1(k, d, e) {
    return rstr2any(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d)), e);
}
/*
 * Perform a simple self-test to see if the VM is working
 */ function sha1_vm_test() {
    return hex_sha1("abc").toLowerCase() == "a9993e364706816aba3e25717850c26c9cd0d89d";
}
/*
 * Calculate the SHA1 of a raw string
 */ function rstr_sha1(s) {
    return binb2rstr(binb_sha1(rstr2binb(s), s.length * 8));
}
/*
 * Calculate the HMAC-SHA1 of a key and some data (raw strings)
 */ function rstr_hmac_sha1(key, data) {
    var bkey = rstr2binb(key);
    if (bkey.length > 16) bkey = binb_sha1(bkey, key.length * 8);
    var ipad = Array(16), opad = Array(16);
    for(var i = 0; i < 16; i++){
        ipad[i] = bkey[i] ^ 0x36363636;
        opad[i] = bkey[i] ^ 0x5C5C5C5C;
    }
    var hash = binb_sha1(ipad.concat(rstr2binb(data)), 512 + data.length * 8);
    return binb2rstr(binb_sha1(opad.concat(hash), 512 + 160));
}
/*
 * Convert a raw string to a hex string
 */ function rstr2hex(input) {
    try {
        hexcase;
    } catch (e) {
        hexcase = 0;
    }
    var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
    var output = "";
    var x;
    for(var i = 0; i < input.length; i++){
        x = input.charCodeAt(i);
        output += hex_tab.charAt(x >>> 4 & 0x0F) + hex_tab.charAt(x & 0x0F);
    }
    return output;
}
/*
 * Convert a raw string to a base-64 string
 */ function rstr2b64(input) {
    try {
        b64pad;
    } catch (e) {
        b64pad = "";
    }
    var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var output = "";
    var len = input.length;
    for(var i = 0; i < len; i += 3){
        var triplet = input.charCodeAt(i) << 16 | (i + 1 < len ? input.charCodeAt(i + 1) << 8 : 0) | (i + 2 < len ? input.charCodeAt(i + 2) : 0);
        for(var j = 0; j < 4; j++){
            if (i * 8 + j * 6 > input.length * 8) output += b64pad;
            else output += tab.charAt(triplet >>> 6 * (3 - j) & 0x3F);
        }
    }
    return output;
}
/*
 * Convert a raw string to an arbitrary string encoding
 */ function rstr2any(input, encoding) {
    var divisor = encoding.length;
    var remainders = Array();
    var i, q, x, quotient;
    /* Convert to an array of 16-bit big-endian values, forming the dividend */ var dividend = Array(Math.ceil(input.length / 2));
    for(i = 0; i < dividend.length; i++){
        dividend[i] = input.charCodeAt(i * 2) << 8 | input.charCodeAt(i * 2 + 1);
    }
    /*
   * Repeatedly perform a long division. The binary array forms the dividend,
   * the length of the encoding is the divisor. Once computed, the quotient
   * forms the dividend for the next step. We stop when the dividend is zero.
   * All remainders are stored for later use.
   */ while(dividend.length > 0){
        quotient = Array();
        x = 0;
        for(i = 0; i < dividend.length; i++){
            x = (x << 16) + dividend[i];
            q = Math.floor(x / divisor);
            x -= q * divisor;
            if (quotient.length > 0 || q > 0) quotient[quotient.length] = q;
        }
        remainders[remainders.length] = x;
        dividend = quotient;
    }
    /* Convert the remainders to the output string */ var output = "";
    for(i = remainders.length - 1; i >= 0; i--)output += encoding.charAt(remainders[i]);
    /* Append leading zero equivalents */ var full_length = Math.ceil(input.length * 8 / (Math.log(encoding.length) / Math.log(2)));
    for(i = output.length; i < full_length; i++)output = encoding[0] + output;
    return output;
}
/*
 * Encode a string as utf-8.
 * For efficiency, this assumes the input is valid utf-16.
 */ function str2rstr_utf8(input) {
    var output = "";
    var i = -1;
    var x, y;
    while(++i < input.length){
        /* Decode utf-16 surrogate pairs */ x = input.charCodeAt(i);
        y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
        if (0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF) {
            x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
            i++;
        }
        /* Encode output as utf-8 */ if (x <= 0x7F) output += String.fromCharCode(x);
        else if (x <= 0x7FF) output += String.fromCharCode(0xC0 | x >>> 6 & 0x1F, 0x80 | x & 0x3F);
        else if (x <= 0xFFFF) output += String.fromCharCode(0xE0 | x >>> 12 & 0x0F, 0x80 | x >>> 6 & 0x3F, 0x80 | x & 0x3F);
        else if (x <= 0x1FFFFF) output += String.fromCharCode(0xF0 | x >>> 18 & 0x07, 0x80 | x >>> 12 & 0x3F, 0x80 | x >>> 6 & 0x3F, 0x80 | x & 0x3F);
    }
    return output;
}
/*
 * Encode a string as utf-16
 */ function str2rstr_utf16le(input) {
    var output = "";
    for(var i = 0; i < input.length; i++)output += String.fromCharCode(input.charCodeAt(i) & 0xFF, input.charCodeAt(i) >>> 8 & 0xFF);
    return output;
}
function str2rstr_utf16be(input) {
    var output = "";
    for(var i = 0; i < input.length; i++)output += String.fromCharCode(input.charCodeAt(i) >>> 8 & 0xFF, input.charCodeAt(i) & 0xFF);
    return output;
}
/*
 * Convert a raw string to an array of big-endian words
 * Characters >255 have their high-byte silently ignored.
 */ function rstr2binb(input) {
    var output = Array(input.length >> 2);
    for(var i = 0; i < output.length; i++)output[i] = 0;
    for(var i = 0; i < input.length * 8; i += 8)output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << 24 - i % 32;
    return output;
}
/*
 * Convert an array of big-endian words to a string
 */ function binb2rstr(input) {
    var output = "";
    for(var i = 0; i < input.length * 32; i += 8)output += String.fromCharCode(input[i >> 5] >>> 24 - i % 32 & 0xFF);
    return output;
}
/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */ function binb_sha1(x, len) {
    /* append padding */ x[len >> 5] |= 0x80 << 24 - len % 32;
    x[(len + 64 >> 9 << 4) + 15] = len;
    var w = Array(80);
    var a = 1732584193;
    var b = -271733879;
    var c = -1732584194;
    var d = 271733878;
    var e = -1009589776;
    for(var i = 0; i < x.length; i += 16){
        var olda = a;
        var oldb = b;
        var oldc = c;
        var oldd = d;
        var olde = e;
        for(var j = 0; j < 80; j++){
            if (j < 16) w[j] = x[i + j];
            else w[j] = bit_rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
            var t = safe_add(safe_add(bit_rol(a, 5), sha1_ft(j, b, c, d)), safe_add(safe_add(e, w[j]), sha1_kt(j)));
            e = d;
            d = c;
            c = bit_rol(b, 30);
            b = a;
            a = t;
        }
        a = safe_add(a, olda);
        b = safe_add(b, oldb);
        c = safe_add(c, oldc);
        d = safe_add(d, oldd);
        e = safe_add(e, olde);
    }
    return Array(a, b, c, d, e);
}
/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */ function sha1_ft(t, b, c, d) {
    if (t < 20) return b & c | ~b & d;
    if (t < 40) return b ^ c ^ d;
    if (t < 60) return b & c | b & d | c & d;
    return b ^ c ^ d;
}
/*
 * Determine the appropriate additive constant for the current iteration
 */ function sha1_kt(t) {
    return t < 20 ? 1518500249 : t < 40 ? 1859775393 : t < 60 ? -1894007588 : -899497514;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */ function safe_add(x, y) {
    var lsw = (x & 0xFFFF) + (y & 0xFFFF);
    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return msw << 16 | lsw & 0xFFFF;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */ function bit_rol(num, cnt) {
    return num << cnt | num >>> 32 - cnt;
}
exports.HMACSHA1 = function(key, data) {
    return b64_hmac_sha1(key, data);
};


/***/ }),

/***/ 30816:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

var crypto = __webpack_require__(6113);
/**
 * Exported function
 *
 * Options:
 *
 *  - `algorithm` hash algo to be used by this instance: *'sha1', 'md5'
 *  - `excludeValues` {true|*false} hash object keys, values ignored
 *  - `encoding` hash encoding, supports 'buffer', '*hex', 'binary', 'base64'
 *  - `ignoreUnknown` {true|*false} ignore unknown object types
 *  - `replacer` optional function that replaces values before hashing
 *  - `respectFunctionProperties` {*true|false} consider function properties when hashing
 *  - `respectFunctionNames` {*true|false} consider 'name' property of functions for hashing
 *  - `respectType` {*true|false} Respect special properties (prototype, constructor)
 *    when hashing to distinguish between types
 *  - `unorderedArrays` {true|*false} Sort all arrays before hashing
 *  - `unorderedSets` {*true|false} Sort `Set` and `Map` instances before hashing
 *  * = default
 *
 * @param {object} object value to hash
 * @param {object} options hashing options
 * @return {string} hash value
 * @api public
 */ exports = module.exports = objectHash;
function objectHash(object, options) {
    options = applyDefaults(object, options);
    return hash(object, options);
}
/**
 * Exported sugar methods
 *
 * @param {object} object value to hash
 * @return {string} hash value
 * @api public
 */ exports.sha1 = function(object) {
    return objectHash(object);
};
exports.keys = function(object) {
    return objectHash(object, {
        excludeValues: true,
        algorithm: "sha1",
        encoding: "hex"
    });
};
exports.MD5 = function(object) {
    return objectHash(object, {
        algorithm: "md5",
        encoding: "hex"
    });
};
exports.keysMD5 = function(object) {
    return objectHash(object, {
        algorithm: "md5",
        encoding: "hex",
        excludeValues: true
    });
};
// Internals
var hashes = crypto.getHashes ? crypto.getHashes().slice() : [
    "sha1",
    "md5"
];
hashes.push("passthrough");
var encodings = [
    "buffer",
    "hex",
    "binary",
    "base64"
];
function applyDefaults(object, sourceOptions) {
    sourceOptions = sourceOptions || {};
    // create a copy rather than mutating
    var options = {};
    options.algorithm = sourceOptions.algorithm || "sha1";
    options.encoding = sourceOptions.encoding || "hex";
    options.excludeValues = sourceOptions.excludeValues ? true : false;
    options.algorithm = options.algorithm.toLowerCase();
    options.encoding = options.encoding.toLowerCase();
    options.ignoreUnknown = sourceOptions.ignoreUnknown !== true ? false : true; // default to false
    options.respectType = sourceOptions.respectType === false ? false : true; // default to true
    options.respectFunctionNames = sourceOptions.respectFunctionNames === false ? false : true;
    options.respectFunctionProperties = sourceOptions.respectFunctionProperties === false ? false : true;
    options.unorderedArrays = sourceOptions.unorderedArrays !== true ? false : true; // default to false
    options.unorderedSets = sourceOptions.unorderedSets === false ? false : true; // default to false
    options.unorderedObjects = sourceOptions.unorderedObjects === false ? false : true; // default to true
    options.replacer = sourceOptions.replacer || undefined;
    options.excludeKeys = sourceOptions.excludeKeys || undefined;
    if (typeof object === "undefined") {
        throw new Error("Object argument required.");
    }
    // if there is a case-insensitive match in the hashes list, accept it
    // (i.e. SHA256 for sha256)
    for(var i = 0; i < hashes.length; ++i){
        if (hashes[i].toLowerCase() === options.algorithm.toLowerCase()) {
            options.algorithm = hashes[i];
        }
    }
    if (hashes.indexOf(options.algorithm) === -1) {
        throw new Error('Algorithm "' + options.algorithm + '"  not supported. ' + "supported values: " + hashes.join(", "));
    }
    if (encodings.indexOf(options.encoding) === -1 && options.algorithm !== "passthrough") {
        throw new Error('Encoding "' + options.encoding + '"  not supported. ' + "supported values: " + encodings.join(", "));
    }
    return options;
}
/** Check if the given function is a native function */ function isNativeFunction(f) {
    if (typeof f !== "function") {
        return false;
    }
    var exp = /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i;
    return exp.exec(Function.prototype.toString.call(f)) != null;
}
function hash(object, options) {
    var hashingStream;
    if (options.algorithm !== "passthrough") {
        hashingStream = crypto.createHash(options.algorithm);
    } else {
        hashingStream = new PassThrough();
    }
    if (typeof hashingStream.write === "undefined") {
        hashingStream.write = hashingStream.update;
        hashingStream.end = hashingStream.update;
    }
    var hasher = typeHasher(options, hashingStream);
    hasher.dispatch(object);
    if (!hashingStream.update) {
        hashingStream.end("");
    }
    if (hashingStream.digest) {
        return hashingStream.digest(options.encoding === "buffer" ? undefined : options.encoding);
    }
    var buf = hashingStream.read();
    if (options.encoding === "buffer") {
        return buf;
    }
    return buf.toString(options.encoding);
}
/**
 * Expose streaming API
 *
 * @param {object} object  Value to serialize
 * @param {object} options  Options, as for hash()
 * @param {object} stream  A stream to write the serializiation to
 * @api public
 */ exports.writeToStream = function(object, options, stream) {
    if (typeof stream === "undefined") {
        stream = options;
        options = {};
    }
    options = applyDefaults(object, options);
    return typeHasher(options, stream).dispatch(object);
};
function typeHasher(options, writeTo, context) {
    context = context || [];
    var write = function(str) {
        if (writeTo.update) {
            return writeTo.update(str, "utf8");
        } else {
            return writeTo.write(str, "utf8");
        }
    };
    return {
        dispatch: function(value) {
            if (options.replacer) {
                value = options.replacer(value);
            }
            var type = typeof value;
            if (value === null) {
                type = "null";
            }
            //console.log("[DEBUG] Dispatch: ", value, "->", type, " -> ", "_" + type);
            return this["_" + type](value);
        },
        _object: function(object) {
            var pattern = /\[object (.*)\]/i;
            var objString = Object.prototype.toString.call(object);
            var objType = pattern.exec(objString);
            if (!objType) {
                objType = "unknown:[" + objString + "]";
            } else {
                objType = objType[1]; // take only the class name
            }
            objType = objType.toLowerCase();
            var objectNumber = null;
            if ((objectNumber = context.indexOf(object)) >= 0) {
                return this.dispatch("[CIRCULAR:" + objectNumber + "]");
            } else {
                context.push(object);
            }
            if (typeof Buffer !== "undefined" && Buffer.isBuffer && Buffer.isBuffer(object)) {
                write("buffer:");
                return write(object);
            }
            if (objType !== "object" && objType !== "function" && objType !== "asyncfunction") {
                if (this["_" + objType]) {
                    this["_" + objType](object);
                } else if (options.ignoreUnknown) {
                    return write("[" + objType + "]");
                } else {
                    throw new Error('Unknown object type "' + objType + '"');
                }
            } else {
                var keys = Object.keys(object);
                if (options.unorderedObjects) {
                    keys = keys.sort();
                }
                // Make sure to incorporate special properties, so
                // Types with different prototypes will produce
                // a different hash and objects derived from
                // different functions (`new Foo`, `new Bar`) will
                // produce different hashes.
                // We never do this for native functions since some
                // seem to break because of that.
                if (options.respectType !== false && !isNativeFunction(object)) {
                    keys.splice(0, 0, "prototype", "__proto__", "constructor");
                }
                if (options.excludeKeys) {
                    keys = keys.filter(function(key) {
                        return !options.excludeKeys(key);
                    });
                }
                write("object:" + keys.length + ":");
                var self = this;
                return keys.forEach(function(key) {
                    self.dispatch(key);
                    write(":");
                    if (!options.excludeValues) {
                        self.dispatch(object[key]);
                    }
                    write(",");
                });
            }
        },
        _array: function(arr, unordered) {
            unordered = typeof unordered !== "undefined" ? unordered : options.unorderedArrays !== false; // default to options.unorderedArrays
            var self = this;
            write("array:" + arr.length + ":");
            if (!unordered || arr.length <= 1) {
                return arr.forEach(function(entry) {
                    return self.dispatch(entry);
                });
            }
            // the unordered case is a little more complicated:
            // since there is no canonical ordering on objects,
            // i.e. {a:1} < {a:2} and {a:1} > {a:2} are both false,
            // we first serialize each entry using a PassThrough stream
            // before sorting.
            // also: we can’t use the same context array for all entries
            // since the order of hashing should *not* matter. instead,
            // we keep track of the additions to a copy of the context array
            // and add all of them to the global context array when we’re done
            var contextAdditions = [];
            var entries = arr.map(function(entry) {
                var strm = new PassThrough();
                var localContext = context.slice(); // make copy
                var hasher = typeHasher(options, strm, localContext);
                hasher.dispatch(entry);
                // take only what was added to localContext and append it to contextAdditions
                contextAdditions = contextAdditions.concat(localContext.slice(context.length));
                return strm.read().toString();
            });
            context = context.concat(contextAdditions);
            entries.sort();
            return this._array(entries, false);
        },
        _date: function(date) {
            return write("date:" + date.toJSON());
        },
        _symbol: function(sym) {
            return write("symbol:" + sym.toString());
        },
        _error: function(err) {
            return write("error:" + err.toString());
        },
        _boolean: function(bool) {
            return write("bool:" + bool.toString());
        },
        _string: function(string) {
            write("string:" + string.length + ":");
            write(string.toString());
        },
        _function: function(fn) {
            write("fn:");
            if (isNativeFunction(fn)) {
                this.dispatch("[native]");
            } else {
                this.dispatch(fn.toString());
            }
            if (options.respectFunctionNames !== false) {
                // Make sure we can still distinguish native functions
                // by their name, otherwise String and Function will
                // have the same hash
                this.dispatch("function-name:" + String(fn.name));
            }
            if (options.respectFunctionProperties) {
                this._object(fn);
            }
        },
        _number: function(number) {
            return write("number:" + number.toString());
        },
        _xml: function(xml) {
            return write("xml:" + xml.toString());
        },
        _null: function() {
            return write("Null");
        },
        _undefined: function() {
            return write("Undefined");
        },
        _regexp: function(regex) {
            return write("regex:" + regex.toString());
        },
        _uint8array: function(arr) {
            write("uint8array:");
            return this.dispatch(Array.prototype.slice.call(arr));
        },
        _uint8clampedarray: function(arr) {
            write("uint8clampedarray:");
            return this.dispatch(Array.prototype.slice.call(arr));
        },
        _int8array: function(arr) {
            write("uint8array:");
            return this.dispatch(Array.prototype.slice.call(arr));
        },
        _uint16array: function(arr) {
            write("uint16array:");
            return this.dispatch(Array.prototype.slice.call(arr));
        },
        _int16array: function(arr) {
            write("uint16array:");
            return this.dispatch(Array.prototype.slice.call(arr));
        },
        _uint32array: function(arr) {
            write("uint32array:");
            return this.dispatch(Array.prototype.slice.call(arr));
        },
        _int32array: function(arr) {
            write("uint32array:");
            return this.dispatch(Array.prototype.slice.call(arr));
        },
        _float32array: function(arr) {
            write("float32array:");
            return this.dispatch(Array.prototype.slice.call(arr));
        },
        _float64array: function(arr) {
            write("float64array:");
            return this.dispatch(Array.prototype.slice.call(arr));
        },
        _arraybuffer: function(arr) {
            write("arraybuffer:");
            return this.dispatch(new Uint8Array(arr));
        },
        _url: function(url) {
            return write("url:" + url.toString(), "utf8");
        },
        _map: function(map) {
            write("map:");
            var arr = Array.from(map);
            return this._array(arr, options.unorderedSets !== false);
        },
        _set: function(set) {
            write("set:");
            var arr = Array.from(set);
            return this._array(arr, options.unorderedSets !== false);
        },
        _file: function(file) {
            write("file:");
            return this.dispatch([
                file.name,
                file.size,
                file.type,
                file.lastModfied
            ]);
        },
        _blob: function() {
            if (options.ignoreUnknown) {
                return write("[blob]");
            }
            throw Error("Hashing Blob objects is currently not supported\n" + "(see https://github.com/puleos/object-hash/issues/26)\n" + 'Use "options.replacer" or "options.ignoreUnknown"\n');
        },
        _domwindow: function() {
            return write("domwindow");
        },
        _bigint: function(number) {
            return write("bigint:" + number.toString());
        },
        /* Node.js standard native objects */ _process: function() {
            return write("process");
        },
        _timer: function() {
            return write("timer");
        },
        _pipe: function() {
            return write("pipe");
        },
        _tcp: function() {
            return write("tcp");
        },
        _udp: function() {
            return write("udp");
        },
        _tty: function() {
            return write("tty");
        },
        _statwatcher: function() {
            return write("statwatcher");
        },
        _securecontext: function() {
            return write("securecontext");
        },
        _connection: function() {
            return write("connection");
        },
        _zlib: function() {
            return write("zlib");
        },
        _context: function() {
            return write("context");
        },
        _nodescript: function() {
            return write("nodescript");
        },
        _httpparser: function() {
            return write("httpparser");
        },
        _dataview: function() {
            return write("dataview");
        },
        _signal: function() {
            return write("signal");
        },
        _fsevent: function() {
            return write("fsevent");
        },
        _tlswrap: function() {
            return write("tlswrap");
        }
    };
}
// Mini-implementation of stream.PassThrough
// We are far from having need for the full implementation, and we can
// make assumptions like "many writes, then only one final read"
// and we can ignore encoding specifics
function PassThrough() {
    return {
        buf: "",
        write: function(b) {
            this.buf += b;
        },
        end: function(b) {
            this.buf += b;
        },
        read: function() {
            return this.buf;
        }
    };
}


/***/ }),

/***/ 95356:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const { strict: assert  } = __webpack_require__(39491);
const { createHash  } = __webpack_require__(6113);
const { format  } = __webpack_require__(73837);
const shake256 = __webpack_require__(67900);
let encode;
if (Buffer.isEncoding("base64url")) {
    encode = (input)=>input.toString("base64url");
} else {
    const fromBase64 = (base64)=>base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    encode = (input)=>fromBase64(input.toString("base64"));
}
/** SPECIFICATION
 * Its (_hash) value is the base64url encoding of the left-most half of the hash of the octets of
 * the ASCII representation of the token value, where the hash algorithm used is the hash algorithm
 * used in the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is
 * RS256, hash the token value with SHA-256, then take the left-most 128 bits and base64url encode
 * them. The _hash value is a case sensitive string.
 */ /**
 * @name getHash
 * @api private
 *
 * returns the sha length based off the JOSE alg heade value, defaults to sha256
 *
 * @param token {String} token value to generate the hash from
 * @param alg {String} ID Token JOSE header alg value (i.e. RS256, HS384, ES512, PS256)
 * @param [crv] {String} For EdDSA the curve decides what hash algorithm is used. Required for EdDSA
 */ function getHash(alg, crv) {
    switch(alg){
        case "HS256":
        case "RS256":
        case "PS256":
        case "ES256":
        case "ES256K":
            return createHash("sha256");
        case "HS384":
        case "RS384":
        case "PS384":
        case "ES384":
            return createHash("sha384");
        case "HS512":
        case "RS512":
        case "PS512":
        case "ES512":
            return createHash("sha512");
        case "EdDSA":
            switch(crv){
                case "Ed25519":
                    return createHash("sha512");
                case "Ed448":
                    if (!shake256) {
                        throw new TypeError("Ed448 *_hash calculation is not supported in your Node.js runtime version");
                    }
                    return createHash("shake256", {
                        outputLength: 114
                    });
                default:
                    throw new TypeError("unrecognized or invalid EdDSA curve provided");
            }
        default:
            throw new TypeError("unrecognized or invalid JWS algorithm provided");
    }
}
function generate(token, alg, crv) {
    const digest = getHash(alg, crv).update(token).digest();
    return encode(digest.slice(0, digest.length / 2));
}
function validate(names, actual, source, alg, crv) {
    if (typeof names.claim !== "string" || !names.claim) {
        throw new TypeError("names.claim must be a non-empty string");
    }
    if (typeof names.source !== "string" || !names.source) {
        throw new TypeError("names.source must be a non-empty string");
    }
    assert(typeof actual === "string" && actual, `${names.claim} must be a non-empty string`);
    assert(typeof source === "string" && source, `${names.source} must be a non-empty string`);
    let expected;
    let msg;
    try {
        expected = generate(source, alg, crv);
    } catch (err) {
        msg = format("%s could not be validated (%s)", names.claim, err.message);
    }
    msg = msg || format("%s mismatch, expected %s, got: %s", names.claim, expected, actual);
    assert.equal(expected, actual, msg);
}
module.exports = {
    validate,
    generate
};


/***/ }),

/***/ 67900:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const crypto = __webpack_require__(6113);
const [major, minor] = process.version.substr(1).split(".").map((x)=>parseInt(x, 10));
const xofOutputLength = major > 12 || major === 12 && minor >= 8;
const shake256 = xofOutputLength && crypto.getHashes().includes("shake256");
module.exports = shake256;


/***/ }),

/***/ 20785:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const { inspect  } = __webpack_require__(73837);
const stdhttp = __webpack_require__(13685);
const crypto = __webpack_require__(6113);
const { strict: assert  } = __webpack_require__(39491);
const querystring = __webpack_require__(63477);
const url = __webpack_require__(57310);
const jose = __webpack_require__(89723);
const tokenHash = __webpack_require__(95356);
const isKeyObject = __webpack_require__(84482);
const decodeJWT = __webpack_require__(33289);
const base64url = __webpack_require__(58);
const defaults = __webpack_require__(66942);
const parseWwwAuthenticate = __webpack_require__(51091);
const { assertSigningAlgValuesSupport , assertIssuerConfiguration  } = __webpack_require__(10772);
const pick = __webpack_require__(75469);
const isPlainObject = __webpack_require__(93968);
const processResponse = __webpack_require__(21074);
const TokenSet = __webpack_require__(70023);
const { OPError , RPError  } = __webpack_require__(29567);
const now = __webpack_require__(42839);
const { random  } = __webpack_require__(45936);
const request = __webpack_require__(77260);
const { CLOCK_TOLERANCE  } = __webpack_require__(23575);
const { keystores  } = __webpack_require__(94489);
const KeyStore = __webpack_require__(40270);
const clone = __webpack_require__(56777);
const { authenticatedPost , resolveResponseType , resolveRedirectUri  } = __webpack_require__(72257);
const { queryKeyStore  } = __webpack_require__(64306);
const DeviceFlowHandle = __webpack_require__(33163);
const [major, minor] = process.version.slice(1).split(".").map((str)=>parseInt(str, 10));
const rsaPssParams = major >= 17 || major === 16 && minor >= 9;
const retryAttempt = Symbol();
const skipNonceCheck = Symbol();
const skipMaxAgeCheck = Symbol();
function pickCb(input) {
    return pick(input, "access_token", "code", "error_description", "error_uri", "error", "expires_in", "id_token", "iss", "response", "session_state", "state", "token_type");
}
function authorizationHeaderValue(token, tokenType = "Bearer") {
    return `${tokenType} ${token}`;
}
function verifyPresence(payload, jwt, prop) {
    if (payload[prop] === undefined) {
        throw new RPError({
            message: `missing required JWT property ${prop}`,
            jwt
        });
    }
}
function authorizationParams(params) {
    const authParams = {
        client_id: this.client_id,
        scope: "openid",
        response_type: resolveResponseType.call(this),
        redirect_uri: resolveRedirectUri.call(this),
        ...params
    };
    Object.entries(authParams).forEach(([key, value])=>{
        if (value === null || value === undefined) {
            delete authParams[key];
        } else if (key === "claims" && typeof value === "object") {
            authParams[key] = JSON.stringify(value);
        } else if (key === "resource" && Array.isArray(value)) {
            authParams[key] = value;
        } else if (typeof value !== "string") {
            authParams[key] = String(value);
        }
    });
    return authParams;
}
function getKeystore(jwks) {
    if (!isPlainObject(jwks) || !Array.isArray(jwks.keys) || jwks.keys.some((k)=>!isPlainObject(k) || !("kty" in k))) {
        throw new TypeError("jwks must be a JSON Web Key Set formatted object");
    }
    return KeyStore.fromJWKS(jwks, {
        onlyPrivate: true
    });
}
// if an OP doesnt support client_secret_basic but supports client_secret_post, use it instead
// this is in place to take care of most common pitfalls when first using discovered Issuers without
// the support for default values defined by Discovery 1.0
function checkBasicSupport(client, properties) {
    try {
        const supported = client.issuer.token_endpoint_auth_methods_supported;
        if (!supported.includes(properties.token_endpoint_auth_method)) {
            if (supported.includes("client_secret_post")) {
                properties.token_endpoint_auth_method = "client_secret_post";
            }
        }
    } catch (err) {}
}
function handleCommonMistakes(client, metadata, properties) {
    if (!metadata.token_endpoint_auth_method) {
        // if no explicit value was provided
        checkBasicSupport(client, properties);
    }
    // :fp: c'mon people... RTFM
    if (metadata.redirect_uri) {
        if (metadata.redirect_uris) {
            throw new TypeError("provide a redirect_uri or redirect_uris, not both");
        }
        properties.redirect_uris = [
            metadata.redirect_uri
        ];
        delete properties.redirect_uri;
    }
    if (metadata.response_type) {
        if (metadata.response_types) {
            throw new TypeError("provide a response_type or response_types, not both");
        }
        properties.response_types = [
            metadata.response_type
        ];
        delete properties.response_type;
    }
}
function getDefaultsForEndpoint(endpoint, issuer, properties) {
    if (!issuer[`${endpoint}_endpoint`]) return;
    const tokenEndpointAuthMethod = properties.token_endpoint_auth_method;
    const tokenEndpointAuthSigningAlg = properties.token_endpoint_auth_signing_alg;
    const eam = `${endpoint}_endpoint_auth_method`;
    const easa = `${endpoint}_endpoint_auth_signing_alg`;
    if (properties[eam] === undefined && properties[easa] === undefined) {
        if (tokenEndpointAuthMethod !== undefined) {
            properties[eam] = tokenEndpointAuthMethod;
        }
        if (tokenEndpointAuthSigningAlg !== undefined) {
            properties[easa] = tokenEndpointAuthSigningAlg;
        }
    }
}
class BaseClient {
    #metadata;
    #issuer;
    #aadIssValidation;
    #additionalAuthorizedParties;
    constructor(issuer, aadIssValidation, metadata = {}, jwks, options){
        this.#metadata = new Map();
        this.#issuer = issuer;
        this.#aadIssValidation = aadIssValidation;
        if (typeof metadata.client_id !== "string" || !metadata.client_id) {
            throw new TypeError("client_id is required");
        }
        const properties = {
            grant_types: [
                "authorization_code"
            ],
            id_token_signed_response_alg: "RS256",
            authorization_signed_response_alg: "RS256",
            response_types: [
                "code"
            ],
            token_endpoint_auth_method: "client_secret_basic",
            ...this.fapi() ? {
                grant_types: [
                    "authorization_code",
                    "implicit"
                ],
                id_token_signed_response_alg: "PS256",
                authorization_signed_response_alg: "PS256",
                response_types: [
                    "code id_token"
                ],
                tls_client_certificate_bound_access_tokens: true,
                token_endpoint_auth_method: undefined
            } : undefined,
            ...metadata
        };
        if (this.fapi()) {
            switch(properties.token_endpoint_auth_method){
                case "self_signed_tls_client_auth":
                case "tls_client_auth":
                    break;
                case "private_key_jwt":
                    if (!jwks) {
                        throw new TypeError("jwks is required");
                    }
                    break;
                case undefined:
                    throw new TypeError("token_endpoint_auth_method is required");
                default:
                    throw new TypeError("invalid or unsupported token_endpoint_auth_method");
            }
        }
        handleCommonMistakes(this, metadata, properties);
        assertSigningAlgValuesSupport("token", this.issuer, properties);
        [
            "introspection",
            "revocation"
        ].forEach((endpoint)=>{
            getDefaultsForEndpoint(endpoint, this.issuer, properties);
            assertSigningAlgValuesSupport(endpoint, this.issuer, properties);
        });
        Object.entries(properties).forEach(([key, value])=>{
            this.#metadata.set(key, value);
            if (!this[key]) {
                Object.defineProperty(this, key, {
                    get () {
                        return this.#metadata.get(key);
                    },
                    enumerable: true
                });
            }
        });
        if (jwks !== undefined) {
            const keystore = getKeystore.call(this, jwks);
            keystores.set(this, keystore);
        }
        if (options != null && options.additionalAuthorizedParties) {
            this.#additionalAuthorizedParties = clone(options.additionalAuthorizedParties);
        }
        this[CLOCK_TOLERANCE] = 0;
    }
    authorizationUrl(params = {}) {
        if (!isPlainObject(params)) {
            throw new TypeError("params must be a plain object");
        }
        assertIssuerConfiguration(this.issuer, "authorization_endpoint");
        const target = url.parse(this.issuer.authorization_endpoint, true);
        target.search = null;
        target.query = {
            ...target.query,
            ...authorizationParams.call(this, params)
        };
        return url.format(target);
    }
    authorizationPost(params = {}) {
        if (!isPlainObject(params)) {
            throw new TypeError("params must be a plain object");
        }
        const inputs = authorizationParams.call(this, params);
        const formInputs = Object.keys(inputs).map((name)=>`<input type="hidden" name="${name}" value="${inputs[name]}"/>`).join("\n");
        return `<!DOCTYPE html>
<head>
<title>Requesting Authorization</title>
</head>
<body onload="javascript:document.forms[0].submit()">
<form method="post" action="${this.issuer.authorization_endpoint}">
  ${formInputs}
</form>
</body>
</html>`;
    }
    endSessionUrl(params = {}) {
        assertIssuerConfiguration(this.issuer, "end_session_endpoint");
        const { 0: postLogout , length  } = this.post_logout_redirect_uris || [];
        const { post_logout_redirect_uri =length === 1 ? postLogout : undefined  } = params;
        let id_token_hint;
        ({ id_token_hint , ...params } = params);
        if (id_token_hint instanceof TokenSet) {
            if (!id_token_hint.id_token) {
                throw new TypeError("id_token not present in TokenSet");
            }
            id_token_hint = id_token_hint.id_token;
        }
        const target = url.parse(this.issuer.end_session_endpoint, true);
        target.search = null;
        defaults(target.query, params, {
            post_logout_redirect_uri,
            client_id: this.client_id
        }, {
            id_token_hint
        });
        Object.entries(target.query).forEach(([key, value])=>{
            if (value === null || value === undefined) {
                delete target.query[key];
            }
        });
        return url.format(target);
    }
    callbackParams(input) {
        const isIncomingMessage = input instanceof stdhttp.IncomingMessage || input && input.method && input.url;
        const isString = typeof input === "string";
        if (!isString && !isIncomingMessage) {
            throw new TypeError("#callbackParams only accepts string urls, http.IncomingMessage or a lookalike");
        }
        if (isIncomingMessage) {
            switch(input.method){
                case "GET":
                    return pickCb(url.parse(input.url, true).query);
                case "POST":
                    if (input.body === undefined) {
                        throw new TypeError("incoming message body missing, include a body parser prior to this method call");
                    }
                    switch(typeof input.body){
                        case "object":
                        case "string":
                            if (Buffer.isBuffer(input.body)) {
                                return pickCb(querystring.parse(input.body.toString("utf-8")));
                            }
                            if (typeof input.body === "string") {
                                return pickCb(querystring.parse(input.body));
                            }
                            return pickCb(input.body);
                        default:
                            throw new TypeError("invalid IncomingMessage body object");
                    }
                default:
                    throw new TypeError("invalid IncomingMessage method");
            }
        } else {
            return pickCb(url.parse(input, true).query);
        }
    }
    async callback(redirectUri, parameters, checks = {}, { exchangeBody , clientAssertionPayload , DPoP  } = {}) {
        let params = pickCb(parameters);
        if (checks.jarm && !("response" in parameters)) {
            throw new RPError({
                message: "expected a JARM response",
                checks,
                params
            });
        } else if ("response" in parameters) {
            const decrypted = await this.decryptJARM(params.response);
            params = await this.validateJARM(decrypted);
        }
        if (this.default_max_age && !checks.max_age) {
            checks.max_age = this.default_max_age;
        }
        if (params.state && !checks.state) {
            throw new TypeError("checks.state argument is missing");
        }
        if (!params.state && checks.state) {
            throw new RPError({
                message: "state missing from the response",
                checks,
                params
            });
        }
        if (checks.state !== params.state) {
            throw new RPError({
                printf: [
                    "state mismatch, expected %s, got: %s",
                    checks.state,
                    params.state
                ],
                checks,
                params
            });
        }
        if ("iss" in params) {
            assertIssuerConfiguration(this.issuer, "issuer");
            if (params.iss !== this.issuer.issuer) {
                throw new RPError({
                    printf: [
                        "iss mismatch, expected %s, got: %s",
                        this.issuer.issuer,
                        params.iss
                    ],
                    params
                });
            }
        } else if (this.issuer.authorization_response_iss_parameter_supported && !("id_token" in params) && !("response" in parameters)) {
            throw new RPError({
                message: "iss missing from the response",
                params
            });
        }
        if (params.error) {
            throw new OPError(params);
        }
        const RESPONSE_TYPE_REQUIRED_PARAMS = {
            code: [
                "code"
            ],
            id_token: [
                "id_token"
            ],
            token: [
                "access_token",
                "token_type"
            ]
        };
        if (checks.response_type) {
            for (const type of checks.response_type.split(" ")){
                if (type === "none") {
                    if (params.code || params.id_token || params.access_token) {
                        throw new RPError({
                            message: 'unexpected params encountered for "none" response',
                            checks,
                            params
                        });
                    }
                } else {
                    for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[type]){
                        if (!params[param]) {
                            throw new RPError({
                                message: `${param} missing from response`,
                                checks,
                                params
                            });
                        }
                    }
                }
            }
        }
        if (params.id_token) {
            const tokenset = new TokenSet(params);
            await this.decryptIdToken(tokenset);
            await this.validateIdToken(tokenset, checks.nonce, "authorization", checks.max_age, checks.state);
            if (!params.code) {
                return tokenset;
            }
        }
        if (params.code) {
            const tokenset1 = await this.grant({
                ...exchangeBody,
                grant_type: "authorization_code",
                code: params.code,
                redirect_uri: redirectUri,
                code_verifier: checks.code_verifier
            }, {
                clientAssertionPayload,
                DPoP
            });
            await this.decryptIdToken(tokenset1);
            await this.validateIdToken(tokenset1, checks.nonce, "token", checks.max_age);
            if (params.session_state) {
                tokenset1.session_state = params.session_state;
            }
            return tokenset1;
        }
        return new TokenSet(params);
    }
    async oauthCallback(redirectUri, parameters, checks = {}, { exchangeBody , clientAssertionPayload , DPoP  } = {}) {
        let params = pickCb(parameters);
        if (checks.jarm && !("response" in parameters)) {
            throw new RPError({
                message: "expected a JARM response",
                checks,
                params
            });
        } else if ("response" in parameters) {
            const decrypted = await this.decryptJARM(params.response);
            params = await this.validateJARM(decrypted);
        }
        if (params.state && !checks.state) {
            throw new TypeError("checks.state argument is missing");
        }
        if (!params.state && checks.state) {
            throw new RPError({
                message: "state missing from the response",
                checks,
                params
            });
        }
        if (checks.state !== params.state) {
            throw new RPError({
                printf: [
                    "state mismatch, expected %s, got: %s",
                    checks.state,
                    params.state
                ],
                checks,
                params
            });
        }
        if ("iss" in params) {
            assertIssuerConfiguration(this.issuer, "issuer");
            if (params.iss !== this.issuer.issuer) {
                throw new RPError({
                    printf: [
                        "iss mismatch, expected %s, got: %s",
                        this.issuer.issuer,
                        params.iss
                    ],
                    params
                });
            }
        } else if (this.issuer.authorization_response_iss_parameter_supported && !("id_token" in params) && !("response" in parameters)) {
            throw new RPError({
                message: "iss missing from the response",
                params
            });
        }
        if (params.error) {
            throw new OPError(params);
        }
        if (typeof params.id_token === "string" && params.id_token.length) {
            throw new RPError({
                message: "id_token detected in the response, you must use client.callback() instead of client.oauthCallback()",
                params
            });
        }
        delete params.id_token;
        const RESPONSE_TYPE_REQUIRED_PARAMS = {
            code: [
                "code"
            ],
            token: [
                "access_token",
                "token_type"
            ]
        };
        if (checks.response_type) {
            for (const type of checks.response_type.split(" ")){
                if (type === "none") {
                    if (params.code || params.id_token || params.access_token) {
                        throw new RPError({
                            message: 'unexpected params encountered for "none" response',
                            checks,
                            params
                        });
                    }
                }
                if (RESPONSE_TYPE_REQUIRED_PARAMS[type]) {
                    for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[type]){
                        if (!params[param]) {
                            throw new RPError({
                                message: `${param} missing from response`,
                                checks,
                                params
                            });
                        }
                    }
                }
            }
        }
        if (params.code) {
            const tokenset = await this.grant({
                ...exchangeBody,
                grant_type: "authorization_code",
                code: params.code,
                redirect_uri: redirectUri,
                code_verifier: checks.code_verifier
            }, {
                clientAssertionPayload,
                DPoP
            });
            if (typeof tokenset.id_token === "string" && tokenset.id_token.length) {
                throw new RPError({
                    message: "id_token detected in the response, you must use client.callback() instead of client.oauthCallback()",
                    params
                });
            }
            delete tokenset.id_token;
            return tokenset;
        }
        return new TokenSet(params);
    }
    async decryptIdToken(token) {
        if (!this.id_token_encrypted_response_alg) {
            return token;
        }
        let idToken = token;
        if (idToken instanceof TokenSet) {
            if (!idToken.id_token) {
                throw new TypeError("id_token not present in TokenSet");
            }
            idToken = idToken.id_token;
        }
        const expectedAlg = this.id_token_encrypted_response_alg;
        const expectedEnc = this.id_token_encrypted_response_enc;
        const result = await this.decryptJWE(idToken, expectedAlg, expectedEnc);
        if (token instanceof TokenSet) {
            token.id_token = result;
            return token;
        }
        return result;
    }
    async validateJWTUserinfo(body) {
        const expectedAlg = this.userinfo_signed_response_alg;
        return this.validateJWT(body, expectedAlg, []);
    }
    async decryptJARM(response) {
        if (!this.authorization_encrypted_response_alg) {
            return response;
        }
        const expectedAlg = this.authorization_encrypted_response_alg;
        const expectedEnc = this.authorization_encrypted_response_enc;
        return this.decryptJWE(response, expectedAlg, expectedEnc);
    }
    async decryptJWTUserinfo(body) {
        if (!this.userinfo_encrypted_response_alg) {
            return body;
        }
        const expectedAlg = this.userinfo_encrypted_response_alg;
        const expectedEnc = this.userinfo_encrypted_response_enc;
        return this.decryptJWE(body, expectedAlg, expectedEnc);
    }
    async decryptJWE(jwe, expectedAlg, expectedEnc = "A128CBC-HS256") {
        const header = JSON.parse(base64url.decode(jwe.split(".")[0]));
        if (header.alg !== expectedAlg) {
            throw new RPError({
                printf: [
                    "unexpected JWE alg received, expected %s, got: %s",
                    expectedAlg,
                    header.alg
                ],
                jwt: jwe
            });
        }
        if (header.enc !== expectedEnc) {
            throw new RPError({
                printf: [
                    "unexpected JWE enc received, expected %s, got: %s",
                    expectedEnc,
                    header.enc
                ],
                jwt: jwe
            });
        }
        const getPlaintext = (result)=>new TextDecoder().decode(result.plaintext);
        let plaintext;
        if (expectedAlg.match(/^(?:RSA|ECDH)/)) {
            const keystore = await keystores.get(this);
            for (const { keyObject: key  } of keystore.all({
                ...jose.decodeProtectedHeader(jwe),
                use: "enc"
            })){
                plaintext = await jose.compactDecrypt(jwe, key).then(getPlaintext, ()=>{});
                if (plaintext) break;
            }
        } else {
            plaintext = await jose.compactDecrypt(jwe, this.secretForAlg(expectedAlg === "dir" ? expectedEnc : expectedAlg)).then(getPlaintext, ()=>{});
        }
        if (!plaintext) {
            throw new RPError({
                message: "failed to decrypt JWE",
                jwt: jwe
            });
        }
        return plaintext;
    }
    async validateIdToken(tokenSet, nonce, returnedBy, maxAge, state) {
        let idToken = tokenSet;
        const expectedAlg = this.id_token_signed_response_alg;
        const isTokenSet = idToken instanceof TokenSet;
        if (isTokenSet) {
            if (!idToken.id_token) {
                throw new TypeError("id_token not present in TokenSet");
            }
            idToken = idToken.id_token;
        }
        idToken = String(idToken);
        const timestamp = now();
        const { protected: header , payload , key  } = await this.validateJWT(idToken, expectedAlg);
        if (typeof maxAge === "number" || maxAge !== skipMaxAgeCheck && this.require_auth_time) {
            if (!payload.auth_time) {
                throw new RPError({
                    message: "missing required JWT property auth_time",
                    jwt: idToken
                });
            }
            if (typeof payload.auth_time !== "number") {
                throw new RPError({
                    message: "JWT auth_time claim must be a JSON numeric value",
                    jwt: idToken
                });
            }
        }
        if (typeof maxAge === "number" && payload.auth_time + maxAge < timestamp - this[CLOCK_TOLERANCE]) {
            throw new RPError({
                printf: [
                    "too much time has elapsed since the last End-User authentication, max_age %i, auth_time: %i, now %i",
                    maxAge,
                    payload.auth_time,
                    timestamp - this[CLOCK_TOLERANCE]
                ],
                now: timestamp,
                tolerance: this[CLOCK_TOLERANCE],
                auth_time: payload.auth_time,
                jwt: idToken
            });
        }
        if (nonce !== skipNonceCheck && (payload.nonce || nonce !== undefined) && payload.nonce !== nonce) {
            throw new RPError({
                printf: [
                    "nonce mismatch, expected %s, got: %s",
                    nonce,
                    payload.nonce
                ],
                jwt: idToken
            });
        }
        if (returnedBy === "authorization") {
            if (!payload.at_hash && tokenSet.access_token) {
                throw new RPError({
                    message: "missing required property at_hash",
                    jwt: idToken
                });
            }
            if (!payload.c_hash && tokenSet.code) {
                throw new RPError({
                    message: "missing required property c_hash",
                    jwt: idToken
                });
            }
            if (this.fapi()) {
                if (!payload.s_hash && (tokenSet.state || state)) {
                    throw new RPError({
                        message: "missing required property s_hash",
                        jwt: idToken
                    });
                }
            }
            if (payload.s_hash) {
                if (!state) {
                    throw new TypeError('cannot verify s_hash, "checks.state" property not provided');
                }
                try {
                    tokenHash.validate({
                        claim: "s_hash",
                        source: "state"
                    }, payload.s_hash, state, header.alg, key.jwk && key.jwk.crv);
                } catch (err) {
                    throw new RPError({
                        message: err.message,
                        jwt: idToken
                    });
                }
            }
        }
        if (this.fapi() && payload.iat < timestamp - 3600) {
            throw new RPError({
                printf: [
                    "JWT issued too far in the past, now %i, iat %i",
                    timestamp,
                    payload.iat
                ],
                now: timestamp,
                tolerance: this[CLOCK_TOLERANCE],
                iat: payload.iat,
                jwt: idToken
            });
        }
        if (tokenSet.access_token && payload.at_hash !== undefined) {
            try {
                tokenHash.validate({
                    claim: "at_hash",
                    source: "access_token"
                }, payload.at_hash, tokenSet.access_token, header.alg, key.jwk && key.jwk.crv);
            } catch (err1) {
                throw new RPError({
                    message: err1.message,
                    jwt: idToken
                });
            }
        }
        if (tokenSet.code && payload.c_hash !== undefined) {
            try {
                tokenHash.validate({
                    claim: "c_hash",
                    source: "code"
                }, payload.c_hash, tokenSet.code, header.alg, key.jwk && key.jwk.crv);
            } catch (err2) {
                throw new RPError({
                    message: err2.message,
                    jwt: idToken
                });
            }
        }
        return tokenSet;
    }
    async validateJWT(jwt, expectedAlg, required = [
        "iss",
        "sub",
        "aud",
        "exp",
        "iat"
    ]) {
        const isSelfIssued = this.issuer.issuer === "https://self-issued.me";
        const timestamp = now();
        let header;
        let payload;
        try {
            ({ header , payload  } = decodeJWT(jwt, {
                complete: true
            }));
        } catch (err) {
            throw new RPError({
                printf: [
                    "failed to decode JWT (%s: %s)",
                    err.name,
                    err.message
                ],
                jwt
            });
        }
        if (header.alg !== expectedAlg) {
            throw new RPError({
                printf: [
                    "unexpected JWT alg received, expected %s, got: %s",
                    expectedAlg,
                    header.alg
                ],
                jwt
            });
        }
        if (isSelfIssued) {
            required = [
                ...required,
                "sub_jwk"
            ];
        }
        required.forEach(verifyPresence.bind(undefined, payload, jwt));
        if (payload.iss !== undefined) {
            let expectedIss = this.issuer.issuer;
            if (this.#aadIssValidation) {
                expectedIss = this.issuer.issuer.replace("{tenantid}", payload.tid);
            }
            if (payload.iss !== expectedIss) {
                throw new RPError({
                    printf: [
                        "unexpected iss value, expected %s, got: %s",
                        expectedIss,
                        payload.iss
                    ],
                    jwt
                });
            }
        }
        if (payload.iat !== undefined) {
            if (typeof payload.iat !== "number") {
                throw new RPError({
                    message: "JWT iat claim must be a JSON numeric value",
                    jwt
                });
            }
        }
        if (payload.nbf !== undefined) {
            if (typeof payload.nbf !== "number") {
                throw new RPError({
                    message: "JWT nbf claim must be a JSON numeric value",
                    jwt
                });
            }
            if (payload.nbf > timestamp + this[CLOCK_TOLERANCE]) {
                throw new RPError({
                    printf: [
                        "JWT not active yet, now %i, nbf %i",
                        timestamp + this[CLOCK_TOLERANCE],
                        payload.nbf
                    ],
                    now: timestamp,
                    tolerance: this[CLOCK_TOLERANCE],
                    nbf: payload.nbf,
                    jwt
                });
            }
        }
        if (payload.exp !== undefined) {
            if (typeof payload.exp !== "number") {
                throw new RPError({
                    message: "JWT exp claim must be a JSON numeric value",
                    jwt
                });
            }
            if (timestamp - this[CLOCK_TOLERANCE] >= payload.exp) {
                throw new RPError({
                    printf: [
                        "JWT expired, now %i, exp %i",
                        timestamp - this[CLOCK_TOLERANCE],
                        payload.exp
                    ],
                    now: timestamp,
                    tolerance: this[CLOCK_TOLERANCE],
                    exp: payload.exp,
                    jwt
                });
            }
        }
        if (payload.aud !== undefined) {
            if (Array.isArray(payload.aud)) {
                if (payload.aud.length > 1 && !payload.azp) {
                    throw new RPError({
                        message: "missing required JWT property azp",
                        jwt
                    });
                }
                if (!payload.aud.includes(this.client_id)) {
                    throw new RPError({
                        printf: [
                            "aud is missing the client_id, expected %s to be included in %j",
                            this.client_id,
                            payload.aud
                        ],
                        jwt
                    });
                }
            } else if (payload.aud !== this.client_id) {
                throw new RPError({
                    printf: [
                        "aud mismatch, expected %s, got: %s",
                        this.client_id,
                        payload.aud
                    ],
                    jwt
                });
            }
        }
        if (payload.azp !== undefined) {
            let additionalAuthorizedParties = this.#additionalAuthorizedParties;
            if (typeof additionalAuthorizedParties === "string") {
                additionalAuthorizedParties = [
                    this.client_id,
                    additionalAuthorizedParties
                ];
            } else if (Array.isArray(additionalAuthorizedParties)) {
                additionalAuthorizedParties = [
                    this.client_id,
                    ...additionalAuthorizedParties
                ];
            } else {
                additionalAuthorizedParties = [
                    this.client_id
                ];
            }
            if (!additionalAuthorizedParties.includes(payload.azp)) {
                throw new RPError({
                    printf: [
                        "azp mismatch, got: %s",
                        payload.azp
                    ],
                    jwt
                });
            }
        }
        let keys;
        if (isSelfIssued) {
            try {
                assert(isPlainObject(payload.sub_jwk));
                const key = await jose.importJWK(payload.sub_jwk, header.alg);
                assert.equal(key.type, "public");
                keys = [
                    {
                        keyObject: key
                    }
                ];
            } catch (err1) {
                throw new RPError({
                    message: "failed to use sub_jwk claim as an asymmetric JSON Web Key",
                    jwt
                });
            }
            if (await jose.calculateJwkThumbprint(payload.sub_jwk) !== payload.sub) {
                throw new RPError({
                    message: "failed to match the subject with sub_jwk",
                    jwt
                });
            }
        } else if (header.alg.startsWith("HS")) {
            keys = [
                this.secretForAlg(header.alg)
            ];
        } else if (header.alg !== "none") {
            keys = await queryKeyStore.call(this.issuer, {
                ...header,
                use: "sig"
            });
        }
        if (!keys && header.alg === "none") {
            return {
                protected: header,
                payload
            };
        }
        for (const key1 of keys){
            const verified = await jose.compactVerify(jwt, key1 instanceof Uint8Array ? key1 : key1.keyObject).catch(()=>{});
            if (verified) {
                return {
                    payload,
                    protected: verified.protectedHeader,
                    key: key1
                };
            }
        }
        throw new RPError({
            message: "failed to validate JWT signature",
            jwt
        });
    }
    async refresh(refreshToken, { exchangeBody , clientAssertionPayload , DPoP  } = {}) {
        let token = refreshToken;
        if (token instanceof TokenSet) {
            if (!token.refresh_token) {
                throw new TypeError("refresh_token not present in TokenSet");
            }
            token = token.refresh_token;
        }
        const tokenset = await this.grant({
            ...exchangeBody,
            grant_type: "refresh_token",
            refresh_token: String(token)
        }, {
            clientAssertionPayload,
            DPoP
        });
        if (tokenset.id_token) {
            await this.decryptIdToken(tokenset);
            await this.validateIdToken(tokenset, skipNonceCheck, "token", skipMaxAgeCheck);
            if (refreshToken instanceof TokenSet && refreshToken.id_token) {
                const expectedSub = refreshToken.claims().sub;
                const actualSub = tokenset.claims().sub;
                if (actualSub !== expectedSub) {
                    throw new RPError({
                        printf: [
                            "sub mismatch, expected %s, got: %s",
                            expectedSub,
                            actualSub
                        ],
                        jwt: tokenset.id_token
                    });
                }
            }
        }
        return tokenset;
    }
    async requestResource(resourceUrl, accessToken, { method , headers , body , DPoP , tokenType =DPoP ? "DPoP" : accessToken instanceof TokenSet ? accessToken.token_type : "Bearer"  } = {}, retry) {
        if (accessToken instanceof TokenSet) {
            if (!accessToken.access_token) {
                throw new TypeError("access_token not present in TokenSet");
            }
            accessToken = accessToken.access_token;
        }
        if (!accessToken) {
            throw new TypeError("no access token provided");
        } else if (typeof accessToken !== "string") {
            throw new TypeError("invalid access token provided");
        }
        const requestOpts = {
            headers: {
                Authorization: authorizationHeaderValue(accessToken, tokenType),
                ...headers
            },
            body
        };
        const mTLS = !!this.tls_client_certificate_bound_access_tokens;
        const response = await request.call(this, {
            ...requestOpts,
            responseType: "buffer",
            method,
            url: resourceUrl
        }, {
            accessToken,
            mTLS,
            DPoP
        });
        const wwwAuthenticate = response.headers["www-authenticate"];
        if (retry !== retryAttempt && wwwAuthenticate && wwwAuthenticate.toLowerCase().startsWith("dpop ") && parseWwwAuthenticate(wwwAuthenticate).error === "use_dpop_nonce") {
            return this.requestResource(resourceUrl, accessToken, {
                method,
                headers,
                body,
                DPoP,
                tokenType
            });
        }
        return response;
    }
    async userinfo(accessToken, { method ="GET" , via ="header" , tokenType , params , DPoP  } = {}) {
        assertIssuerConfiguration(this.issuer, "userinfo_endpoint");
        const options = {
            tokenType,
            method: String(method).toUpperCase(),
            DPoP
        };
        if (options.method !== "GET" && options.method !== "POST") {
            throw new TypeError("#userinfo() method can only be POST or a GET");
        }
        if (via === "body" && options.method !== "POST") {
            throw new TypeError("can only send body on POST");
        }
        const jwt = !!(this.userinfo_signed_response_alg || this.userinfo_encrypted_response_alg);
        if (jwt) {
            options.headers = {
                Accept: "application/jwt"
            };
        } else {
            options.headers = {
                Accept: "application/json"
            };
        }
        const mTLS = !!this.tls_client_certificate_bound_access_tokens;
        let targetUrl;
        if (mTLS && this.issuer.mtls_endpoint_aliases) {
            targetUrl = this.issuer.mtls_endpoint_aliases.userinfo_endpoint;
        }
        targetUrl = new url.URL(targetUrl || this.issuer.userinfo_endpoint);
        if (via === "body") {
            options.headers.Authorization = undefined;
            options.headers["Content-Type"] = "application/x-www-form-urlencoded";
            options.body = new url.URLSearchParams();
            options.body.append("access_token", accessToken instanceof TokenSet ? accessToken.access_token : accessToken);
        }
        // handle additional parameters, GET via querystring, POST via urlencoded body
        if (params) {
            if (options.method === "GET") {
                Object.entries(params).forEach(([key, value])=>{
                    targetUrl.searchParams.append(key, value);
                });
            } else if (options.body) {
                // POST && via body
                Object.entries(params).forEach(([key, value])=>{
                    options.body.append(key, value);
                });
            } else {
                // POST && via header
                options.body = new url.URLSearchParams();
                options.headers["Content-Type"] = "application/x-www-form-urlencoded";
                Object.entries(params).forEach(([key, value])=>{
                    options.body.append(key, value);
                });
            }
        }
        if (options.body) {
            options.body = options.body.toString();
        }
        const response = await this.requestResource(targetUrl, accessToken, options);
        let parsed = processResponse(response, {
            bearer: true
        });
        if (jwt) {
            if (!/^application\/jwt/.test(response.headers["content-type"])) {
                throw new RPError({
                    message: "expected application/jwt response from the userinfo_endpoint",
                    response
                });
            }
            const body = response.body.toString();
            const userinfo = await this.decryptJWTUserinfo(body);
            if (!this.userinfo_signed_response_alg) {
                try {
                    parsed = JSON.parse(userinfo);
                    assert(isPlainObject(parsed));
                } catch (err) {
                    throw new RPError({
                        message: "failed to parse userinfo JWE payload as JSON",
                        jwt: userinfo
                    });
                }
            } else {
                ({ payload: parsed  } = await this.validateJWTUserinfo(userinfo));
            }
        } else {
            try {
                parsed = JSON.parse(response.body);
            } catch (err1) {
                Object.defineProperty(err1, "response", {
                    value: response
                });
                throw err1;
            }
        }
        if (accessToken instanceof TokenSet && accessToken.id_token) {
            const expectedSub = accessToken.claims().sub;
            if (parsed.sub !== expectedSub) {
                throw new RPError({
                    printf: [
                        "userinfo sub mismatch, expected %s, got: %s",
                        expectedSub,
                        parsed.sub
                    ],
                    body: parsed,
                    jwt: accessToken.id_token
                });
            }
        }
        return parsed;
    }
    encryptionSecret(len) {
        const hash = len <= 256 ? "sha256" : len <= 384 ? "sha384" : len <= 512 ? "sha512" : false;
        if (!hash) {
            throw new Error("unsupported symmetric encryption key derivation");
        }
        return crypto.createHash(hash).update(this.client_secret).digest().slice(0, len / 8);
    }
    secretForAlg(alg) {
        if (!this.client_secret) {
            throw new TypeError("client_secret is required");
        }
        if (/^A(\d{3})(?:GCM)?KW$/.test(alg)) {
            return this.encryptionSecret(parseInt(RegExp.$1, 10));
        }
        if (/^A(\d{3})(?:GCM|CBC-HS(\d{3}))$/.test(alg)) {
            return this.encryptionSecret(parseInt(RegExp.$2 || RegExp.$1, 10));
        }
        return new TextEncoder().encode(this.client_secret);
    }
    async grant(body, { clientAssertionPayload , DPoP  } = {}, retry) {
        assertIssuerConfiguration(this.issuer, "token_endpoint");
        const response = await authenticatedPost.call(this, "token", {
            form: body,
            responseType: "json"
        }, {
            clientAssertionPayload,
            DPoP
        });
        let responseBody;
        try {
            responseBody = processResponse(response);
        } catch (err) {
            if (retry !== retryAttempt && err instanceof OPError && err.error === "use_dpop_nonce") {
                return this.grant(body, {
                    clientAssertionPayload,
                    DPoP
                }, retryAttempt);
            }
            throw err;
        }
        return new TokenSet(responseBody);
    }
    async deviceAuthorization(params = {}, { exchangeBody , clientAssertionPayload , DPoP  } = {}) {
        assertIssuerConfiguration(this.issuer, "device_authorization_endpoint");
        assertIssuerConfiguration(this.issuer, "token_endpoint");
        const body = authorizationParams.call(this, {
            client_id: this.client_id,
            redirect_uri: null,
            response_type: null,
            ...params
        });
        const response = await authenticatedPost.call(this, "device_authorization", {
            responseType: "json",
            form: body
        }, {
            clientAssertionPayload,
            endpointAuthMethod: "token"
        });
        const responseBody = processResponse(response);
        return new DeviceFlowHandle({
            client: this,
            exchangeBody,
            clientAssertionPayload,
            response: responseBody,
            maxAge: params.max_age,
            DPoP
        });
    }
    async revoke(token, hint, { revokeBody , clientAssertionPayload  } = {}) {
        assertIssuerConfiguration(this.issuer, "revocation_endpoint");
        if (hint !== undefined && typeof hint !== "string") {
            throw new TypeError("hint must be a string");
        }
        const form = {
            ...revokeBody,
            token
        };
        if (hint) {
            form.token_type_hint = hint;
        }
        const response = await authenticatedPost.call(this, "revocation", {
            form
        }, {
            clientAssertionPayload
        });
        processResponse(response, {
            body: false
        });
    }
    async introspect(token, hint, { introspectBody , clientAssertionPayload  } = {}) {
        assertIssuerConfiguration(this.issuer, "introspection_endpoint");
        if (hint !== undefined && typeof hint !== "string") {
            throw new TypeError("hint must be a string");
        }
        const form = {
            ...introspectBody,
            token
        };
        if (hint) {
            form.token_type_hint = hint;
        }
        const response = await authenticatedPost.call(this, "introspection", {
            form,
            responseType: "json"
        }, {
            clientAssertionPayload
        });
        const responseBody = processResponse(response);
        return responseBody;
    }
    static async register(metadata, options = {}) {
        const { initialAccessToken , jwks , ...clientOptions } = options;
        assertIssuerConfiguration(this.issuer, "registration_endpoint");
        if (jwks !== undefined && !(metadata.jwks || metadata.jwks_uri)) {
            const keystore = await getKeystore.call(this, jwks);
            metadata.jwks = keystore.toJWKS();
        }
        const response = await request.call(this, {
            headers: {
                Accept: "application/json",
                ...initialAccessToken ? {
                    Authorization: authorizationHeaderValue(initialAccessToken)
                } : undefined
            },
            responseType: "json",
            json: metadata,
            url: this.issuer.registration_endpoint,
            method: "POST"
        });
        const responseBody = processResponse(response, {
            statusCode: 201,
            bearer: true
        });
        return new this(responseBody, jwks, clientOptions);
    }
    get metadata() {
        return clone(Object.fromEntries(this.#metadata.entries()));
    }
    static async fromUri(registrationClientUri, registrationAccessToken, jwks, clientOptions) {
        const response = await request.call(this, {
            method: "GET",
            url: registrationClientUri,
            responseType: "json",
            headers: {
                Authorization: authorizationHeaderValue(registrationAccessToken),
                Accept: "application/json"
            }
        });
        const responseBody = processResponse(response, {
            bearer: true
        });
        return new this(responseBody, jwks, clientOptions);
    }
    async requestObject(requestObject = {}, { sign: signingAlgorithm = this.request_object_signing_alg || "none" , encrypt: { alg: eKeyManagement = this.request_object_encryption_alg , enc: eContentEncryption = this.request_object_encryption_enc || "A128CBC-HS256"  } = {}  } = {}) {
        if (!isPlainObject(requestObject)) {
            throw new TypeError("requestObject must be a plain object");
        }
        let signed;
        let key;
        const unix = now();
        const header = {
            alg: signingAlgorithm,
            typ: "oauth-authz-req+jwt"
        };
        const payload = JSON.stringify(defaults({}, requestObject, {
            iss: this.client_id,
            aud: this.issuer.issuer,
            client_id: this.client_id,
            jti: random(),
            iat: unix,
            exp: unix + 300,
            ...this.fapi() ? {
                nbf: unix
            } : undefined
        }));
        if (signingAlgorithm === "none") {
            signed = [
                base64url.encode(JSON.stringify(header)),
                base64url.encode(payload),
                ""
            ].join(".");
        } else {
            const symmetric = signingAlgorithm.startsWith("HS");
            if (symmetric) {
                key = this.secretForAlg(signingAlgorithm);
            } else {
                const keystore = await keystores.get(this);
                if (!keystore) {
                    throw new TypeError(`no keystore present for client, cannot sign using alg ${signingAlgorithm}`);
                }
                key = keystore.get({
                    alg: signingAlgorithm,
                    use: "sig"
                });
                if (!key) {
                    throw new TypeError(`no key to sign with found for alg ${signingAlgorithm}`);
                }
            }
            signed = await new jose.CompactSign(new TextEncoder().encode(payload)).setProtectedHeader({
                ...header,
                kid: symmetric ? undefined : key.jwk.kid
            }).sign(symmetric ? key : key.keyObject);
        }
        if (!eKeyManagement) {
            return signed;
        }
        const fields = {
            alg: eKeyManagement,
            enc: eContentEncryption,
            cty: "oauth-authz-req+jwt"
        };
        if (fields.alg.match(/^(RSA|ECDH)/)) {
            [key] = await queryKeyStore.call(this.issuer, {
                alg: fields.alg,
                use: "enc"
            }, {
                allowMulti: true
            });
        } else {
            key = this.secretForAlg(fields.alg === "dir" ? fields.enc : fields.alg);
        }
        return new jose.CompactEncrypt(new TextEncoder().encode(signed)).setProtectedHeader({
            ...fields,
            kid: key instanceof Uint8Array ? undefined : key.jwk.kid
        }).encrypt(key instanceof Uint8Array ? key : key.keyObject);
    }
    async pushedAuthorizationRequest(params = {}, { clientAssertionPayload  } = {}) {
        assertIssuerConfiguration(this.issuer, "pushed_authorization_request_endpoint");
        const body = {
            ..."request" in params ? params : authorizationParams.call(this, params),
            client_id: this.client_id
        };
        const response = await authenticatedPost.call(this, "pushed_authorization_request", {
            responseType: "json",
            form: body
        }, {
            clientAssertionPayload,
            endpointAuthMethod: "token"
        });
        const responseBody = processResponse(response, {
            statusCode: 201
        });
        if (!("expires_in" in responseBody)) {
            throw new RPError({
                message: "expected expires_in in Pushed Authorization Successful Response",
                response
            });
        }
        if (typeof responseBody.expires_in !== "number") {
            throw new RPError({
                message: "invalid expires_in value in Pushed Authorization Successful Response",
                response
            });
        }
        if (!("request_uri" in responseBody)) {
            throw new RPError({
                message: "expected request_uri in Pushed Authorization Successful Response",
                response
            });
        }
        if (typeof responseBody.request_uri !== "string") {
            throw new RPError({
                message: "invalid request_uri value in Pushed Authorization Successful Response",
                response
            });
        }
        return responseBody;
    }
    get issuer() {
        return this.#issuer;
    }
    /* istanbul ignore next */ [inspect.custom]() {
        return `${this.constructor.name} ${inspect(this.metadata, {
            depth: Infinity,
            colors: process.stdout.isTTY,
            compact: false,
            sorted: true
        })}`;
    }
    fapi() {
        return this.constructor.name === "FAPI1Client";
    }
    async validateJARM(response) {
        const expectedAlg = this.authorization_signed_response_alg;
        const { payload  } = await this.validateJWT(response, expectedAlg, [
            "iss",
            "exp",
            "aud"
        ]);
        return pickCb(payload);
    }
}
const RSPS = /^(?:RS|PS)(?:256|384|512)$/;
function determineRsaAlgorithm(privateKey, privateKeyInput, valuesSupported) {
    if (typeof privateKeyInput === "object" && typeof privateKeyInput.key === "object" && privateKeyInput.key.alg) {
        return privateKeyInput.key.alg;
    }
    if (Array.isArray(valuesSupported)) {
        let candidates = valuesSupported.filter(RegExp.prototype.test.bind(RSPS));
        if (privateKey.asymmetricKeyType === "rsa-pss") {
            candidates = candidates.filter((value)=>value.startsWith("PS"));
        }
        return [
            "PS256",
            "PS384",
            "PS512",
            "RS256",
            "RS384",
            "RS384"
        ].find((preferred)=>candidates.includes(preferred));
    }
    return "PS256";
}
const p256 = Buffer.from([
    42,
    134,
    72,
    206,
    61,
    3,
    1,
    7
]);
const p384 = Buffer.from([
    43,
    129,
    4,
    0,
    34
]);
const p521 = Buffer.from([
    43,
    129,
    4,
    0,
    35
]);
const secp256k1 = Buffer.from([
    43,
    129,
    4,
    0,
    10
]);
function determineEcAlgorithm(privateKey, privateKeyInput) {
    // If input was a JWK
    switch(typeof privateKeyInput === "object" && typeof privateKeyInput.key === "object" && privateKeyInput.key.crv){
        case "P-256":
            return "ES256";
        case "secp256k1":
            return "ES256K";
        case "P-384":
            return "ES384";
        case "P-512":
            return "ES512";
        default:
            break;
    }
    const buf = privateKey.export({
        format: "der",
        type: "pkcs8"
    });
    const i = buf[1] < 128 ? 17 : 18;
    const len = buf[i];
    const curveOid = buf.slice(i + 1, i + 1 + len);
    if (curveOid.equals(p256)) {
        return "ES256";
    }
    if (curveOid.equals(p384)) {
        return "ES384";
    }
    if (curveOid.equals(p521)) {
        return "ES512";
    }
    if (curveOid.equals(secp256k1)) {
        return "ES256K";
    }
    throw new TypeError("unsupported DPoP private key curve");
}
const jwkCache = new WeakMap();
async function getJwk(privateKey, privateKeyInput) {
    if (typeof privateKeyInput === "object" && typeof privateKeyInput.key === "object" && privateKeyInput.key.crv) {
        return pick(privateKeyInput.key, "kty", "crv", "x", "y", "e", "n");
    }
    if (jwkCache.has(privateKeyInput)) {
        return jwkCache.get(privateKeyInput);
    }
    const jwk = pick(await jose.exportJWK(privateKey), "kty", "crv", "x", "y", "e", "n");
    if (isKeyObject(privateKeyInput)) {
        jwkCache.set(privateKeyInput, jwk);
    }
    return jwk;
}
/**
 * @name dpopProof
 * @api private
 */ async function dpopProof(payload, privateKeyInput, accessToken) {
    if (!isPlainObject(payload)) {
        throw new TypeError("payload must be a plain object");
    }
    let privateKey;
    if (isKeyObject(privateKeyInput)) {
        privateKey = privateKeyInput;
    } else {
        privateKey = crypto.createPrivateKey(privateKeyInput);
    }
    if (privateKey.type !== "private") {
        throw new TypeError('"DPoP" option must be a private key');
    }
    let alg;
    switch(privateKey.asymmetricKeyType){
        case "ed25519":
        case "ed448":
            alg = "EdDSA";
            break;
        case "ec":
            alg = determineEcAlgorithm(privateKey, privateKeyInput);
            break;
        case "rsa":
        case rsaPssParams && "rsa-pss":
            alg = determineRsaAlgorithm(privateKey, privateKeyInput, this.issuer.dpop_signing_alg_values_supported);
            break;
        default:
            throw new TypeError("unsupported DPoP private key asymmetric key type");
    }
    if (!alg) {
        throw new TypeError("could not determine DPoP JWS Algorithm");
    }
    return new jose.SignJWT({
        ath: accessToken ? base64url.encode(crypto.createHash("sha256").update(accessToken).digest()) : undefined,
        ...payload
    }).setProtectedHeader({
        alg,
        typ: "dpop+jwt",
        jwk: await getJwk(privateKey, privateKeyInput)
    }).setIssuedAt().setJti(random()).sign(privateKey);
}
Object.defineProperty(BaseClient.prototype, "dpopProof", {
    enumerable: true,
    configurable: true,
    value (...args) {
        process.emitWarning("The DPoP APIs implements an IETF draft (https://www.ietf.org/archive/id/draft-ietf-oauth-dpop-04.html). Breaking draft implementations are included as minor versions of the openid-client library, therefore, the ~ semver operator should be used and close attention be payed to library changelog as well as the drafts themselves.", "DraftWarning");
        Object.defineProperty(BaseClient.prototype, "dpopProof", {
            enumerable: true,
            configurable: true,
            value: dpopProof
        });
        return this.dpopProof(...args);
    }
});
module.exports = (issuer, aadIssValidation = false)=>class Client extends BaseClient {
        constructor(...args){
            super(issuer, aadIssValidation, ...args);
        }
        static get issuer() {
            return issuer;
        }
    };
module.exports.BaseClient = BaseClient;


/***/ }),

/***/ 33163:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const { inspect  } = __webpack_require__(73837);
const { RPError , OPError  } = __webpack_require__(29567);
const now = __webpack_require__(42839);
class DeviceFlowHandle {
    #aborted;
    #client;
    #clientAssertionPayload;
    #DPoP;
    #exchangeBody;
    #expires_at;
    #interval;
    #maxAge;
    #response;
    constructor({ client , exchangeBody , clientAssertionPayload , response , maxAge , DPoP  }){
        [
            "verification_uri",
            "user_code",
            "device_code"
        ].forEach((prop)=>{
            if (typeof response[prop] !== "string" || !response[prop]) {
                throw new RPError(`expected ${prop} string to be returned by Device Authorization Response, got %j`, response[prop]);
            }
        });
        if (!Number.isSafeInteger(response.expires_in)) {
            throw new RPError("expected expires_in number to be returned by Device Authorization Response, got %j", response.expires_in);
        }
        this.#expires_at = now() + response.expires_in;
        this.#client = client;
        this.#DPoP = DPoP;
        this.#maxAge = maxAge;
        this.#exchangeBody = exchangeBody;
        this.#clientAssertionPayload = clientAssertionPayload;
        this.#response = response;
        this.#interval = response.interval * 1000 || 5000;
    }
    abort() {
        this.#aborted = true;
    }
    async poll({ signal  } = {}) {
        if (signal && signal.aborted || this.#aborted) {
            throw new RPError("polling aborted");
        }
        if (this.expired()) {
            throw new RPError("the device code %j has expired and the device authorization session has concluded", this.device_code);
        }
        await new Promise((resolve)=>setTimeout(resolve, this.#interval));
        let tokenset;
        try {
            tokenset = await this.#client.grant({
                ...this.#exchangeBody,
                grant_type: "urn:ietf:params:oauth:grant-type:device_code",
                device_code: this.device_code
            }, {
                clientAssertionPayload: this.#clientAssertionPayload,
                DPoP: this.#DPoP
            });
        } catch (err) {
            switch(err instanceof OPError && err.error){
                case "slow_down":
                    this.#interval += 5000;
                case "authorization_pending":
                    return this.poll({
                        signal
                    });
                default:
                    throw err;
            }
        }
        if ("id_token" in tokenset) {
            await this.#client.decryptIdToken(tokenset);
            await this.#client.validateIdToken(tokenset, undefined, "token", this.#maxAge);
        }
        return tokenset;
    }
    get device_code() {
        return this.#response.device_code;
    }
    get user_code() {
        return this.#response.user_code;
    }
    get verification_uri() {
        return this.#response.verification_uri;
    }
    get verification_uri_complete() {
        return this.#response.verification_uri_complete;
    }
    get expires_in() {
        return Math.max.apply(null, [
            this.#expires_at - now(),
            0
        ]);
    }
    expired() {
        return this.expires_in === 0;
    }
    /* istanbul ignore next */ [inspect.custom]() {
        return `${this.constructor.name} ${inspect(this.#response, {
            depth: Infinity,
            colors: process.stdout.isTTY,
            compact: false,
            sorted: true
        })}`;
    }
}
module.exports = DeviceFlowHandle;


/***/ }),

/***/ 29567:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const { format  } = __webpack_require__(73837);
class OPError extends Error {
    constructor({ error_description , error , error_uri , session_state , state , scope  }, response){
        super(!error_description ? error : `${error} (${error_description})`);
        Object.assign(this, {
            error
        }, error_description && {
            error_description
        }, error_uri && {
            error_uri
        }, state && {
            state
        }, scope && {
            scope
        }, session_state && {
            session_state
        });
        if (response) {
            Object.defineProperty(this, "response", {
                value: response
            });
        }
        this.name = this.constructor.name;
        Error.captureStackTrace(this, this.constructor);
    }
}
class RPError extends Error {
    constructor(...args){
        if (typeof args[0] === "string") {
            super(format(...args));
        } else {
            const { message , printf , response , ...rest } = args[0];
            if (printf) {
                super(format(...printf));
            } else {
                super(message);
            }
            Object.assign(this, rest);
            if (response) {
                Object.defineProperty(this, "response", {
                    value: response
                });
            }
        }
        this.name = this.constructor.name;
        Error.captureStackTrace(this, this.constructor);
    }
}
module.exports = {
    OPError,
    RPError
};


/***/ }),

/***/ 10772:
/***/ ((module) => {

"use strict";

function assertSigningAlgValuesSupport(endpoint, issuer, properties) {
    if (!issuer[`${endpoint}_endpoint`]) return;
    const eam = `${endpoint}_endpoint_auth_method`;
    const easa = `${endpoint}_endpoint_auth_signing_alg`;
    const easavs = `${endpoint}_endpoint_auth_signing_alg_values_supported`;
    if (properties[eam] && properties[eam].endsWith("_jwt") && !properties[easa] && !issuer[easavs]) {
        throw new TypeError(`${easavs} must be configured on the issuer if ${easa} is not defined on a client`);
    }
}
function assertIssuerConfiguration(issuer, endpoint) {
    if (!issuer[endpoint]) {
        throw new TypeError(`${endpoint} must be configured on the issuer`);
    }
}
module.exports = {
    assertSigningAlgValuesSupport,
    assertIssuerConfiguration
};


/***/ }),

/***/ 58:
/***/ ((module) => {

"use strict";

let encode;
if (Buffer.isEncoding("base64url")) {
    encode = (input, encoding = "utf8")=>Buffer.from(input, encoding).toString("base64url");
} else {
    const fromBase64 = (base64)=>base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    encode = (input, encoding = "utf8")=>fromBase64(Buffer.from(input, encoding).toString("base64"));
}
const decode = (input)=>Buffer.from(input, "base64");
module.exports.decode = decode;
module.exports.encode = encode;


/***/ }),

/***/ 72257:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const jose = __webpack_require__(89723);
const { RPError  } = __webpack_require__(29567);
const { assertIssuerConfiguration  } = __webpack_require__(10772);
const { random  } = __webpack_require__(45936);
const now = __webpack_require__(42839);
const request = __webpack_require__(77260);
const { keystores  } = __webpack_require__(94489);
const merge = __webpack_require__(4016);
const formUrlEncode = (value)=>encodeURIComponent(value).replace(/%20/g, "+");
async function clientAssertion(endpoint, payload) {
    let alg = this[`${endpoint}_endpoint_auth_signing_alg`];
    if (!alg) {
        assertIssuerConfiguration(this.issuer, `${endpoint}_endpoint_auth_signing_alg_values_supported`);
    }
    if (this[`${endpoint}_endpoint_auth_method`] === "client_secret_jwt") {
        if (!alg) {
            const supported = this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`];
            alg = Array.isArray(supported) && supported.find((signAlg)=>/^HS(?:256|384|512)/.test(signAlg));
        }
        if (!alg) {
            throw new RPError(`failed to determine a JWS Algorithm to use for ${this[`${endpoint}_endpoint_auth_method`]} Client Assertion`);
        }
        return new jose.CompactSign(Buffer.from(JSON.stringify(payload))).setProtectedHeader({
            alg
        }).sign(this.secretForAlg(alg));
    }
    const keystore = await keystores.get(this);
    if (!keystore) {
        throw new TypeError("no client jwks provided for signing a client assertion with");
    }
    if (!alg) {
        const supported1 = this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`];
        alg = Array.isArray(supported1) && supported1.find((signAlg)=>keystore.get({
                alg: signAlg,
                use: "sig"
            }));
    }
    if (!alg) {
        throw new RPError(`failed to determine a JWS Algorithm to use for ${this[`${endpoint}_endpoint_auth_method`]} Client Assertion`);
    }
    const key = keystore.get({
        alg,
        use: "sig"
    });
    if (!key) {
        throw new RPError(`no key found in client jwks to sign a client assertion with using alg ${alg}`);
    }
    return new jose.CompactSign(Buffer.from(JSON.stringify(payload))).setProtectedHeader({
        alg,
        kid: key.jwk && key.jwk.kid
    }).sign(key.keyObject);
}
async function authFor(endpoint, { clientAssertionPayload  } = {}) {
    const authMethod = this[`${endpoint}_endpoint_auth_method`];
    switch(authMethod){
        case "self_signed_tls_client_auth":
        case "tls_client_auth":
        case "none":
            return {
                form: {
                    client_id: this.client_id
                }
            };
        case "client_secret_post":
            if (!this.client_secret) {
                throw new TypeError("client_secret_post client authentication method requires a client_secret");
            }
            return {
                form: {
                    client_id: this.client_id,
                    client_secret: this.client_secret
                }
            };
        case "private_key_jwt":
        case "client_secret_jwt":
            {
                const timestamp = now();
                const audience = [
                    ...new Set([
                        this.issuer.issuer,
                        this.issuer.token_endpoint
                    ].filter(Boolean))
                ];
                const assertion = await clientAssertion.call(this, endpoint, {
                    iat: timestamp,
                    exp: timestamp + 60,
                    jti: random(),
                    iss: this.client_id,
                    sub: this.client_id,
                    aud: audience,
                    ...clientAssertionPayload
                });
                return {
                    form: {
                        client_id: this.client_id,
                        client_assertion: assertion,
                        client_assertion_type: "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
                    }
                };
            }
        case "client_secret_basic":
            {
                // This is correct behaviour, see https://tools.ietf.org/html/rfc6749#section-2.3.1 and the
                // related appendix. (also https://github.com/panva/node-openid-client/pull/91)
                // > The client identifier is encoded using the
                // > "application/x-www-form-urlencoded" encoding algorithm per
                // > Appendix B, and the encoded value is used as the username; the client
                // > password is encoded using the same algorithm and used as the
                // > password.
                if (!this.client_secret) {
                    throw new TypeError("client_secret_basic client authentication method requires a client_secret");
                }
                const encoded = `${formUrlEncode(this.client_id)}:${formUrlEncode(this.client_secret)}`;
                const value = Buffer.from(encoded).toString("base64");
                return {
                    headers: {
                        Authorization: `Basic ${value}`
                    }
                };
            }
        default:
            {
                throw new TypeError(`missing, or unsupported, ${endpoint}_endpoint_auth_method`);
            }
    }
}
function resolveResponseType() {
    const { length , 0: value  } = this.response_types;
    if (length === 1) {
        return value;
    }
    return undefined;
}
function resolveRedirectUri() {
    const { length , 0: value  } = this.redirect_uris || [];
    if (length === 1) {
        return value;
    }
    return undefined;
}
async function authenticatedPost(endpoint, opts, { clientAssertionPayload , endpointAuthMethod =endpoint , DPoP  } = {}) {
    const auth = await authFor.call(this, endpointAuthMethod, {
        clientAssertionPayload
    });
    const requestOpts = merge(opts, auth);
    const mTLS = this[`${endpointAuthMethod}_endpoint_auth_method`].includes("tls_client_auth") || endpoint === "token" && this.tls_client_certificate_bound_access_tokens;
    let targetUrl;
    if (mTLS && this.issuer.mtls_endpoint_aliases) {
        targetUrl = this.issuer.mtls_endpoint_aliases[`${endpoint}_endpoint`];
    }
    targetUrl = targetUrl || this.issuer[`${endpoint}_endpoint`];
    if ("form" in requestOpts) {
        for (const [key, value] of Object.entries(requestOpts.form)){
            if (typeof value === "undefined") {
                delete requestOpts.form[key];
            }
        }
    }
    return request.call(this, {
        ...requestOpts,
        method: "POST",
        url: targetUrl,
        headers: {
            ...endpoint !== "revocation" ? {
                Accept: "application/json"
            } : undefined,
            ...requestOpts.headers
        }
    }, {
        mTLS,
        DPoP
    });
}
module.exports = {
    resolveResponseType,
    resolveRedirectUri,
    authFor,
    authenticatedPost
};


/***/ }),

/***/ 23575:
/***/ ((module) => {

"use strict";

const HTTP_OPTIONS = Symbol();
const CLOCK_TOLERANCE = Symbol();
module.exports = {
    CLOCK_TOLERANCE,
    HTTP_OPTIONS
};


/***/ }),

/***/ 33289:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const base64url = __webpack_require__(58);
module.exports = (token)=>{
    if (typeof token !== "string" || !token) {
        throw new TypeError("JWT must be a string");
    }
    const { 0: header , 1: payload , 2: signature , length  } = token.split(".");
    if (length === 5) {
        throw new TypeError("encrypted JWTs cannot be decoded");
    }
    if (length !== 3) {
        throw new Error("JWTs must have three components");
    }
    try {
        return {
            header: JSON.parse(base64url.decode(header)),
            payload: JSON.parse(base64url.decode(payload)),
            signature
        };
    } catch (err) {
        throw new Error("JWT is malformed");
    }
};


/***/ }),

/***/ 56777:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const { serialize , deserialize  } = __webpack_require__(84655);
module.exports = globalThis.structuredClone || ((obj)=>deserialize(serialize(obj)));


/***/ }),

/***/ 66942:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const isPlainObject = __webpack_require__(93968);
function defaults(deep, target, ...sources) {
    for (const source of sources){
        if (!isPlainObject(source)) {
            continue;
        }
        for (const [key, value] of Object.entries(source)){
            /* istanbul ignore if */ if (key === "__proto__" || key === "constructor") {
                continue;
            }
            if (typeof target[key] === "undefined" && typeof value !== "undefined") {
                target[key] = value;
            }
            if (deep && isPlainObject(target[key]) && isPlainObject(value)) {
                defaults(true, target[key], value);
            }
        }
    }
    return target;
}
module.exports = defaults.bind(undefined, false);
module.exports.deep = defaults.bind(undefined, true);


/***/ }),

/***/ 45936:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const { createHash , randomBytes  } = __webpack_require__(6113);
const base64url = __webpack_require__(58);
const random = (bytes = 32)=>base64url.encode(randomBytes(bytes));
module.exports = {
    random,
    state: random,
    nonce: random,
    codeVerifier: random,
    codeChallenge: (codeVerifier)=>base64url.encode(createHash("sha256").update(codeVerifier).digest())
};


/***/ }),

/***/ 84482:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const util = __webpack_require__(73837);
const crypto = __webpack_require__(6113);
module.exports = util.types.isKeyObject || ((obj)=>obj && obj instanceof crypto.KeyObject);


/***/ }),

/***/ 93968:
/***/ ((module) => {

"use strict";

module.exports = (a)=>!!a && a.constructor === Object;


/***/ }),

/***/ 64306:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const objectHash = __webpack_require__(30816);
const LRU = __webpack_require__(65462);
const { RPError  } = __webpack_require__(29567);
const { assertIssuerConfiguration  } = __webpack_require__(10772);
const KeyStore = __webpack_require__(40270);
const { keystores  } = __webpack_require__(94489);
const processResponse = __webpack_require__(21074);
const request = __webpack_require__(77260);
const inFlight = new WeakMap();
const caches = new WeakMap();
const lrus = (ctx)=>{
    if (!caches.has(ctx)) {
        caches.set(ctx, new LRU({
            max: 100
        }));
    }
    return caches.get(ctx);
};
async function getKeyStore(reload = false) {
    assertIssuerConfiguration(this, "jwks_uri");
    const keystore = keystores.get(this);
    const cache = lrus(this);
    if (reload || !keystore) {
        if (inFlight.has(this)) {
            return inFlight.get(this);
        }
        cache.reset();
        inFlight.set(this, (async ()=>{
            const response = await request.call(this, {
                method: "GET",
                responseType: "json",
                url: this.jwks_uri,
                headers: {
                    Accept: "application/json, application/jwk-set+json"
                }
            }).finally(()=>{
                inFlight.delete(this);
            });
            const jwks = processResponse(response);
            const joseKeyStore = KeyStore.fromJWKS(jwks, {
                onlyPublic: true
            });
            cache.set("throttle", true, 60 * 1000);
            keystores.set(this, joseKeyStore);
            return joseKeyStore;
        })());
        return inFlight.get(this);
    }
    return keystore;
}
async function queryKeyStore({ kid , kty , alg , use  }, { allowMulti =false  } = {}) {
    const cache = lrus(this);
    const def = {
        kid,
        kty,
        alg,
        use
    };
    const defHash = objectHash(def, {
        algorithm: "sha256",
        ignoreUnknown: true,
        unorderedArrays: true,
        unorderedSets: true
    });
    // refresh keystore on every unknown key but also only upto once every minute
    const freshJwksUri = cache.get(defHash) || cache.get("throttle");
    const keystore = await getKeyStore.call(this, !freshJwksUri);
    const keys = keystore.all(def);
    delete def.use;
    if (keys.length === 0) {
        throw new RPError({
            printf: [
                "no valid key found in issuer's jwks_uri for key parameters %j",
                def
            ],
            jwks: keystore
        });
    }
    if (!allowMulti && keys.length > 1 && !kid) {
        throw new RPError({
            printf: [
                "multiple matching keys found in issuer's jwks_uri for key parameters %j, kid must be provided in this case",
                def
            ],
            jwks: keystore
        });
    }
    cache.set(defHash, true);
    return keys;
}
module.exports.queryKeyStore = queryKeyStore;
module.exports.keystore = getKeyStore;


/***/ }),

/***/ 40270:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const v8 = __webpack_require__(84655);
const jose = __webpack_require__(89723);
const clone = globalThis.structuredClone || ((value)=>v8.deserialize(v8.serialize(value)));
const isPlainObject = __webpack_require__(93968);
const isKeyObject = __webpack_require__(84482);
const internal = Symbol();
function fauxAlg(kty) {
    switch(kty){
        case "RSA":
            return "RSA-OAEP";
        case "EC":
            return "ECDH-ES";
        case "OKP":
            return "ECDH-ES";
        case "oct":
            return "HS256";
        default:
            return undefined;
    }
}
const keyscore = (key, { alg , use  })=>{
    let score = 0;
    if (alg && key.alg) {
        score++;
    }
    if (use && key.use) {
        score++;
    }
    return score;
};
function getKtyFromAlg(alg) {
    switch(typeof alg === "string" && alg.slice(0, 2)){
        case "RS":
        case "PS":
            return "RSA";
        case "ES":
            return "EC";
        case "Ed":
            return "OKP";
        default:
            return undefined;
    }
}
function getAlgorithms(use, alg, kty, crv) {
    // Ed25519, Ed448, and secp256k1 always have "alg"
    // OKP always has use
    if (alg) {
        return new Set([
            alg
        ]);
    }
    switch(kty){
        case "EC":
            {
                let algs = [];
                if (use === "enc" || use === undefined) {
                    algs = algs.concat([
                        "ECDH-ES",
                        "ECDH-ES+A128KW",
                        "ECDH-ES+A192KW",
                        "ECDH-ES+A256KW"
                    ]);
                }
                if (use === "sig" || use === undefined) {
                    algs = algs.concat([
                        `ES${crv.slice(-3)}`.replace("21", "12")
                    ]);
                }
                return new Set(algs);
            }
        case "OKP":
            {
                return new Set([
                    "ECDH-ES",
                    "ECDH-ES+A128KW",
                    "ECDH-ES+A192KW",
                    "ECDH-ES+A256KW"
                ]);
            }
        case "RSA":
            {
                let algs1 = [];
                if (use === "enc" || use === undefined) {
                    algs1 = algs1.concat([
                        "RSA-OAEP",
                        "RSA-OAEP-256",
                        "RSA-OAEP-384",
                        "RSA-OAEP-512",
                        "RSA1_5"
                    ]);
                }
                if (use === "sig" || use === undefined) {
                    algs1 = algs1.concat([
                        "PS256",
                        "PS384",
                        "PS512",
                        "RS256",
                        "RS384",
                        "RS512"
                    ]);
                }
                return new Set(algs1);
            }
        default:
            throw new Error("unreachable");
    }
}
module.exports = class KeyStore {
    #keys;
    constructor(i, keys){
        if (i !== internal) throw new Error("invalid constructor call");
        this.#keys = keys;
    }
    toJWKS() {
        return {
            keys: this.map(({ jwk: { d , p , q , dp , dq , qi , ...jwk }  })=>jwk)
        };
    }
    all({ alg , kid , use  } = {}) {
        if (!use || !alg) {
            throw new Error();
        }
        const kty = getKtyFromAlg(alg);
        const search = {
            alg,
            use
        };
        return this.filter((key)=>{
            let candidate = true;
            if (candidate && kty !== undefined && key.jwk.kty !== kty) {
                candidate = false;
            }
            if (candidate && kid !== undefined && key.jwk.kid !== kid) {
                candidate = false;
            }
            if (candidate && use !== undefined && key.jwk.use !== undefined && key.jwk.use !== use) {
                candidate = false;
            }
            if (candidate && key.jwk.alg && key.jwk.alg !== alg) {
                candidate = false;
            } else if (!key.algorithms.has(alg)) {
                candidate = false;
            }
            return candidate;
        }).sort((first, second)=>keyscore(second, search) - keyscore(first, search));
    }
    get(...args) {
        return this.all(...args)[0];
    }
    static async fromJWKS(jwks, { onlyPublic =false , onlyPrivate =false  } = {}) {
        if (!isPlainObject(jwks) || !Array.isArray(jwks.keys) || jwks.keys.some((k)=>!isPlainObject(k) || !("kty" in k))) {
            throw new TypeError("jwks must be a JSON Web Key Set formatted object");
        }
        const keys = [];
        for (let jwk of jwks.keys){
            jwk = clone(jwk);
            const { kty , kid , crv  } = jwk;
            let { alg , use  } = jwk;
            if (typeof kty !== "string" || !kty) {
                continue;
            }
            if (use !== undefined && use !== "sig" && use !== "enc") {
                continue;
            }
            if (typeof alg !== "string" && alg !== undefined) {
                continue;
            }
            if (typeof kid !== "string" && kid !== undefined) {
                continue;
            }
            if (kty === "EC" && use === "sig") {
                switch(crv){
                    case "P-256":
                        alg = "ES256";
                        break;
                    case "P-384":
                        alg = "ES384";
                        break;
                    case "P-521":
                        alg = "ES512";
                        break;
                    default:
                        break;
                }
            }
            if (crv === "secp256k1") {
                use = "sig";
                alg = "ES256K";
            }
            if (kty === "OKP") {
                switch(crv){
                    case "Ed25519":
                    case "Ed448":
                        use = "sig";
                        alg = "EdDSA";
                        break;
                    case "X25519":
                    case "X448":
                        use = "enc";
                        break;
                    default:
                        break;
                }
            }
            if (alg && !use) {
                switch(true){
                    case alg.startsWith("ECDH"):
                        use = "enc";
                        break;
                    case alg.startsWith("RSA"):
                        use = "enc";
                        break;
                    default:
                        break;
                }
            }
            const keyObject = await jose.importJWK(jwk, alg || fauxAlg(jwk.kty)).catch(()=>{});
            if (!keyObject) continue;
            if (keyObject instanceof Uint8Array || keyObject.type === "secret") {
                if (onlyPrivate) {
                    throw new Error("jwks must only contain private keys");
                }
                continue;
            }
            if (!isKeyObject(keyObject)) {
                throw new Error("what?!");
            }
            if (onlyPrivate && keyObject.type !== "private") {
                throw new Error("jwks must only contain private keys");
            }
            if (onlyPublic && keyObject.type !== "public") {
                continue;
            }
            if (kty === "RSA" && keyObject.asymmetricKeySize < 2048) {
                continue;
            }
            keys.push({
                jwk: {
                    ...jwk,
                    alg,
                    use
                },
                keyObject,
                get algorithms () {
                    Object.defineProperty(this, "algorithms", {
                        value: getAlgorithms(this.jwk.use, this.jwk.alg, this.jwk.kty, this.jwk.crv),
                        enumerable: true,
                        configurable: false
                    });
                    return this.algorithms;
                }
            });
        }
        return new this(internal, keys);
    }
    filter(...args) {
        return this.#keys.filter(...args);
    }
    find(...args) {
        return this.#keys.find(...args);
    }
    every(...args) {
        return this.#keys.every(...args);
    }
    some(...args) {
        return this.#keys.some(...args);
    }
    map(...args) {
        return this.#keys.map(...args);
    }
    forEach(...args) {
        return this.#keys.forEach(...args);
    }
    reduce(...args) {
        return this.#keys.reduce(...args);
    }
    sort(...args) {
        return this.#keys.sort(...args);
    }
    *[Symbol.iterator]() {
        for (const key of this.#keys){
            yield key;
        }
    }
};


/***/ }),

/***/ 4016:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const isPlainObject = __webpack_require__(93968);
function merge(target, ...sources) {
    for (const source of sources){
        if (!isPlainObject(source)) {
            continue;
        }
        for (const [key, value] of Object.entries(source)){
            /* istanbul ignore if */ if (key === "__proto__" || key === "constructor") {
                continue;
            }
            if (isPlainObject(target[key]) && isPlainObject(value)) {
                target[key] = merge(target[key], value);
            } else if (typeof value !== "undefined") {
                target[key] = value;
            }
        }
    }
    return target;
}
module.exports = merge;


/***/ }),

/***/ 75469:
/***/ ((module) => {

"use strict";

module.exports = function pick(object, ...paths) {
    const obj = {};
    for (const path of paths){
        if (object[path] !== undefined) {
            obj[path] = object[path];
        }
    }
    return obj;
};


/***/ }),

/***/ 21074:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const { STATUS_CODES  } = __webpack_require__(13685);
const { format  } = __webpack_require__(73837);
const { OPError  } = __webpack_require__(29567);
const parseWwwAuthenticate = __webpack_require__(51091);
const throwAuthenticateErrors = (response)=>{
    const params = parseWwwAuthenticate(response.headers["www-authenticate"]);
    if (params.error) {
        throw new OPError(params, response);
    }
};
const isStandardBodyError = (response)=>{
    let result = false;
    try {
        let jsonbody;
        if (typeof response.body !== "object" || Buffer.isBuffer(response.body)) {
            jsonbody = JSON.parse(response.body);
        } else {
            jsonbody = response.body;
        }
        result = typeof jsonbody.error === "string" && jsonbody.error.length;
        if (result) Object.defineProperty(response, "body", {
            value: jsonbody,
            configurable: true
        });
    } catch (err) {}
    return result;
};
function processResponse(response, { statusCode =200 , body =true , bearer =false  } = {}) {
    if (response.statusCode !== statusCode) {
        if (bearer) {
            throwAuthenticateErrors(response);
        }
        if (isStandardBodyError(response)) {
            throw new OPError(response.body, response);
        }
        throw new OPError({
            error: format("expected %i %s, got: %i %s", statusCode, STATUS_CODES[statusCode], response.statusCode, STATUS_CODES[response.statusCode])
        }, response);
    }
    if (body && !response.body) {
        throw new OPError({
            error: format("expected %i %s with body but no body was returned", statusCode, STATUS_CODES[statusCode])
        }, response);
    }
    return response.body;
}
module.exports = processResponse;


/***/ }),

/***/ 77260:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const assert = __webpack_require__(39491);
const querystring = __webpack_require__(63477);
const http = __webpack_require__(13685);
const https = __webpack_require__(95687);
const { once  } = __webpack_require__(82361);
const { URL  } = __webpack_require__(57310);
const LRU = __webpack_require__(65462);
const pkg = __webpack_require__(56412);
const { RPError  } = __webpack_require__(29567);
const pick = __webpack_require__(75469);
const { deep: defaultsDeep  } = __webpack_require__(66942);
const { HTTP_OPTIONS  } = __webpack_require__(23575);
let DEFAULT_HTTP_OPTIONS;
const NQCHAR = /^[\x21\x23-\x5B\x5D-\x7E]+$/;
const allowed = [
    "agent",
    "ca",
    "cert",
    "crl",
    "headers",
    "key",
    "lookup",
    "passphrase",
    "pfx",
    "timeout"
];
const setDefaults = (props, options)=>{
    DEFAULT_HTTP_OPTIONS = defaultsDeep({}, props.length ? pick(options, ...props) : options, DEFAULT_HTTP_OPTIONS);
};
setDefaults([], {
    headers: {
        "User-Agent": `${pkg.name}/${pkg.version} (${pkg.homepage})`
    },
    timeout: 3500
});
function send(req, body, contentType) {
    if (contentType) {
        req.removeHeader("content-type");
        req.setHeader("content-type", contentType);
    }
    if (body) {
        req.removeHeader("content-length");
        req.setHeader("content-length", Buffer.byteLength(body));
        req.write(body);
    }
    req.end();
}
const nonces = new LRU({
    max: 100
});
module.exports = async function request(options, { accessToken , mTLS =false , DPoP  } = {}) {
    let url;
    try {
        url = new URL(options.url);
        delete options.url;
        assert(/^(https?:)$/.test(url.protocol));
    } catch (err) {
        throw new TypeError("only valid absolute URLs can be requested");
    }
    const optsFn = this[HTTP_OPTIONS];
    let opts = options;
    const nonceKey = `${url.origin}${url.pathname}`;
    if (DPoP && "dpopProof" in this) {
        opts.headers = opts.headers || {};
        opts.headers.DPoP = await this.dpopProof({
            htu: `${url.origin}${url.pathname}`,
            htm: options.method,
            nonce: nonces.get(nonceKey)
        }, DPoP, accessToken);
    }
    let userOptions;
    if (optsFn) {
        userOptions = pick(optsFn.call(this, url, defaultsDeep({}, opts, DEFAULT_HTTP_OPTIONS)), ...allowed);
    }
    opts = defaultsDeep({}, userOptions, opts, DEFAULT_HTTP_OPTIONS);
    if (mTLS && !opts.pfx && !(opts.key && opts.cert)) {
        throw new TypeError("mutual-TLS certificate and key not set");
    }
    if (opts.searchParams) {
        for (const [key, value] of Object.entries(opts.searchParams)){
            url.searchParams.delete(key);
            url.searchParams.set(key, value);
        }
    }
    let responseType;
    let form;
    let json;
    let body;
    ({ form , responseType , json , body , ...opts } = opts);
    for (const [key1, value1] of Object.entries(opts.headers || {})){
        if (value1 === undefined) {
            delete opts.headers[key1];
        }
    }
    let response;
    const req = (url.protocol === "https:" ? https.request : http.request)(url.href, opts);
    return (async ()=>{
        if (json) {
            send(req, JSON.stringify(json), "application/json");
        } else if (form) {
            send(req, querystring.stringify(form), "application/x-www-form-urlencoded");
        } else if (body) {
            send(req, body);
        } else {
            send(req);
        }
        [response] = await Promise.race([
            once(req, "response"),
            once(req, "timeout")
        ]);
        // timeout reached
        if (!response) {
            req.destroy();
            throw new RPError(`outgoing request timed out after ${opts.timeout}ms`);
        }
        const parts = [];
        for await (const part of response){
            parts.push(part);
        }
        if (parts.length) {
            switch(responseType){
                case "json":
                    {
                        Object.defineProperty(response, "body", {
                            get () {
                                let value = Buffer.concat(parts);
                                try {
                                    value = JSON.parse(value);
                                } catch (err) {
                                    Object.defineProperty(err, "response", {
                                        value: response
                                    });
                                    throw err;
                                } finally{
                                    Object.defineProperty(response, "body", {
                                        value,
                                        configurable: true
                                    });
                                }
                                return value;
                            },
                            configurable: true
                        });
                        break;
                    }
                case undefined:
                case "buffer":
                    {
                        Object.defineProperty(response, "body", {
                            get () {
                                const value = Buffer.concat(parts);
                                Object.defineProperty(response, "body", {
                                    value,
                                    configurable: true
                                });
                                return value;
                            },
                            configurable: true
                        });
                        break;
                    }
                default:
                    throw new TypeError("unsupported responseType request option");
            }
        }
        return response;
    })().catch((err)=>{
        if (response) Object.defineProperty(err, "response", {
            value: response
        });
        throw err;
    }).finally(()=>{
        const dpopNonce = response && response.headers["dpop-nonce"];
        if (dpopNonce && NQCHAR.test(dpopNonce)) {
            nonces.set(nonceKey, dpopNonce);
        }
    });
};
module.exports.setDefaults = setDefaults.bind(undefined, allowed);


/***/ }),

/***/ 42839:
/***/ ((module) => {

"use strict";

module.exports = ()=>Math.floor(Date.now() / 1000);


/***/ }),

/***/ 94489:
/***/ ((module) => {

"use strict";

module.exports.keystores = new WeakMap();


/***/ }),

/***/ 60503:
/***/ ((module) => {

"use strict";
// Credit: https://github.com/rohe/pyoidc/blob/master/src/oic/utils/webfinger.py
// -- Normalization --
// A string of any other type is interpreted as a URI either the form of scheme
// "://" authority path-abempty [ "?" query ] [ "#" fragment ] or authority
// path-abempty [ "?" query ] [ "#" fragment ] per RFC 3986 [RFC3986] and is
// normalized according to the following rules:
//
// If the user input Identifier does not have an RFC 3986 [RFC3986] scheme
// portion, the string is interpreted as [userinfo "@"] host [":" port]
// path-abempty [ "?" query ] [ "#" fragment ] per RFC 3986 [RFC3986].
// If the userinfo component is present and all of the path component, query
// component, and port component are empty, the acct scheme is assumed. In this
// case, the normalized URI is formed by prefixing acct: to the string as the
// scheme. Per the 'acct' URI Scheme [I‑D.ietf‑appsawg‑acct‑uri], if there is an
// at-sign character ('@') in the userinfo component, it needs to be
// percent-encoded as described in RFC 3986 [RFC3986].
// For all other inputs without a scheme portion, the https scheme is assumed,
// and the normalized URI is formed by prefixing https:// to the string as the
// scheme.
// If the resulting URI contains a fragment portion, it MUST be stripped off
// together with the fragment delimiter character "#".
// The WebFinger [I‑D.ietf‑appsawg‑webfinger] Resource in this case is the
// resulting URI, and the WebFinger Host is the authority component.
//
// Note: Since the definition of authority in RFC 3986 [RFC3986] is
// [ userinfo "@" ] host [ ":" port ], it is legal to have a user input
// identifier like userinfo@host:port, e.g., alice@example.com:8080.

const PORT = /^\d+$/;
function hasScheme(input) {
    if (input.includes("://")) return true;
    const authority = input.replace(/(\/|\?)/g, "#").split("#")[0];
    if (authority.includes(":")) {
        const index = authority.indexOf(":");
        const hostOrPort = authority.slice(index + 1);
        if (!PORT.test(hostOrPort)) {
            return true;
        }
    }
    return false;
}
function acctSchemeAssumed(input) {
    if (!input.includes("@")) return false;
    const parts = input.split("@");
    const host = parts[parts.length - 1];
    return !(host.includes(":") || host.includes("/") || host.includes("?"));
}
function normalize(input) {
    if (typeof input !== "string") {
        throw new TypeError("input must be a string");
    }
    let output;
    if (hasScheme(input)) {
        output = input;
    } else if (acctSchemeAssumed(input)) {
        output = `acct:${input}`;
    } else {
        output = `https://${input}`;
    }
    return output.split("#")[0];
}
module.exports = normalize;


/***/ }),

/***/ 51091:
/***/ ((module) => {

"use strict";

const REGEXP = /(\w+)=("[^"]*")/g;
module.exports = (wwwAuthenticate)=>{
    const params = {};
    try {
        while(REGEXP.exec(wwwAuthenticate) !== null){
            if (RegExp.$1 && RegExp.$2) {
                params[RegExp.$1] = RegExp.$2.slice(1, -1);
            }
        }
    } catch (err) {}
    return params;
};


/***/ }),

/***/ 5668:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const Issuer = __webpack_require__(10624);
const { OPError , RPError  } = __webpack_require__(29567);
const Strategy = __webpack_require__(85378);
const TokenSet = __webpack_require__(70023);
const { CLOCK_TOLERANCE , HTTP_OPTIONS  } = __webpack_require__(23575);
const generators = __webpack_require__(45936);
const { setDefaults  } = __webpack_require__(77260);
module.exports = {
    Issuer,
    Strategy,
    TokenSet,
    errors: {
        OPError,
        RPError
    },
    custom: {
        setHttpOptionsDefaults: setDefaults,
        http_options: HTTP_OPTIONS,
        clock_tolerance: CLOCK_TOLERANCE
    },
    generators
};


/***/ }),

/***/ 87584:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Issuer": () => (/* binding */ Issuer),
/* harmony export */   "Strategy": () => (/* binding */ Strategy),
/* harmony export */   "TokenSet": () => (/* binding */ TokenSet),
/* harmony export */   "custom": () => (/* binding */ custom),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "errors": () => (/* binding */ errors),
/* harmony export */   "generators": () => (/* binding */ generators)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5668);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_index_js__WEBPACK_IMPORTED_MODULE_0__);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((_index_js__WEBPACK_IMPORTED_MODULE_0___default()));
const Issuer = (_index_js__WEBPACK_IMPORTED_MODULE_0___default().Issuer);
const Strategy = (_index_js__WEBPACK_IMPORTED_MODULE_0___default().Strategy);
const TokenSet = (_index_js__WEBPACK_IMPORTED_MODULE_0___default().TokenSet);
const errors = (_index_js__WEBPACK_IMPORTED_MODULE_0___default().errors);
const custom = (_index_js__WEBPACK_IMPORTED_MODULE_0___default().custom);
const generators = (_index_js__WEBPACK_IMPORTED_MODULE_0___default().generators);


/***/ }),

/***/ 10624:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const { inspect  } = __webpack_require__(73837);
const url = __webpack_require__(57310);
const { RPError  } = __webpack_require__(29567);
const getClient = __webpack_require__(20785);
const registry = __webpack_require__(21724);
const processResponse = __webpack_require__(21074);
const webfingerNormalize = __webpack_require__(60503);
const request = __webpack_require__(77260);
const clone = __webpack_require__(56777);
const { keystore  } = __webpack_require__(64306);
const AAD_MULTITENANT_DISCOVERY = [
    "https://login.microsoftonline.com/common/.well-known/openid-configuration",
    "https://login.microsoftonline.com/common/v2.0/.well-known/openid-configuration",
    "https://login.microsoftonline.com/organizations/v2.0/.well-known/openid-configuration",
    "https://login.microsoftonline.com/consumers/v2.0/.well-known/openid-configuration"
];
const AAD_MULTITENANT = Symbol();
const ISSUER_DEFAULTS = {
    claim_types_supported: [
        "normal"
    ],
    claims_parameter_supported: false,
    grant_types_supported: [
        "authorization_code",
        "implicit"
    ],
    request_parameter_supported: false,
    request_uri_parameter_supported: true,
    require_request_uri_registration: false,
    response_modes_supported: [
        "query",
        "fragment"
    ],
    token_endpoint_auth_methods_supported: [
        "client_secret_basic"
    ]
};
class Issuer {
    #metadata;
    constructor(meta = {}){
        const aadIssValidation = meta[AAD_MULTITENANT];
        delete meta[AAD_MULTITENANT];
        [
            "introspection",
            "revocation"
        ].forEach((endpoint)=>{
            // if intro/revocation endpoint auth specific meta is missing use the token ones if they
            // are defined
            if (meta[`${endpoint}_endpoint`] && meta[`${endpoint}_endpoint_auth_methods_supported`] === undefined && meta[`${endpoint}_endpoint_auth_signing_alg_values_supported`] === undefined) {
                if (meta.token_endpoint_auth_methods_supported) {
                    meta[`${endpoint}_endpoint_auth_methods_supported`] = meta.token_endpoint_auth_methods_supported;
                }
                if (meta.token_endpoint_auth_signing_alg_values_supported) {
                    meta[`${endpoint}_endpoint_auth_signing_alg_values_supported`] = meta.token_endpoint_auth_signing_alg_values_supported;
                }
            }
        });
        this.#metadata = new Map();
        Object.entries(meta).forEach(([key, value])=>{
            this.#metadata.set(key, value);
            if (!this[key]) {
                Object.defineProperty(this, key, {
                    get () {
                        return this.#metadata.get(key);
                    },
                    enumerable: true
                });
            }
        });
        registry.set(this.issuer, this);
        const Client = getClient(this, aadIssValidation);
        Object.defineProperties(this, {
            Client: {
                value: Client,
                enumerable: true
            },
            FAPI1Client: {
                value: class FAPI1Client extends Client {
                },
                enumerable: true
            }
        });
    }
    get metadata() {
        return clone(Object.fromEntries(this.#metadata.entries()));
    }
    static async webfinger(input) {
        const resource = webfingerNormalize(input);
        const { host  } = url.parse(resource);
        const webfingerUrl = `https://${host}/.well-known/webfinger`;
        const response = await request.call(this, {
            method: "GET",
            url: webfingerUrl,
            responseType: "json",
            searchParams: {
                resource,
                rel: "http://openid.net/specs/connect/1.0/issuer"
            },
            headers: {
                Accept: "application/json"
            }
        });
        const body = processResponse(response);
        const location = Array.isArray(body.links) && body.links.find((link)=>typeof link === "object" && link.rel === "http://openid.net/specs/connect/1.0/issuer" && link.href);
        if (!location) {
            throw new RPError({
                message: "no issuer found in webfinger response",
                body
            });
        }
        if (typeof location.href !== "string" || !location.href.startsWith("https://")) {
            throw new RPError({
                printf: [
                    "invalid issuer location %s",
                    location.href
                ],
                body
            });
        }
        const expectedIssuer = location.href;
        if (registry.has(expectedIssuer)) {
            return registry.get(expectedIssuer);
        }
        const issuer = await this.discover(expectedIssuer);
        if (issuer.issuer !== expectedIssuer) {
            registry.del(issuer.issuer);
            throw new RPError("discovered issuer mismatch, expected %s, got: %s", expectedIssuer, issuer.issuer);
        }
        return issuer;
    }
    static async discover(uri) {
        const parsed = url.parse(uri);
        if (parsed.pathname.includes("/.well-known/")) {
            const response = await request.call(this, {
                method: "GET",
                responseType: "json",
                url: uri,
                headers: {
                    Accept: "application/json"
                }
            });
            const body = processResponse(response);
            return new Issuer({
                ...ISSUER_DEFAULTS,
                ...body,
                [AAD_MULTITENANT]: !!AAD_MULTITENANT_DISCOVERY.find((discoveryURL)=>uri.startsWith(discoveryURL))
            });
        }
        let pathname;
        if (parsed.pathname.endsWith("/")) {
            pathname = `${parsed.pathname}.well-known/openid-configuration`;
        } else {
            pathname = `${parsed.pathname}/.well-known/openid-configuration`;
        }
        const wellKnownUri = url.format({
            ...parsed,
            pathname
        });
        const response1 = await request.call(this, {
            method: "GET",
            responseType: "json",
            url: wellKnownUri,
            headers: {
                Accept: "application/json"
            }
        });
        const body1 = processResponse(response1);
        return new Issuer({
            ...ISSUER_DEFAULTS,
            ...body1,
            [AAD_MULTITENANT]: !!AAD_MULTITENANT_DISCOVERY.find((discoveryURL)=>wellKnownUri.startsWith(discoveryURL))
        });
    }
    async reloadJwksUri() {
        await keystore.call(this, true);
    }
    /* istanbul ignore next */ [inspect.custom]() {
        return `${this.constructor.name} ${inspect(this.metadata, {
            depth: Infinity,
            colors: process.stdout.isTTY,
            compact: false,
            sorted: true
        })}`;
    }
}
module.exports = Issuer;


/***/ }),

/***/ 21724:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const LRU = __webpack_require__(65462);
module.exports = new LRU({
    max: 100
});


/***/ }),

/***/ 85378:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const url = __webpack_require__(57310);
const { format  } = __webpack_require__(73837);
const cloneDeep = __webpack_require__(56777);
const { RPError , OPError  } = __webpack_require__(29567);
const { BaseClient  } = __webpack_require__(20785);
const { random , codeChallenge  } = __webpack_require__(45936);
const pick = __webpack_require__(75469);
const { resolveResponseType , resolveRedirectUri  } = __webpack_require__(72257);
function verified(err, user, info = {}) {
    if (err) {
        this.error(err);
    } else if (!user) {
        this.fail(info);
    } else {
        this.success(user, info);
    }
}
function OpenIDConnectStrategy({ client , params ={} , passReqToCallback =false , sessionKey , usePKCE =true , extras ={}  } = {}, verify) {
    if (!(client instanceof BaseClient)) {
        throw new TypeError("client must be an instance of openid-client Client");
    }
    if (typeof verify !== "function") {
        throw new TypeError("verify callback must be a function");
    }
    if (!client.issuer || !client.issuer.issuer) {
        throw new TypeError("client must have an issuer with an identifier");
    }
    this._client = client;
    this._issuer = client.issuer;
    this._verify = verify;
    this._passReqToCallback = passReqToCallback;
    this._usePKCE = usePKCE;
    this._key = sessionKey || `oidc:${url.parse(this._issuer.issuer).hostname}`;
    this._params = cloneDeep(params);
    this._extras = cloneDeep(extras);
    if (!this._params.response_type) this._params.response_type = resolveResponseType.call(client);
    if (!this._params.redirect_uri) this._params.redirect_uri = resolveRedirectUri.call(client);
    if (!this._params.scope) this._params.scope = "openid";
    if (this._usePKCE === true) {
        const supportedMethods = Array.isArray(this._issuer.code_challenge_methods_supported) ? this._issuer.code_challenge_methods_supported : false;
        if (supportedMethods && supportedMethods.includes("S256")) {
            this._usePKCE = "S256";
        } else if (supportedMethods && supportedMethods.includes("plain")) {
            this._usePKCE = "plain";
        } else if (supportedMethods) {
            throw new TypeError("neither code_challenge_method supported by the client is supported by the issuer");
        } else {
            this._usePKCE = "S256";
        }
    } else if (typeof this._usePKCE === "string" && ![
        "plain",
        "S256"
    ].includes(this._usePKCE)) {
        throw new TypeError(`${this._usePKCE} is not valid/implemented PKCE code_challenge_method`);
    }
    this.name = url.parse(client.issuer.issuer).hostname;
}
OpenIDConnectStrategy.prototype.authenticate = function authenticate(req, options) {
    (async ()=>{
        const client = this._client;
        if (!req.session) {
            throw new TypeError("authentication requires session support");
        }
        const reqParams = client.callbackParams(req);
        const sessionKey = this._key;
        /* start authentication request */ if (Object.keys(reqParams).length === 0) {
            // provide options object with extra authentication parameters
            const params = {
                state: random(),
                ...this._params,
                ...options
            };
            if (!params.nonce && params.response_type.includes("id_token")) {
                params.nonce = random();
            }
            req.session[sessionKey] = pick(params, "nonce", "state", "max_age", "response_type");
            if (this._usePKCE && params.response_type.includes("code")) {
                const verifier = random();
                req.session[sessionKey].code_verifier = verifier;
                switch(this._usePKCE){
                    case "S256":
                        params.code_challenge = codeChallenge(verifier);
                        params.code_challenge_method = "S256";
                        break;
                    case "plain":
                        params.code_challenge = verifier;
                        break;
                }
            }
            this.redirect(client.authorizationUrl(params));
            return;
        }
        /* end authentication request */ /* start authentication response */ const session = req.session[sessionKey];
        if (Object.keys(session || {}).length === 0) {
            throw new Error(format('did not find expected authorization request details in session, req.session["%s"] is %j', sessionKey, session));
        }
        const { state , nonce , max_age: maxAge , code_verifier: codeVerifier , response_type: responseType  } = session;
        try {
            delete req.session[sessionKey];
        } catch (err) {}
        const opts = {
            redirect_uri: this._params.redirect_uri,
            ...options
        };
        const checks = {
            state,
            nonce,
            max_age: maxAge,
            code_verifier: codeVerifier,
            response_type: responseType
        };
        const tokenset = await client.callback(opts.redirect_uri, reqParams, checks, this._extras);
        const passReq = this._passReqToCallback;
        const loadUserinfo = this._verify.length > (passReq ? 3 : 2) && client.issuer.userinfo_endpoint;
        const args = [
            tokenset,
            verified.bind(this)
        ];
        if (loadUserinfo) {
            if (!tokenset.access_token) {
                throw new RPError({
                    message: "expected access_token to be returned when asking for userinfo in verify callback",
                    tokenset
                });
            }
            const userinfo = await client.userinfo(tokenset);
            args.splice(1, 0, userinfo);
        }
        if (passReq) {
            args.unshift(req);
        }
        this._verify(...args);
    /* end authentication response */ })().catch((error)=>{
        if (error instanceof OPError && error.error !== "server_error" && !error.error.startsWith("invalid") || error instanceof RPError) {
            this.fail(error);
        } else {
            this.error(error);
        }
    });
};
module.exports = OpenIDConnectStrategy;


/***/ }),

/***/ 70023:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const base64url = __webpack_require__(58);
const now = __webpack_require__(42839);
class TokenSet {
    constructor(values){
        Object.assign(this, values);
        const { constructor , ...properties } = Object.getOwnPropertyDescriptors(this.constructor.prototype);
        Object.defineProperties(this, properties);
    }
    set expires_in(value) {
        this.expires_at = now() + Number(value);
    }
    get expires_in() {
        return Math.max.apply(null, [
            this.expires_at - now(),
            0
        ]);
    }
    expired() {
        return this.expires_in === 0;
    }
    claims() {
        if (!this.id_token) {
            throw new TypeError("id_token not present in TokenSet");
        }
        return JSON.parse(base64url.decode(this.id_token.split(".")[1]));
    }
}
module.exports = TokenSet;


/***/ }),

/***/ 81557:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var BaseClient_1 = __webpack_require__(3133);
var models_1 = __webpack_require__(98159);
var models_2 = __webpack_require__(98159);
var AccountClient = /** @class */ function(_super) {
    __extends(AccountClient, _super);
    /**
     * Create a new AccountClient
     * @param accountToken The account token that should be used with requests.
     * @param configOptions Various options to customize client behavior.
     */ function AccountClient(accountToken, configOptions) {
        return _super.call(this, accountToken, models_1.ClientOptions.AuthHeaderNames.ACCOUNT_TOKEN, configOptions) || this;
    }
    /**
     * Retrieve a list of Servers.
     *
     * @param filter - An optional filter for which data is retrieved.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.getServers = function(filter, callback) {
        if (filter === void 0) {
            filter = new models_2.ServerFilteringParameters();
        }
        this.setDefaultPaginationValues(filter);
        return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.GET, "/servers", filter, callback);
    };
    /**
     * Retrieve a single server by ID.
     *
     * @param id - The ID of the Server for which you wish to retrieve details.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.getServer = function(id, callback) {
        return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.GET, "/servers/".concat(id), {}, callback);
    };
    /**
     * Create a new Server.
     *
     * @param options - The options to be used to create new Server.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.createServer = function(options, callback) {
        return this.processRequestWithBody(models_1.ClientOptions.HttpMethod.POST, "/servers", options, callback);
    };
    /**
     * Modify the Server associated with this Client.
     *
     * @param id - The ID of the Server you wish to update.
     * @param options - The options to be used to create new Server.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.editServer = function(id, options, callback) {
        return this.processRequestWithBody(models_1.ClientOptions.HttpMethod.PUT, "/servers/".concat(id), options, callback);
    };
    /**
     * Modify the Server associated with this Client.
     *
     * @param id - The ID of the Domain you wish to delete.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.deleteServer = function(id, callback) {
        return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.DELETE, "/servers/".concat(id), {}, callback);
    };
    /**
     * Retrieve a batch of Domains.
     *
     * @param filter - An optional filter for which data is retrieved.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.getDomains = function(filter, callback) {
        if (filter === void 0) {
            filter = new models_1.FilteringParameters();
        }
        this.setDefaultPaginationValues(filter);
        return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.GET, "/domains", filter, callback);
    };
    /**
     * Retrieve a single Domain by ID.
     *
     * @param id - The ID of the Domain for which you wish to retrieve details.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.getDomain = function(id, callback) {
        return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.GET, "/domains/".concat(id), {}, callback);
    };
    /**
     * Create a new Domain.
     *
     * @param options - The options to be used to create new Domain.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.createDomain = function(options, callback) {
        return this.processRequestWithBody(models_1.ClientOptions.HttpMethod.POST, "/domains/", options, callback);
    };
    /**
     * Update a Domain.
     *
     * @param id - The ID of the Domain you wish to update.
     * @param domain - The values on the Domain you wish to update.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.editDomain = function(id, options, callback) {
        return this.processRequestWithBody(models_1.ClientOptions.HttpMethod.PUT, "/domains/".concat(id), options, callback);
    };
    /**
     * Delete a Domain.
     *
     * @param id - The ID of the Domain you wish to delete.
     * @param options - The options to be used in create Domain.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.deleteDomain = function(id, callback) {
        return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.DELETE, "/domains/".concat(id), {}, callback);
    };
    /**
     * Trigger Domain DKIM key verification.
     *
     * @param id - The ID of the Domain you wish to trigger DKIM verification for.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.verifyDomainDKIM = function(id, callback) {
        return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.PUT, "/domains/".concat(id, "/verifyDKIM"), {}, callback);
    };
    /**
     * Trigger Domain DKIM key verification.
     *
     * @param id - The ID of the Domain you wish to trigger DKIM verification for.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.verifyDomainReturnPath = function(id, callback) {
        return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.PUT, "/domains/".concat(id, "/verifyReturnPath"), {}, callback);
    };
    /**
     * Trigger Domain DKIM key verification.
     *
     * @param id - The ID of the Domain you wish to trigger DKIM verification for.
     * @param callback If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.verifyDomainSPF = function(id, callback) {
        return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.PUT, "/domains/".concat(id, "/verifySPF"), {}, callback);
    };
    /**
     * Trigger Domain DKIM key verification.
     *
     * @param id - The ID of the Domain you wish to trigger DKIM verification for.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.rotateDomainDKIM = function(id, callback) {
        return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.PUT, "/domains/".concat(id, "/rotateDKIM"), {}, callback);
    };
    /**
     * Retrieve a single Sender Signature by ID.
     *
     * @param id - The ID of the Sender Signature for which you wish to retrieve details.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.getSenderSignature = function(id, callback) {
        return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.GET, "/senders/".concat(id), {}, callback);
    };
    /**
     * Retrieve a batch of Sender Signatures.
     *
     * @param filter - An optional filter for which data is retrieved.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.getSenderSignatures = function(filter, callback) {
        if (filter === void 0) {
            filter = new models_1.FilteringParameters();
        }
        this.setDefaultPaginationValues(filter);
        return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.GET, "/senders", filter, callback);
    };
    /**
     * Create a new Sender Signature.
     *
     * @param options - The options to be used to create new Sender Signature.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.createSenderSignature = function(options, callback) {
        return this.processRequestWithBody(models_1.ClientOptions.HttpMethod.POST, "/senders/", options, callback);
    };
    /**
     * Update a Sender Signature.
     *
     * @param id - The ID of the Sender Signature for which you wish to update.
     * @param options - The values on the Sender Signature you wish to update.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.editSenderSignature = function(id, options, callback) {
        return this.processRequestWithBody(models_1.ClientOptions.HttpMethod.PUT, "/senders/".concat(id), options, callback);
    };
    /**
     * Delete a Domain.
     *
     * @param id - The ID of the Domain you wish to delete.
     * @param options - The options to be used in create Domain.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.deleteSenderSignature = function(id, callback) {
        return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.DELETE, "/senders/".concat(id), {}, callback);
    };
    /**
     * Request a new confirmation email to be sent to the email address associated with a Sender Signature.
     *
     * @param id - The ID of the Sender Signature.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.resendSenderSignatureConfirmation = function(id, callback) {
        return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.POST, "/senders/".concat(id, "/resend"), {}, callback);
    };
    /**
     * Request that the SPF records for Sender Signature be verified.
     *
     * @param id - The ID of the Sender Signature.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.verifySenderSignatureSPF = function(id, callback) {
        return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.POST, "/senders/".concat(id, "/verifySpf"), {}, callback);
    };
    /**
     * Request that the SPF records for Sender Signature be verified.
     *
     * @param id - The ID of the Sender Signature.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.requestNewDKIMForSenderSignature = function(id, callback) {
        return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.POST, "/senders/".concat(id, "/requestNewDkim"), {}, callback);
    };
    /**
     * Request a push of templates from one server to another.
     *
     * @param options - details for pushing templates from one place to another.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.pushTemplates = function(options, callback) {
        return this.processRequestWithBody(models_1.ClientOptions.HttpMethod.PUT, "/templates/push", options, callback);
    };
    return AccountClient;
}(BaseClient_1.default);
exports["default"] = AccountClient; //# sourceMappingURL=AccountClient.js.map


/***/ }),

/***/ 3133:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var ErrorHandler_1 = __webpack_require__(59810);
var HttpClient_1 = __webpack_require__(88172);
var packageJson = __webpack_require__(43727);
var CLIENT_VERSION = packageJson.version;
/**
 * Base client class from which client classes can be implemented, in our case, AccountClient and ServerClient classes.
 * This class is NOT intended to be instantiated directly.
 */ var BaseClient = /** @class */ function() {
    function BaseClient(token, authHeader, configOptions) {
        this.errorHandler = new ErrorHandler_1.ErrorHandler();
        this.verifyToken(token);
        this.token = token.trim();
        this.authHeader = authHeader;
        this.clientVersion = CLIENT_VERSION;
        this.httpClient = new HttpClient_1.AxiosHttpClient(configOptions);
    }
    BaseClient.prototype.setClientOptions = function(configOptions) {
        this.httpClient.initHttpClient(configOptions);
    };
    BaseClient.prototype.getClientOptions = function() {
        return this.httpClient.clientOptions;
    };
    /**
     * Process http request with sending body - data.
     *
     * @see processRequest for more details.
     */ BaseClient.prototype.processRequestWithBody = function(method, path, body, callback) {
        return this.processRequest(method, path, {}, body, callback);
    };
    /**
     * Process http request without sending body - data.
     *
     * @see processRequest for more details.
     */ BaseClient.prototype.processRequestWithoutBody = function(method, path, queryParameters, callback) {
        if (queryParameters === void 0) {
            queryParameters = {};
        }
        return this.processRequest(method, path, queryParameters, null, callback);
    };
    /**
     * Process request for Postmark ClientOptions.
     *
     * @param method - see processHttpRequest for details
     * @param path - see processHttpRequest for details
     * @param queryParameters - see processHttpRequest for details
     * @param body - see processHttpRequest for details
     * @param callback - callback function to be executed.
     *
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ BaseClient.prototype.processRequest = function(method, path, queryParameters, body, callback) {
        var httpRequest = this.processHttpRequest(method, path, queryParameters, body);
        this.processCallbackRequest(httpRequest, callback);
        return httpRequest;
    };
    /**
     * Process HTTP request.
     *
     * @param method - Which type of http request will be executed.
     * @param path - API URL endpoint.
     * @param queryParameters - Querystring parameters used for http request.
     * @param body - Data sent with http request.
     *
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ BaseClient.prototype.processHttpRequest = function(method, path, queryParameters, body) {
        return this.httpClient.httpRequest(method, path, queryParameters, body, this.getComposedHttpRequestHeaders()).then(function(response) {
            return response;
        }).catch(function(error) {
            return Promise.reject(error);
        });
    };
    /**
     * Process callback function for HTTP request.
     *
     * @param httpRequest - HTTP request for which callback will be executed
     * @param callback - callback function to be executed.
     */ BaseClient.prototype.processCallbackRequest = function(httpRequest, callback) {
        if (callback) {
            httpRequest.then(function(response) {
                return callback(null, response);
            }).catch(function(error) {
                return callback(error, null);
            });
        }
    };
    /**
     * JSON object with default headers sent by HTTP request.
     */ BaseClient.prototype.getComposedHttpRequestHeaders = function() {
        var _a;
        return _a = {}, _a[this.authHeader] = this.token, _a["Accept"] = "application/json", _a["User-Agent"] = "Postmark.JS - ".concat(this.clientVersion), _a;
    };
    /**
     * Token can't be empty.
     *
     * @param {string} token - HTTP request token
     */ BaseClient.prototype.verifyToken = function(token) {
        if (!token || token.trim() === "") {
            throw this.errorHandler.buildError("A valid API token must be provided.");
        }
    };
    /**
     * Set default values for count and offset when doing filtering with API requests if they are not specified by filter.
     */ BaseClient.prototype.setDefaultPaginationValues = function(filter) {
        filter.count = filter.count || 100;
        filter.offset = filter.offset || 0;
    };
    return BaseClient;
}();
exports["default"] = BaseClient; //# sourceMappingURL=BaseClient.js.map


/***/ }),

/***/ 88172:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = (void 0) && (void 0).__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AxiosHttpClient = void 0;
var axios_1 = __webpack_require__(19138);
var models_1 = __webpack_require__(98159);
var index_1 = __webpack_require__(83563);
var AxiosHttpClient = /** @class */ function(_super) {
    __extends(AxiosHttpClient, _super);
    function AxiosHttpClient(configOptions) {
        var _this = _super.call(this, configOptions) || this;
        _this.errorHandler = new index_1.ErrorHandler();
        return _this;
    }
    /**
     * Create http client instance with default settings.
     *
     * @return {AxiosInstance}
     */ AxiosHttpClient.prototype.initHttpClient = function(configOptions) {
        this.clientOptions = __assign(__assign({}, models_1.HttpClient.DefaultOptions), configOptions);
        var httpClient = axios_1.default.create({
            baseURL: this.getBaseHttpRequestURL(),
            timeout: this.getRequestTimeoutInMilliseconds(),
            responseType: "json",
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            validateStatus: function(status) {
                return status >= 200 && status < 300;
            }
        });
        httpClient.interceptors.response.use(function(response) {
            return response.data;
        });
        this.client = httpClient;
    };
    /**
     * Process http request.
     *
     * @param method - Which type of http request will be executed.
     * @param path - API URL endpoint.
     * @param queryParameters - Querystring parameters used for http request.
     * @param body - Data sent with http request.
     */ AxiosHttpClient.prototype.httpRequest = function(method, path, queryParameters, body, requestHeaders) {
        var _this = this;
        return this.client.request({
            method: method,
            url: path,
            data: body,
            headers: requestHeaders,
            params: queryParameters
        }).catch(function(errorThrown) {
            return Promise.reject(_this.transformError(errorThrown));
        });
    };
    /**
     * Process callback function for HTTP request.
     *
     * @param error - request error that needs to be transformed to proper Postmark error.
     *
     * @return {PostmarkError} - formatted Postmark error
     */ AxiosHttpClient.prototype.transformError = function(errorThrown) {
        var response = errorThrown.response;
        if (response !== undefined) {
            var status_1 = this.adjustValue(0, response.status);
            var errorCode = this.adjustValue(0, response.data.ErrorCode);
            var message = this.adjustValue(errorThrown.message, response.data.Message);
            return this.errorHandler.buildError(message, errorCode, status_1);
        } else if (errorThrown.message !== undefined) {
            return this.errorHandler.buildError(errorThrown.message);
        } else {
            return this.errorHandler.buildError(JSON.stringify(errorThrown, Object.getOwnPropertyNames(errorThrown)));
        }
    };
    /**
     * Timeout in seconds is adjusted to Axios format.
     *
     * @private
     */ AxiosHttpClient.prototype.getRequestTimeoutInMilliseconds = function() {
        return (this.clientOptions.timeout || 60) * 1000;
    };
    AxiosHttpClient.prototype.adjustValue = function(defaultValue, data) {
        return data === undefined ? defaultValue : data;
    };
    return AxiosHttpClient;
}(models_1.HttpClient);
exports.AxiosHttpClient = AxiosHttpClient; //# sourceMappingURL=HttpClient.js.map


/***/ }),

/***/ 71544:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var BaseClient_1 = __webpack_require__(3133);
var index_1 = __webpack_require__(98159);
var index_2 = __webpack_require__(98159);
/**
 * Server client class that can be used to interact with an individual Postmark Server.
 */ var ServerClient = /** @class */ function(_super) {
    __extends(ServerClient, _super);
    /**
     * Create a client.
     *
     * @param serverToken - The token for the server that you wish to interact with.
     * @param configOptions - Options to customize the behavior of the this client.
     */ function ServerClient(serverToken, configOptions) {
        return _super.call(this, serverToken, index_1.ClientOptions.AuthHeaderNames.SERVER_TOKEN, configOptions) || this;
    }
    /** Send a single email message.
     *
     * @param email - Email message to send.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.sendEmail = function(email, callback) {
        return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/email", email, callback);
    };
    /**
     * Send a batch of email messages.
     *
     * @param emails - An array of messages to send.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.sendEmailBatch = function(emails, callback) {
        return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/email/batch", emails, callback);
    };
    /**
     * Send a message using a template.
     *
     * @param template - Message you wish to send.
     * @param callback If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.sendEmailWithTemplate = function(template, callback) {
        return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/email/withTemplate", template, callback);
    };
    /**
     * Send a batch of template email messages.
     *
     * @param templates - An array of templated messages you wish to send using this Client.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.sendEmailBatchWithTemplates = function(templates, callback) {
        return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/email/batchWithTemplates", {
            Messages: templates
        }, callback);
    };
    /**
     * Get bounce statistic information for the associated Server.
     *
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getDeliveryStatistics = function(callback) {
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/deliveryStats", {}, callback);
    };
    /**
     * Get a batch of bounces.
     *
     * @param filter - Optional filtering parameters.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getBounces = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.BounceFilteringParameters();
        }
        this.setDefaultPaginationValues(filter);
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/bounces", filter, callback);
    };
    /**
     * Get details for a specific Bounce.
     *
     * @param id - The ID of the Bounce you wish to retrieve.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getBounce = function(id, callback) {
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/bounces/".concat(id), {}, callback);
    };
    /**
     * Get a Bounce Dump for a specific Bounce.
     *
     * @param id - The ID of the Bounce for which you wish to retrieve Bounce Dump.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getBounceDump = function(id, callback) {
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/bounces/".concat(id, "/dump"), {}, callback);
    };
    /**
     * Activate email address that was deactivated due to a Bounce.
     *
     * @param id - The ID of the Bounce for which you wish to activate the associated email.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.activateBounce = function(id, callback) {
        return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.PUT, "/bounces/".concat(id, "/activate"), {}, callback);
    };
    /**
     * Get the list of templates associated with this server.
     *
     * @param filter - Optional filtering options.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getTemplates = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.TemplateFilteringParameters();
        }
        this.setDefaultPaginationValues(filter);
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/templates", filter, callback);
    };
    /**
     * Get the a specific template associated with this server.
     *
     * @param idOrAlias - ID or alias for the template you wish to retrieve.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getTemplate = function(idOrAlias, callback) {
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/templates/".concat(idOrAlias), {}, callback);
    };
    /**
     * Delete a template associated with this server.
     *
     * @param idOrAlias - ID or template alias you wish to delete.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.deleteTemplate = function(idOrAlias, callback) {
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.DELETE, "/templates/".concat(idOrAlias), {}, callback);
    };
    /**
     * Create a new template on the associated server.
     *
     * @param options - Configuration options to be used to create the Template.
     * @param callback If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.createTemplate = function(options, callback) {
        return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/templates/", options, callback);
    };
    /**
     * Update a template on the associated server.
     *
     * @param idOrAlias - Id or alias of the template you wish to update.
     * @param options - Template options you wish to update.
     * @param callback If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.editTemplate = function(idOrAlias, options, callback) {
        return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.PUT, "/templates/".concat(idOrAlias), options, callback);
    };
    /**
     * Validate template markup to verify that it will be parsed. Also provides a recommended template
     * model to be used when sending using the specified template content.
     *
     * @param options - The template content you wish to validate.
     * @param callback If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.validateTemplate = function(options, callback) {
        return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/templates/validate", options, callback);
    };
    /**
     * Get the information for the Server associated with this Client.
     *
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getServer = function(callback) {
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/server", {}, callback);
    };
    /**
     * Modify the Server associated with this Client.
     *
     * @param options - The options you wish to modify.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.editServer = function(options, callback) {
        return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.PUT, "/server", options, callback);
    };
    /**
     * Get a batch of Outbound Messages.
     *
     * @param filter - Optional filtering parameters.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getOutboundMessages = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.OutboundMessagesFilteringParameters();
        }
        this.setDefaultPaginationValues(filter);
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/messages/outbound", filter, callback);
    };
    /**
     * Get details for a specific Outbound Message.
     *
     * @param messageId - The ID of the OutboundMessage you wish to retrieve.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getOutboundMessageDetails = function(messageId, callback) {
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/messages/outbound/".concat(messageId), {}, callback);
    };
    /**
     * Get details for a specific Outbound Message.
     *
     * @param messageId - The ID of the OutboundMessage you wish to retrieve.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getOutboundMessageDump = function(messageId, callback) {
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/messages/outbound/".concat(messageId, "/dump"), {}, callback);
    };
    /**
     * Get a batch of Inbound Messages.
     *
     * @param filter - Optional filtering parameters.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getInboundMessages = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.InboundMessagesFilteringParameters();
        }
        this.setDefaultPaginationValues(filter);
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/messages/inbound", filter, callback);
    };
    /**
     * Get details for a specific Inbound Message.
     *
     * @param messageId - The ID of the Inbound Message you wish to retrieve.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getInboundMessageDetails = function(messageId, callback) {
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/messages/inbound/".concat(messageId, "/details"), {}, callback);
    };
    /**
     * Cause an Inbound Message to bypass filtering rules defined on this Client's associated Server.
     *
     * @param messageId - The ID of the Inbound Message for which you wish to bypass the filtering rules.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.bypassBlockedInboundMessage = function(messageId, callback) {
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.PUT, "/messages/inbound/".concat(messageId, "/bypass"), {}, callback);
    };
    /**
     * Request that Postmark retry POSTing to the Inbound Hook for the specified message.
     *
     * @param messageId - The ID of the Inbound Message for which you wish to retry the inbound hook.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.retryInboundHookForMessage = function(messageId, callback) {
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.PUT, "/messages/inbound/".concat(messageId, "/retry"), {}, callback);
    };
    /**
     * Get the Opens for Outbound Messages.
     *
     * @param filter - Optional filtering parameters.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getMessageOpens = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.OutboundMessageOpensFilteringParameters();
        }
        this.setDefaultPaginationValues(filter);
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/messages/outbound/opens", filter, callback);
    };
    /**
     * Get details of Opens for specific Outbound Message.
     *
     * @param messageId - Message ID of the message for which you wish to retrieve Opens.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getMessageOpensForSingleMessage = function(messageId, filter, callback) {
        if (filter === void 0) {
            filter = new index_2.OutboundMessageOpensFilteringParameters(50, 0);
        }
        this.setDefaultPaginationValues(filter);
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/messages/outbound/opens/".concat(messageId), filter, callback);
    };
    /**
     * Get the Clicks for Outbound Messages.
     *
     * @param filter - Optional filtering parameters.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getMessageClicks = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.OutboundMessageClicksFilteringParameters();
        }
        this.setDefaultPaginationValues(filter);
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/messages/outbound/clicks", filter, callback);
    };
    /**
     * Get Click information for a single Outbound Message.
     *
     * @param messageId - The MessageID for which clicks should be retrieved.
     * @param filter - Optional filtering parameters.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getMessageClicksForSingleMessage = function(messageId, filter, callback) {
        if (filter === void 0) {
            filter = new index_2.OutboundMessageClicksFilteringParameters();
        }
        this.setDefaultPaginationValues(filter);
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/messages/outbound/clicks/".concat(messageId), filter, callback);
    };
    /**
     * Get overview statistics on Outbound Messages sent from the Server associated with this Client.
     *
     * @param filter - Optional filtering parameters.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getOutboundOverview = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.StatisticsFilteringParameters();
        }
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound", filter, callback);
    };
    /**
     * Get statistics on email sent from the Server associated with this Client.
     *
     * @param filter - Optional filtering parameters.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getSentCounts = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.StatisticsFilteringParameters();
        }
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound/sends", filter, callback);
    };
    /**
     * Get statistiscs on emails that bounced after being sent from the Server associated with this Client.
     *
     * @param filter - Optional filtering parameters.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getBounceCounts = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.StatisticsFilteringParameters();
        }
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound/bounces", filter, callback);
    };
    /**
     * Get SPAM complaint statistics for email sent from the Server associated with this Client.
     *
     * @param filter - Optional filtering parameters.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getSpamComplaintsCounts = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.StatisticsFilteringParameters();
        }
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound/spam", filter, callback);
    };
    /**
     * Get email tracking statistics for messages sent from the Server associated with this Client.
     *
     * @param filter - Optional filtering parameters.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getTrackedEmailCounts = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.StatisticsFilteringParameters();
        }
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound/tracked", filter, callback);
    };
    /**
     * Get Open statistics for messages sent from the Server associated with this Client.
     *
     * @param filter - Optional filtering parameters.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getEmailOpenCounts = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.StatisticsFilteringParameters();
        }
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound/opens", filter, callback);
    };
    /**
     * Get Email Client Platform statistics for messages sent from the Server associated with this Client.
     *
     * @param filter - Optional filtering parameters.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getEmailOpenPlatformUsage = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.StatisticsFilteringParameters();
        }
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound/opens/platforms", filter, callback);
    };
    /**
     * Get statistics on which Email Clients were used to open messages sent from the Server associated with this Client.
     *
     * @param filter - Optional filtering parameters.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getEmailOpenClientUsage = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.StatisticsFilteringParameters();
        }
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound/opens/emailClients", filter, callback);
    };
    /**
     * Get Read Time statistics for messages sent from the Server associated with this Client.
     * @param filter Optional filtering parameters.
     * @param callback If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getEmailOpenReadTimes = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.StatisticsFilteringParameters();
        }
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound/opens/readTimes", filter, callback);
    };
    /**
     * Get total clicks statistics for tracked links for messages sent from the Server associated with this Client.
     *
     * @param filter - Optional filtering parameters.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getClickCounts = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.StatisticsFilteringParameters();
        }
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound/clicks", filter, callback);
    };
    /**
     * Get browser family statistics for tracked links for messages sent from the Server associated with this Client.
     * @param filter Optional filtering parameters.
     * @param callback If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getClickBrowserUsage = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.StatisticsFilteringParameters();
        }
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound/clicks/browserFamilies", filter, callback);
    };
    /**
     * Get browser platform statistics for tracked links for messages sent from the Server associated with this Client.
     *
     * @param filter - Optional filtering parameters.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getClickPlatformUsage = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.StatisticsFilteringParameters();
        }
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound/clicks/platforms", filter, callback);
    };
    /**
     * Get click location (in HTML or Text body of the email) statistics for tracked links for messages sent
     * from the Server associated with this Client.
     *
     * @param filter - Optional filtering parameters.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getClickLocation = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.StatisticsFilteringParameters();
        }
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound/clicks/location", filter, callback);
    };
    /**
     * Create an Inbound Rule Trigger.
     *
     * @param options - Configuration options to be used when creating this Trigger.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.createInboundRuleTrigger = function(options, callback) {
        return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/triggers/inboundRules", options, callback);
    };
    /**
     * Delete an Inbound Rule Trigger.
     *
     * @param id - The ID of the Inbound Rule Trigger you wish to delete.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.deleteInboundRuleTrigger = function(id, callback) {
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.DELETE, "/triggers/inboundRules/".concat(id), {}, callback);
    };
    /**
     * Get a list of Inbound Rule Triggers.
     *
     * @param filter - Optional filtering parameters.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getInboundRuleTriggers = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_1.FilteringParameters();
        }
        this.setDefaultPaginationValues(filter);
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/triggers/inboundRules", filter, callback);
    };
    /**
     * Get the list of Webhooks for specific server.
     *
     * @param filter - Optional filtering parameters
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getWebhooks = function(filter, callback) {
        if (filter === void 0) {
            filter = {};
        }
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/webhooks", filter, callback);
    };
    /**
     * Get details for a specific Webhook.
     *
     * @param id - The ID of the Webhook you wish to retrieve.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getWebhook = function(id, callback) {
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/webhooks/".concat(id), {}, callback);
    };
    /**
     * Create a Webhook on the associated server.
     *
     * @param options - Configuration options to be used when creating Webhook trigger.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.createWebhook = function(options, callback) {
        return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/webhooks", options, callback);
    };
    /**
     * Update Webhook on the associated server.
     *
     * @param id - Id of the webhook you wish to update.
     * @param options - Webhook options you wish to update.
     * @param callback If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.editWebhook = function(id, options, callback) {
        return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.PUT, "/webhooks/".concat(id), options, callback);
    };
    /**
     * Delete an existing Webhook.
     *
     * @param id - The ID of the Webhook you wish to delete.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.deleteWebhook = function(id, callback) {
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.DELETE, "/webhooks/".concat(id), {}, callback);
    };
    /**
     * Get the list of message streams on a server.
     *
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getMessageStreams = function(filter, callback) {
        if (filter === void 0) {
            filter = {};
        }
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/message-streams", filter, callback);
    };
    /**
     * Get details for a specific message stream on a server.
     *
     * @param id - The ID of the message stream you wish to retrieve.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getMessageStream = function(id, callback) {
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/message-streams/".concat(id), {}, callback);
    };
    /**
     * Update message stream on the associated server.
     *
     * @param id - Id of the webhook you wish to update.
     * @param options - Webhook options you wish to update.
     * @param callback If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.editMessageStream = function(id, options, callback) {
        return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.PATCH, "/message-streams/".concat(id), options, callback);
    };
    /**
     * Create a message stream on the associated server.
     *
     * @param options - Configuration options to be used when creating message stream on the server.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.createMessageStream = function(options, callback) {
        return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/message-streams", options, callback);
    };
    /**
     * Archive a message stream on the associated server.
     *
     * @param options - Configuration options to be used when creating message stream on the server.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.archiveMessageStream = function(id, callback) {
        return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/message-streams/".concat(id, "/archive"), {}, callback);
    };
    /**
     * Unarchive a message stream on the associated server.
     *
     * @param options - Configuration options to be used when creating message stream on the server.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.unarchiveMessageStream = function(id, callback) {
        return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/message-streams/".concat(id, "/unarchive"), {}, callback);
    };
    /**
     * Get the list of suppressions for a message stream on a server.
     *
     * @param messageStream - Select message stream
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getSuppressions = function(messageStream, callback) {
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/message-streams/".concat(messageStream, "/suppressions/dump"), callback);
    };
    /**
     * Add email addresses to a suppressions list on a message stream on a server.
     *
     * @param messageStream - Select message stream
     * @param options - Suppressions you wish to add.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.createSuppressions = function(messageStream, options, callback) {
        return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/message-streams/".concat(messageStream, "/suppressions"), options, callback);
    };
    /**
     * Delete email addresses from a suppressions list on a message stream on a server.
     *
     * @param messageStream - Select message stream
     * @param options - Suppressions you wish to delete.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.deleteSuppressions = function(messageStream, options, callback) {
        return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/message-streams/".concat(messageStream, "/suppressions/delete"), options, callback);
    };
    return ServerClient;
}(BaseClient_1.default);
exports["default"] = ServerClient; //# sourceMappingURL=ServerClient.js.map


/***/ }),

/***/ 59810:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ErrorHandler = void 0;
var Errors = __webpack_require__(54428);
/**
 * Handles general errors and all client request errors.
 * Client response errors are classified so that proper response error is generated.
 */ var ErrorHandler = /** @class */ function() {
    function ErrorHandler() {}
    /**
     * Build general Postmark error.
     *
     * @param errorMessage - error message that needs to be identified and transformed to proper Postmark error.
     *
     * @returns properly formatted Postmark error.
     */ ErrorHandler.prototype.buildError = function(errorMessage, code, statusCode) {
        if (code === void 0) {
            code = 0;
        }
        if (statusCode === void 0) {
            statusCode = 0;
        }
        if (statusCode === 0 && code === 0) {
            return new Errors.PostmarkError(errorMessage);
        } else {
            return this.buildErrorByHttpStatusCode(errorMessage, code, statusCode);
        }
    };
    /**
     * Build Postmark error based on HTTP request status.
     *
     * @param error - http request library error, that will be transformed to Postmark error.
     *
     * @returns properly formatted Postmark error.
     */ ErrorHandler.prototype.buildErrorByHttpStatusCode = function(errorMessage, errorCode, errorStatusCode) {
        switch(errorStatusCode){
            case 401:
                return new Errors.InvalidAPIKeyError(errorMessage, errorCode, errorStatusCode);
            case 404:
                return new Errors.PostmarkError(errorMessage, errorCode, errorStatusCode);
            case 422:
                return Errors.ApiInputError.buildSpecificError(errorMessage, errorCode, errorStatusCode);
            case 429:
                return new Errors.RateLimitExceededError(errorMessage, errorCode, errorStatusCode);
            case 500:
                return new Errors.InternalServerError(errorMessage, errorCode, errorStatusCode);
            case 503:
                return new Errors.ServiceUnavailablerError(errorMessage, errorCode, errorStatusCode);
            default:
                return new Errors.UnknownError(errorMessage, errorCode, errorStatusCode);
        }
    };
    return ErrorHandler;
}();
exports.ErrorHandler = ErrorHandler; //# sourceMappingURL=ErrorHandler.js.map


/***/ }),

/***/ 54428:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.InvalidEmailRequestError = exports.InactiveRecipientsError = exports.ApiInputError = exports.UnknownError = exports.RateLimitExceededError = exports.ServiceUnavailablerError = exports.InternalServerError = exports.InvalidAPIKeyError = exports.HttpError = exports.PostmarkError = void 0;
/**
 * Standard Postmark error on which all sub-errors are based.
 */ var PostmarkError = /** @class */ function(_super) {
    __extends(PostmarkError, _super);
    function PostmarkError(message, code, statusCode) {
        if (code === void 0) {
            code = 0;
        }
        if (statusCode === void 0) {
            statusCode = 0;
        }
        var _this = _super.call(this, message) || this;
        _this.statusCode = statusCode;
        _this.code = code;
        // this is mandatory due:
        // https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work
        Object.setPrototypeOf(_this, PostmarkError.prototype);
        _this.setUpStackTrace();
        return _this;
    }
    PostmarkError.prototype.setUpStackTrace = function() {
        this.name = this.constructor.name;
        Error.captureStackTrace(this, this.constructor);
    };
    return PostmarkError;
}(Error);
exports.PostmarkError = PostmarkError;
var HttpError = /** @class */ function(_super) {
    __extends(HttpError, _super);
    function HttpError(message, code, statusCode) {
        var _this = _super.call(this, message, code, statusCode) || this;
        Object.setPrototypeOf(_this, HttpError.prototype);
        _this.setUpStackTrace();
        return _this;
    }
    return HttpError;
}(PostmarkError);
exports.HttpError = HttpError;
var InvalidAPIKeyError = /** @class */ function(_super) {
    __extends(InvalidAPIKeyError, _super);
    function InvalidAPIKeyError(message, code, statusCode) {
        var _this = _super.call(this, message, code, statusCode) || this;
        Object.setPrototypeOf(_this, InvalidAPIKeyError.prototype);
        _this.setUpStackTrace();
        return _this;
    }
    return InvalidAPIKeyError;
}(HttpError);
exports.InvalidAPIKeyError = InvalidAPIKeyError;
var InternalServerError = /** @class */ function(_super) {
    __extends(InternalServerError, _super);
    function InternalServerError(message, code, statusCode) {
        var _this = _super.call(this, message, code, statusCode) || this;
        Object.setPrototypeOf(_this, InternalServerError.prototype);
        _this.setUpStackTrace();
        return _this;
    }
    return InternalServerError;
}(HttpError);
exports.InternalServerError = InternalServerError;
var ServiceUnavailablerError = /** @class */ function(_super) {
    __extends(ServiceUnavailablerError, _super);
    function ServiceUnavailablerError(message, code, statusCode) {
        var _this = _super.call(this, message, code, statusCode) || this;
        Object.setPrototypeOf(_this, ServiceUnavailablerError.prototype);
        _this.setUpStackTrace();
        return _this;
    }
    return ServiceUnavailablerError;
}(HttpError);
exports.ServiceUnavailablerError = ServiceUnavailablerError;
var RateLimitExceededError = /** @class */ function(_super) {
    __extends(RateLimitExceededError, _super);
    function RateLimitExceededError(message, code, statusCode) {
        var _this = _super.call(this, message, code, statusCode) || this;
        Object.setPrototypeOf(_this, RateLimitExceededError.prototype);
        _this.setUpStackTrace();
        return _this;
    }
    return RateLimitExceededError;
}(HttpError);
exports.RateLimitExceededError = RateLimitExceededError;
var UnknownError = /** @class */ function(_super) {
    __extends(UnknownError, _super);
    function UnknownError(message, code, statusCode) {
        var _this = _super.call(this, message, code, statusCode) || this;
        Object.setPrototypeOf(_this, UnknownError.prototype);
        _this.setUpStackTrace();
        return _this;
    }
    return UnknownError;
}(HttpError);
exports.UnknownError = UnknownError;
var ApiInputError = /** @class */ function(_super) {
    __extends(ApiInputError, _super);
    function ApiInputError(message, code, statusCode) {
        var _this = _super.call(this, message, code, statusCode) || this;
        Object.setPrototypeOf(_this, ApiInputError.prototype);
        _this.setUpStackTrace();
        return _this;
    }
    ApiInputError.buildSpecificError = function(message, code, statusCode) {
        switch(code){
            case this.ERROR_CODES.inactiveRecipient:
                return new InactiveRecipientsError(message, code, statusCode);
            case this.ERROR_CODES.invalidEmailRequest:
                return new InvalidEmailRequestError(message, code, statusCode);
            default:
                return new ApiInputError(message, code, statusCode);
        }
    };
    ApiInputError.ERROR_CODES = {
        inactiveRecipient: 406,
        invalidEmailRequest: 300
    };
    return ApiInputError;
}(HttpError);
exports.ApiInputError = ApiInputError;
var InactiveRecipientsError = /** @class */ function(_super) {
    __extends(InactiveRecipientsError, _super);
    function InactiveRecipientsError(message, code, statusCode) {
        var _this = _super.call(this, message, code, statusCode) || this;
        Object.setPrototypeOf(_this, InactiveRecipientsError.prototype);
        _this.setUpStackTrace();
        _this.recipients = InactiveRecipientsError.parseInactiveRecipients(message);
        return _this;
    }
    InactiveRecipientsError.parseInactiveRecipients = function(message) {
        var result = [];
        this.inactiveRecipientsPatterns.some(function(pattern) {
            var regexResult = message.match(pattern);
            if (regexResult !== null) {
                result = regexResult[1].split(", ");
                return result;
            } else {
                result = [];
            }
        });
        return result;
    };
    InactiveRecipientsError.inactiveRecipientsPatterns = [
        /Found inactive addresses: (.+?)\.?$/m,
        /these inactive addresses: (.+?)\. Inactive/,
        /these inactive addresses: (.+?)\.?$/
    ];
    return InactiveRecipientsError;
}(ApiInputError);
exports.InactiveRecipientsError = InactiveRecipientsError;
var InvalidEmailRequestError = /** @class */ function(_super) {
    __extends(InvalidEmailRequestError, _super);
    function InvalidEmailRequestError(message, code, statusCode) {
        var _this = _super.call(this, message, code, statusCode) || this;
        Object.setPrototypeOf(_this, InvalidEmailRequestError.prototype);
        _this.setUpStackTrace();
        return _this;
    }
    return InvalidEmailRequestError;
}(ApiInputError);
exports.InvalidEmailRequestError = InvalidEmailRequestError; //# sourceMappingURL=Errors.js.map


/***/ }),

/***/ 83563:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = (void 0) && (void 0).__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
__exportStar(__webpack_require__(59810), exports);
__exportStar(__webpack_require__(54428), exports); //# sourceMappingURL=index.js.map


/***/ }),

/***/ 83522:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
})); //# sourceMappingURL=Bounce.js.map


/***/ }),

/***/ 65801:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.BounceFilteringParameters = exports.BounceType = void 0;
var FilteringParameters_1 = __webpack_require__(75858);
var BounceType;
(function(BounceType) {
    BounceType["HardBounce"] = "HardBounce";
    BounceType["Transient"] = "Transient";
    BounceType["Unsubscribe"] = "Unsubscribe";
    BounceType["Subscribe"] = "Subscribe";
    BounceType["AutoResponder"] = "AutoResponder";
    BounceType["AddressChange"] = "AddressChange";
    BounceType["DnsError"] = "DnsError";
    BounceType["SpamNotification"] = "SpamNotification";
    BounceType["OpenRelayTest"] = "OpenRelayTest";
    BounceType["Unknown"] = "Unknown";
    BounceType["SoftBounce"] = "SoftBounce";
    BounceType["VirusNotification"] = "VirusNotification";
    BounceType["ChallengeVerification"] = "ChallengeVerification";
    BounceType["BadEmailAddress"] = "BadEmailAddress";
    BounceType["SpamComplaint"] = "SpamComplaint";
    BounceType["ManuallyDeactivated"] = "ManuallyDeactivated";
    BounceType["Unconfirmed"] = "Unconfirmed";
    BounceType["Blocked"] = "Blocked";
    BounceType["SMTPApiError"] = "SMTPApiError";
    BounceType["InboundError"] = "InboundError";
    BounceType["DMARCPolicy"] = "DMARCPolicy";
    BounceType["TemplateRenderingFailed"] = "TemplateRenderingFailed";
})(BounceType = exports.BounceType || (exports.BounceType = {}));
/**
 * Describes filtering parameters that can be used when retrieving bounces.
 * When pagination parameters are not specified, default values are set.
 */ var BounceFilteringParameters = /** @class */ function(_super) {
    __extends(BounceFilteringParameters, _super);
    function BounceFilteringParameters(count, offset, type, inactive, emailFilter, tag, messageID, fromDate, toDate, messageStream) {
        if (count === void 0) {
            count = 100;
        }
        if (offset === void 0) {
            offset = 0;
        }
        var _this = _super.call(this, count, offset) || this;
        _this.type = type;
        _this.inactive = inactive;
        _this.emailFilter = emailFilter;
        _this.tag = tag;
        _this.messageID = messageID;
        _this.fromDate = fromDate;
        _this.toDate = toDate;
        _this.messageStream = messageStream;
        return _this;
    }
    return BounceFilteringParameters;
}(FilteringParameters_1.FilteringParameters);
exports.BounceFilteringParameters = BounceFilteringParameters; //# sourceMappingURL=BounceFilteringParameters.js.map


/***/ }),

/***/ 48438:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
})); //# sourceMappingURL=Callback.js.map


/***/ }),

/***/ 84733:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ClientOptions = void 0;
var ClientOptions;
(function(ClientOptions) {
    var Configuration = /** @class */ function() {
        function Configuration(useHttps, requestHost, timeout) {
            this.useHttps = useHttps;
            this.requestHost = requestHost;
            this.timeout = timeout;
        }
        return Configuration;
    }();
    ClientOptions.Configuration = Configuration;
    var HttpMethod;
    (function(HttpMethod) {
        HttpMethod["GET"] = "GET";
        HttpMethod["POST"] = "POST";
        HttpMethod["DELETE"] = "DELETE";
        HttpMethod["PUT"] = "PUT";
        HttpMethod["OPTIONS"] = "OPTIONS";
        HttpMethod["HEAD"] = "HEAD";
        HttpMethod["PATCH"] = "PATCH";
    })(HttpMethod = ClientOptions.HttpMethod || (ClientOptions.HttpMethod = {}));
    var AuthHeaderNames;
    (function(AuthHeaderNames) {
        AuthHeaderNames["SERVER_TOKEN"] = "X-Postmark-Server-Token";
        AuthHeaderNames["ACCOUNT_TOKEN"] = "X-Postmark-Account-Token";
    })(AuthHeaderNames = ClientOptions.AuthHeaderNames || (ClientOptions.AuthHeaderNames = {}));
})(ClientOptions = exports.ClientOptions || (exports.ClientOptions = {})); //# sourceMappingURL=ClientOptions.js.map


/***/ }),

/***/ 3328:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
})); //# sourceMappingURL=DefaultResponse.js.map


/***/ }),

/***/ 75858:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.FilteringParameters = void 0;
/**
 * Describes default filtering parameters that can be used.
 * When pagination parameters are not specified, default values are set.
 */ var FilteringParameters = /** @class */ function() {
    function FilteringParameters(count, offset) {
        if (count === void 0) {
            count = 100;
        }
        if (offset === void 0) {
            offset = 0;
        }
        this.count = count;
        this.offset = offset;
    }
    return FilteringParameters;
}();
exports.FilteringParameters = FilteringParameters; //# sourceMappingURL=FilteringParameters.js.map


/***/ }),

/***/ 21868:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

var __assign = (void 0) && (void 0).__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.HttpClient = void 0;
var HttpClient = /** @class */ function() {
    function HttpClient(configOptions) {
        this.clientOptions = __assign(__assign({}, HttpClient.DefaultOptions), configOptions);
        this.initHttpClient(this.clientOptions);
    }
    HttpClient.prototype.getBaseHttpRequestURL = function() {
        var scheme = this.clientOptions.useHttps ? "https" : "http";
        return "".concat(scheme, "://").concat(this.clientOptions.requestHost);
    };
    /**
     * Http Client connection configuration options.
     * You may modify these values and new clients will use them.
     * Any values provided to a Client constructor will override default options.
     */ HttpClient.DefaultOptions = {
        useHttps: true,
        requestHost: "api.postmarkapp.com",
        timeout: 180
    };
    return HttpClient;
}();
exports.HttpClient = HttpClient; //# sourceMappingURL=HttpClient.js.map


/***/ }),

/***/ 96266:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
})); //# sourceMappingURL=SupportingTypes.js.map


/***/ }),

/***/ 87056:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.UpdateDomainRequest = exports.CreateDomainRequest = void 0;
var CreateDomainRequest = /** @class */ function() {
    function CreateDomainRequest(Name, ReturnPathDomain) {
        this.Name = Name;
        this.ReturnPathDomain = ReturnPathDomain;
    }
    return CreateDomainRequest;
}();
exports.CreateDomainRequest = CreateDomainRequest;
var UpdateDomainRequest = /** @class */ function() {
    function UpdateDomainRequest(ReturnPathDomain) {
        this.ReturnPathDomain = ReturnPathDomain;
    }
    return UpdateDomainRequest;
}();
exports.UpdateDomainRequest = UpdateDomainRequest; //# sourceMappingURL=Domain.js.map


/***/ }),

/***/ 98159:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = (void 0) && (void 0).__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
__exportStar(__webpack_require__(84733), exports);
__exportStar(__webpack_require__(96266), exports);
__exportStar(__webpack_require__(21868), exports);
__exportStar(__webpack_require__(48438), exports);
__exportStar(__webpack_require__(3328), exports);
__exportStar(__webpack_require__(75858), exports);
__exportStar(__webpack_require__(83522), exports);
__exportStar(__webpack_require__(65801), exports);
__exportStar(__webpack_require__(68312), exports);
__exportStar(__webpack_require__(66427), exports);
__exportStar(__webpack_require__(26918), exports);
__exportStar(__webpack_require__(52362), exports);
__exportStar(__webpack_require__(35176), exports);
__exportStar(__webpack_require__(11682), exports);
__exportStar(__webpack_require__(36510), exports);
__exportStar(__webpack_require__(8496), exports);
__exportStar(__webpack_require__(45116), exports);
__exportStar(__webpack_require__(71695), exports);
__exportStar(__webpack_require__(83415), exports);
__exportStar(__webpack_require__(87056), exports);
__exportStar(__webpack_require__(25050), exports);
__exportStar(__webpack_require__(74736), exports);
__exportStar(__webpack_require__(5786), exports);
__exportStar(__webpack_require__(39586), exports);
__exportStar(__webpack_require__(24931), exports);
__exportStar(__webpack_require__(37598), exports);
__exportStar(__webpack_require__(25584), exports);
__exportStar(__webpack_require__(85733), exports);
__exportStar(__webpack_require__(74736), exports);
__exportStar(__webpack_require__(27425), exports);
__exportStar(__webpack_require__(13122), exports); //# sourceMappingURL=index.js.map


/***/ }),

/***/ 68312:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.Message = void 0;
var Message = /** @class */ function() {
    function Message(From, Subject, HtmlBody, TextBody, To, Cc, Bcc, ReplyTo, Tag, TrackOpens, TrackLinks, Headers, Attachments, Metadata) {
        this.From = From;
        this.To = To;
        this.Cc = Cc;
        this.Bcc = Bcc;
        this.Subject = Subject;
        this.ReplyTo = ReplyTo;
        this.HtmlBody = HtmlBody;
        this.TextBody = TextBody;
        this.Tag = Tag;
        this.TrackOpens = TrackOpens;
        this.TrackLinks = TrackLinks;
        this.Headers = Headers;
        this.Attachments = Attachments;
        this.Metadata = Metadata;
    }
    return Message;
}();
exports.Message = Message; //# sourceMappingURL=Message.js.map


/***/ }),

/***/ 66427:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.Attachment = exports.Header = exports.ServerDeliveryTypes = exports.LinkClickLocation = exports.LinkTrackingOptions = void 0;
var LinkTrackingOptions;
(function(LinkTrackingOptions) {
    LinkTrackingOptions["TextOnly"] = "TextOnly";
    LinkTrackingOptions["HtmlOnly"] = "HtmlOnly";
    LinkTrackingOptions["HtmlAndText"] = "HtmlAndText";
    LinkTrackingOptions["None"] = "None";
})(LinkTrackingOptions = exports.LinkTrackingOptions || (exports.LinkTrackingOptions = {}));
var LinkClickLocation;
(function(LinkClickLocation) {
    LinkClickLocation["HTML"] = "HTML";
    LinkClickLocation["Text"] = "Text";
})(LinkClickLocation = exports.LinkClickLocation || (exports.LinkClickLocation = {}));
var ServerDeliveryTypes;
(function(ServerDeliveryTypes) {
    ServerDeliveryTypes["Live"] = "Live";
    ServerDeliveryTypes["Sandbox"] = "Sandbox";
})(ServerDeliveryTypes = exports.ServerDeliveryTypes || (exports.ServerDeliveryTypes = {}));
var Header = /** @class */ function() {
    function Header(Name, Value) {
        this.Name = Name;
        this.Value = Value;
    }
    return Header;
}();
exports.Header = Header;
/**
 * Attachment content
 *
 * @param Name - name of the attachment, for example book.pdf
 * @param Content - Base64 encoded content, for example: fs.readFileSync('/Folder/book.pdf').toString('base64')
 * @param ContentID - id of the attachment, in case we are referencing it, for example: cid:123book.pdf
 * @param ContentType - content type (json, image, etc)
 * @param ContentLength - length of the message
 */ var Attachment = /** @class */ function() {
    function Attachment(Name, Content, ContentType, ContentID, ContentLength) {
        if (ContentID === void 0) {
            ContentID = null;
        }
        this.Name = Name;
        this.Content = Content;
        this.ContentType = ContentType;
        this.ContentID = ContentID;
        this.ContentLength = ContentLength;
    }
    return Attachment;
}();
exports.Attachment = Attachment; //# sourceMappingURL=SupportingTypes.js.map


/***/ }),

/***/ 11682:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
})); //# sourceMappingURL=InboundMessage.js.map


/***/ }),

/***/ 36510:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.OutboundMessageClicksFilteringParameters = exports.OutboundMessageOpensFilteringParameters = exports.OutboundMessageTrackingFilteringParameters = exports.InboundMessagesFilteringParameters = exports.OutboundMessagesFilteringParameters = exports.InboundMessageStatus = exports.OutboundMessageStatus = void 0;
var FilteringParameters_1 = __webpack_require__(75858);
var OutboundMessageStatus;
(function(OutboundMessageStatus) {
    OutboundMessageStatus["Queued"] = "queued";
    OutboundMessageStatus["Sent"] = "sent";
    OutboundMessageStatus["Processed"] = "processed";
})(OutboundMessageStatus = exports.OutboundMessageStatus || (exports.OutboundMessageStatus = {}));
var InboundMessageStatus;
(function(InboundMessageStatus) {
    InboundMessageStatus["Queued"] = "queued";
    InboundMessageStatus["Sent"] = "sent";
    InboundMessageStatus["Processed"] = "processed";
    InboundMessageStatus["Blocked"] = "blocked";
    InboundMessageStatus["Failed"] = "failed";
    InboundMessageStatus["Scheduled"] = "scheduled";
})(InboundMessageStatus = exports.InboundMessageStatus || (exports.InboundMessageStatus = {}));
/**
 * Describes filtering parameters that can be used when retrieving outbound messages.
 * When pagination parameters are not specified, default values are set.
 */ var OutboundMessagesFilteringParameters = /** @class */ function(_super) {
    __extends(OutboundMessagesFilteringParameters, _super);
    function OutboundMessagesFilteringParameters(count, offset, recipient, fromEmail, tag, status, fromDate, toDate, subject, messageStream) {
        if (count === void 0) {
            count = 100;
        }
        if (offset === void 0) {
            offset = 0;
        }
        var _this = _super.call(this, count, offset) || this;
        _this.recipient = recipient;
        _this.fromEmail = fromEmail;
        _this.tag = tag;
        _this.status = status;
        _this.fromDate = fromDate;
        _this.toDate = toDate;
        _this.subject = subject;
        _this.messageStream = messageStream;
        return _this;
    }
    return OutboundMessagesFilteringParameters;
}(FilteringParameters_1.FilteringParameters);
exports.OutboundMessagesFilteringParameters = OutboundMessagesFilteringParameters;
/**
 * Describes filtering parameters that can be used when retrieving inbound messages.
 * When pagination parameters are not specified, default values are set.
 */ var InboundMessagesFilteringParameters = /** @class */ function(_super) {
    __extends(InboundMessagesFilteringParameters, _super);
    function InboundMessagesFilteringParameters(count, offset, mailboxHash, recipient, fromEmail, tag, status, fromDate, toDate, subject) {
        if (count === void 0) {
            count = 100;
        }
        if (offset === void 0) {
            offset = 0;
        }
        var _this = _super.call(this, count, offset) || this;
        _this.status = status;
        _this.mailboxHash = mailboxHash;
        _this.recipient = recipient;
        _this.fromEmail = fromEmail;
        _this.tag = tag;
        _this.fromDate = fromDate;
        _this.toDate = toDate;
        _this.subject = subject;
        return _this;
    }
    return InboundMessagesFilteringParameters;
}(FilteringParameters_1.FilteringParameters);
exports.InboundMessagesFilteringParameters = InboundMessagesFilteringParameters;
/**
 * Describes filtering parameters that can be used when retrieving tracked outbound messages.
 * When pagination parameters are not specified, default values are set.
 */ var OutboundMessageTrackingFilteringParameters = /** @class */ function(_super) {
    __extends(OutboundMessageTrackingFilteringParameters, _super);
    function OutboundMessageTrackingFilteringParameters(count, offset, recipient, tag, client_name, client_company, client_family, os_name, os_family, os_company, platform, country, region, city, messageStream) {
        if (count === void 0) {
            count = 100;
        }
        if (offset === void 0) {
            offset = 0;
        }
        var _this = _super.call(this, count, offset) || this;
        _this.recipient = recipient;
        _this.tag = tag;
        _this.client_name = client_name;
        _this.client_company = client_company;
        _this.client_family = client_family;
        _this.os_name = os_name;
        _this.os_family = os_family;
        _this.os_company = os_company;
        _this.platform = platform;
        _this.country = country;
        _this.region = region;
        _this.city = city;
        _this.messageStream = messageStream;
        return _this;
    }
    return OutboundMessageTrackingFilteringParameters;
}(FilteringParameters_1.FilteringParameters);
exports.OutboundMessageTrackingFilteringParameters = OutboundMessageTrackingFilteringParameters;
var OutboundMessageOpensFilteringParameters = /** @class */ function(_super) {
    __extends(OutboundMessageOpensFilteringParameters, _super);
    function OutboundMessageOpensFilteringParameters() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return OutboundMessageOpensFilteringParameters;
}(OutboundMessageTrackingFilteringParameters);
exports.OutboundMessageOpensFilteringParameters = OutboundMessageOpensFilteringParameters;
var OutboundMessageClicksFilteringParameters = /** @class */ function(_super) {
    __extends(OutboundMessageClicksFilteringParameters, _super);
    function OutboundMessageClicksFilteringParameters() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return OutboundMessageClicksFilteringParameters;
}(OutboundMessageTrackingFilteringParameters);
exports.OutboundMessageClicksFilteringParameters = OutboundMessageClicksFilteringParameters; //# sourceMappingURL=MessageFilteringParameters.js.map


/***/ }),

/***/ 26918:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
})); //# sourceMappingURL=OutboundMessage.js.map


/***/ }),

/***/ 35176:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
})); //# sourceMappingURL=OutboundMessageClick.js.map


/***/ }),

/***/ 52362:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
})); //# sourceMappingURL=OutboundMessageOpen.js.map


/***/ }),

/***/ 25050:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.CreateSignatureRequest = exports.UpdateSignatureRequest = void 0;
var UpdateSignatureRequest = /** @class */ function() {
    function UpdateSignatureRequest(Name, ReplyToEmail, ReturnPathDomain, ConfirmationPersonalNote) {
        this.Name = Name;
        this.ReplyToEmail = ReplyToEmail;
        this.ReturnPathDomain = ReturnPathDomain;
        this.ConfirmationPersonalNote = ConfirmationPersonalNote;
    }
    return UpdateSignatureRequest;
}();
exports.UpdateSignatureRequest = UpdateSignatureRequest;
var CreateSignatureRequest = /** @class */ function() {
    function CreateSignatureRequest(Name, FromEmail, ReplyToEmail, ReturnPathDomain, ConfirmationPersonalNote) {
        this.Name = Name;
        this.ReplyToEmail = ReplyToEmail;
        this.ReturnPathDomain = ReturnPathDomain;
        this.FromEmail = FromEmail;
        this.ConfirmationPersonalNote = ConfirmationPersonalNote;
    }
    return CreateSignatureRequest;
}();
exports.CreateSignatureRequest = CreateSignatureRequest; //# sourceMappingURL=Signature.js.map


/***/ }),

/***/ 45116:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.CreateServerRequest = exports.UpdateServerRequest = void 0;
var UpdateServerRequest = /** @class */ function() {
    function UpdateServerRequest(Name, Color, SmtpApiActivated, RawEmailEnabled, InboundHookUrl, BounceHookUrl, OpenHookUrl, DeliveryHookUrl, ClickHookUrl, PostFirstOpenOnly, InboundSpamThreshold, TrackOpens, TrackLinks, IncludeBounceContentInHook, EnableSmtpApiErrorHooks, InboundDomain) {
        this.Name = Name;
        this.Color = Color;
        this.SmtpApiActivated = SmtpApiActivated;
        this.RawEmailEnabled = RawEmailEnabled;
        this.InboundHookUrl = InboundHookUrl;
        this.BounceHookUrl = BounceHookUrl;
        this.OpenHookUrl = OpenHookUrl;
        this.DeliveryHookUrl = DeliveryHookUrl;
        this.ClickHookUrl = ClickHookUrl;
        this.PostFirstOpenOnly = PostFirstOpenOnly;
        this.InboundSpamThreshold = InboundSpamThreshold;
        this.InboundDomain = InboundDomain;
        this.TrackOpens = TrackOpens;
        this.TrackLinks = TrackLinks;
        this.IncludeBounceContentInHook = IncludeBounceContentInHook;
        this.EnableSmtpApiErrorHooks = EnableSmtpApiErrorHooks;
    }
    return UpdateServerRequest;
}();
exports.UpdateServerRequest = UpdateServerRequest;
var CreateServerRequest = /** @class */ function(_super) {
    __extends(CreateServerRequest, _super);
    function CreateServerRequest(Name, Color, SmtpApiActivated, RawEmailEnabled, InboundHookUrl, BounceHookUrl, OpenHookUrl, DeliveryHookUrl, ClickHookUrl, PostFirstOpenOnly, InboundSpamThreshold, TrackOpens, TrackLinks, IncludeBounceContentInHook, EnableSmtpApiErrorHooks, InboundDomain, DeliveryType) {
        var _this = _super.call(this, Name, Color, SmtpApiActivated, RawEmailEnabled, InboundHookUrl, BounceHookUrl, OpenHookUrl, DeliveryHookUrl, ClickHookUrl, PostFirstOpenOnly, InboundSpamThreshold, TrackOpens, TrackLinks, IncludeBounceContentInHook, EnableSmtpApiErrorHooks, InboundDomain) || this;
        _this.DeliveryType = DeliveryType;
        return _this;
    }
    return CreateServerRequest;
}(UpdateServerRequest);
exports.CreateServerRequest = CreateServerRequest; //# sourceMappingURL=Server.js.map


/***/ }),

/***/ 83415:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ServerFilteringParameters = void 0;
var FilteringParameters_1 = __webpack_require__(75858);
/**
 * Describes filtering parameters that can be used when retrieving servers.
 * When pagination parameters are not specified, default values are set.
 */ var ServerFilteringParameters = /** @class */ function(_super) {
    __extends(ServerFilteringParameters, _super);
    function ServerFilteringParameters(count, offset, name) {
        if (count === void 0) {
            count = 100;
        }
        if (offset === void 0) {
            offset = 0;
        }
        var _this = _super.call(this, count, offset) || this;
        _this.name = name;
        return _this;
    }
    return ServerFilteringParameters;
}(FilteringParameters_1.FilteringParameters);
exports.ServerFilteringParameters = ServerFilteringParameters; //# sourceMappingURL=ServerFilteringParameters.js.map


/***/ }),

/***/ 71695:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
})); //# sourceMappingURL=Servers.js.map


/***/ }),

/***/ 5786:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
})); //# sourceMappingURL=Stats.js.map


/***/ }),

/***/ 39586:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.StatisticsFilteringParameters = void 0;
var StatisticsFilteringParameters = /** @class */ function() {
    function StatisticsFilteringParameters(tag, fromDate, toDate, messageStream) {
        this.tag = tag;
        this.fromDate = fromDate;
        this.toDate = toDate;
        this.messageStream = messageStream;
    }
    return StatisticsFilteringParameters;
}();
exports.StatisticsFilteringParameters = StatisticsFilteringParameters; //# sourceMappingURL=StatsFilteringParameters.js.map


/***/ }),

/***/ 27425:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.CreateMessageStreamRequest = exports.UpdateMessageStreamRequest = exports.UnsubscribeHandlingTypes = void 0;
var UnsubscribeHandlingTypes;
(function(UnsubscribeHandlingTypes) {
    UnsubscribeHandlingTypes["None"] = "None";
    UnsubscribeHandlingTypes["Postmark"] = "Postmark";
    UnsubscribeHandlingTypes["Custom"] = "Custom";
})(UnsubscribeHandlingTypes = exports.UnsubscribeHandlingTypes || (exports.UnsubscribeHandlingTypes = {}));
var UpdateMessageStreamRequest = /** @class */ function() {
    function UpdateMessageStreamRequest(name, description, subscriptionManagementConfiguration) {
        this.Name = name;
        this.Description = description;
        this.SubscriptionManagementConfiguration = subscriptionManagementConfiguration;
    }
    return UpdateMessageStreamRequest;
}();
exports.UpdateMessageStreamRequest = UpdateMessageStreamRequest;
var CreateMessageStreamRequest = /** @class */ function() {
    function CreateMessageStreamRequest(id, name, messageStreamType, description, subscriptionManagementConfiguration) {
        this.Name = name;
        this.Description = description;
        this.ID = id;
        this.MessageStreamType = messageStreamType;
        this.SubscriptionManagementConfiguration = subscriptionManagementConfiguration;
    }
    return CreateMessageStreamRequest;
}();
exports.CreateMessageStreamRequest = CreateMessageStreamRequest; //# sourceMappingURL=MessageStream.js.map


/***/ }),

/***/ 13122:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.MessageStreamsFilteringParameters = void 0;
/**
 * Describes filtering parameters that can be used when retrieving message streams.
 */ var MessageStreamsFilteringParameters = /** @class */ function() {
    function MessageStreamsFilteringParameters(messageStreamType, includeArchivedStreams) {
        this.messageStreamType = messageStreamType;
        this.includeArchivedStreams = includeArchivedStreams;
    }
    return MessageStreamsFilteringParameters;
}();
exports.MessageStreamsFilteringParameters = MessageStreamsFilteringParameters; //# sourceMappingURL=MessageStreamsFilteringParameters.js.map


/***/ }),

/***/ 74736:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
})); //# sourceMappingURL=Suppression.js.map


/***/ }),

/***/ 8496:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.TemplateFilteringParameters = exports.TemplatedMessage = exports.TemplatesPushRequest = exports.TemplateTypes = exports.TemplateValidationOptions = exports.CreateTemplateRequest = exports.UpdateTemplateRequest = void 0;
var FilteringParameters_1 = __webpack_require__(75858);
var UpdateTemplateRequest = /** @class */ function() {
    function UpdateTemplateRequest(Name, Subject, HtmlBody, TextBody, Alias, TemplateType, LayoutTemplate) {
        this.Name = Name;
        this.Subject = Subject;
        this.HtmlBody = HtmlBody;
        this.TextBody = TextBody;
        this.Alias = Alias;
        this.LayoutTemplate = LayoutTemplate;
        this.TemplateType = TemplateType;
    }
    return UpdateTemplateRequest;
}();
exports.UpdateTemplateRequest = UpdateTemplateRequest;
var CreateTemplateRequest = /** @class */ function(_super) {
    __extends(CreateTemplateRequest, _super);
    function CreateTemplateRequest(Name, Subject, HtmlBody, TextBody, Alias, TemplateType, LayoutTemplate) {
        return _super.call(this, Name, Subject, HtmlBody, TextBody, Alias, TemplateType, LayoutTemplate) || this;
    }
    return CreateTemplateRequest;
}(UpdateTemplateRequest);
exports.CreateTemplateRequest = CreateTemplateRequest;
var TemplateValidationOptions = /** @class */ function() {
    function TemplateValidationOptions(Subject, HtmlBody, TextBody, TestRenderModel, TemplateType, LayoutTemplate, InlineCssForHtmlTestRender) {
        this.Subject = Subject;
        this.HtmlBody = HtmlBody;
        this.TextBody = TextBody;
        this.TestRenderModel = TestRenderModel;
        this.TemplateType = TemplateType;
        this.LayoutTemplate = LayoutTemplate;
        this.InlineCssForHtmlTestRender = InlineCssForHtmlTestRender;
    }
    return TemplateValidationOptions;
}();
exports.TemplateValidationOptions = TemplateValidationOptions;
var TemplateTypes;
(function(TemplateTypes) {
    TemplateTypes["Standard"] = "Standard";
    TemplateTypes["Layout"] = "Layout";
})(TemplateTypes = exports.TemplateTypes || (exports.TemplateTypes = {}));
var TemplatesPushRequest = /** @class */ function() {
    function TemplatesPushRequest(SourceServerID, DestinationServerID, PerformChanges) {
        this.SourceServerID = SourceServerID;
        this.DestinationServerID = DestinationServerID;
        this.PerformChanges = PerformChanges;
    }
    return TemplatesPushRequest;
}();
exports.TemplatesPushRequest = TemplatesPushRequest;
var TemplatedMessage = /** @class */ function() {
    function TemplatedMessage(from, templateIdOrAlias, templateModel, to, cc, bcc, replyTo, tag, trackOpens, trackLinks, headers, attachments) {
        this.From = from;
        this.TemplateModel = templateModel;
        if (typeof templateIdOrAlias === "number") {
            this.TemplateId = templateIdOrAlias;
        } else {
            this.TemplateAlias = templateIdOrAlias;
        }
        this.To = to;
        this.Cc = cc;
        this.Bcc = bcc;
        this.ReplyTo = replyTo;
        this.Tag = tag;
        this.TrackOpens = trackOpens;
        this.TrackLinks = trackLinks;
        this.Headers = headers;
        this.Attachments = attachments;
    }
    return TemplatedMessage;
}();
exports.TemplatedMessage = TemplatedMessage;
/**
 * Describes filtering parameters that can be used when retrieving templates.
 * When pagination parameters are not specified, default values are set.
 */ var TemplateFilteringParameters = /** @class */ function(_super) {
    __extends(TemplateFilteringParameters, _super);
    function TemplateFilteringParameters(count, offset, templateType, layoutTemplate) {
        if (count === void 0) {
            count = 100;
        }
        if (offset === void 0) {
            offset = 0;
        }
        var _this = _super.call(this, count, offset) || this;
        _this.templateType = templateType;
        _this.layoutTemplate = layoutTemplate;
        return _this;
    }
    return TemplateFilteringParameters;
}(FilteringParameters_1.FilteringParameters);
exports.TemplateFilteringParameters = TemplateFilteringParameters; //# sourceMappingURL=Template.js.map


/***/ }),

/***/ 24931:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.CreateInboundRuleRequest = void 0;
var CreateInboundRuleRequest = /** @class */ function() {
    function CreateInboundRuleRequest(Rule) {
        this.Rule = Rule;
    }
    return CreateInboundRuleRequest;
}();
exports.CreateInboundRuleRequest = CreateInboundRuleRequest; //# sourceMappingURL=InboundRule.js.map


/***/ }),

/***/ 25584:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.CreateWebhookRequest = exports.UpdateWebhookRequest = void 0;
var UpdateWebhookRequest = /** @class */ function() {
    function UpdateWebhookRequest(url, triggers, httpAuth, httpHeaders) {
        this.Url = url;
        this.HttpAuth = httpAuth;
        this.HttpHeaders = httpHeaders;
        this.Triggers = triggers;
    }
    return UpdateWebhookRequest;
}();
exports.UpdateWebhookRequest = UpdateWebhookRequest;
var CreateWebhookRequest = /** @class */ function(_super) {
    __extends(CreateWebhookRequest, _super);
    function CreateWebhookRequest(url, triggers, httpAuth, httpHeaders, messageStream) {
        var _this = _super.call(this, url, triggers, httpAuth, httpHeaders) || this;
        _this.MessageStream = messageStream;
        return _this;
    }
    return CreateWebhookRequest;
}(UpdateWebhookRequest);
exports.CreateWebhookRequest = CreateWebhookRequest; //# sourceMappingURL=Webhook.js.map


/***/ }),

/***/ 85733:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.WebhookFilteringParameters = void 0;
/**
 * Describes filtering parameters that can be used when retrieving webhooks.
 */ var WebhookFilteringParameters = /** @class */ function() {
    function WebhookFilteringParameters(messageStream) {
        this.messageStream = messageStream;
    }
    return WebhookFilteringParameters;
}();
exports.WebhookFilteringParameters = WebhookFilteringParameters; //# sourceMappingURL=WebhookFilteringParameters.js.map


/***/ }),

/***/ 37598:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
})); //# sourceMappingURL=Webhooks.js.map


/***/ }),

/***/ 3780:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({
    value: true
});
__webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = exports.KU = __webpack_unused_export__ = void 0;
var AccountClient_1 = __webpack_require__(81557);
__webpack_unused_export__ = AccountClient_1.default;
__webpack_unused_export__ = AccountClient_1.default;
var ServerClient_1 = __webpack_require__(71544);
__webpack_unused_export__ = ServerClient_1.default;
exports.KU = ServerClient_1.default;
var Models = __webpack_require__(98159);
__webpack_unused_export__ = Models;
var Errors = __webpack_require__(54428);
__webpack_unused_export__ = Errors;
// Essential types are exposed directly
// to make working with common requests simpler.
var models_1 = __webpack_require__(98159);
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return models_1.Message;
    }
});
var models_2 = __webpack_require__(98159);
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return models_2.TemplatedMessage;
    }
});
var models_3 = __webpack_require__(98159);
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return models_3.Attachment;
    }
});
var models_4 = __webpack_require__(98159);
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return models_4.Header;
    }
}); //# sourceMappingURL=index.js.map


/***/ }),

/***/ 63093:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "render": () => (/* binding */ S),
/* harmony export */   "renderToStaticMarkup": () => (/* binding */ S),
/* harmony export */   "renderToString": () => (/* binding */ S),
/* harmony export */   "shallowRender": () => (/* binding */ x)
/* harmony export */ });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30066);

var n = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|^--/i, o = /^(area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr)$/, i = /[\s\n\\/='"\0<>]/, l = /^xlink:?./, a = /["&<]/;
function s(e) {
    if (!1 === a.test(e += "")) return e;
    for(var t = 0, r = 0, n = "", o = ""; r < e.length; r++){
        switch(e.charCodeAt(r)){
            case 34:
                o = "&quot;";
                break;
            case 38:
                o = "&amp;";
                break;
            case 60:
                o = "&lt;";
                break;
            default:
                continue;
        }
        r !== t && (n += e.slice(t, r)), n += o, t = r + 1;
    }
    return r !== t && (n += e.slice(t, r)), n;
}
var f = function(e, t) {
    return String(e).replace(/(\n+)/g, "$1" + (t || "	"));
}, u = function(e, t, r) {
    return String(e).length > (t || 40) || !r && -1 !== String(e).indexOf("\n") || -1 !== String(e).indexOf("<");
}, c = {}, _ = /([A-Z])/g;
function p(e) {
    var t = "";
    for(var r in e){
        var o = e[r];
        null != o && "" !== o && (t && (t += " "), t += "-" == r[0] ? r : c[r] || (c[r] = r.replace(_, "-$1").toLowerCase()), t = "number" == typeof o && !1 === n.test(r) ? t + ": " + o + "px;" : t + ": " + o + ";");
    }
    return t || void 0;
}
function d(e, t) {
    return Array.isArray(t) ? t.reduce(d, e) : null != t && !1 !== t && e.push(t), e;
}
function v() {
    this.__d = !0;
}
function h(e, t) {
    return {
        __v: e,
        context: t,
        props: e.props,
        setState: v,
        forceUpdate: v,
        __d: !0,
        __h: []
    };
}
function g(e, t) {
    var r = e.contextType, n = r && t[r.__c];
    return null != r ? n ? n.props.value : r.__ : t;
}
var y = [];
function m(r, n, a, c, _, v) {
    if (null == r || "boolean" == typeof r) return "";
    if ("object" != typeof r) return "function" == typeof r ? "" : s(r);
    var b = a.pretty, x = b && "string" == typeof b ? b : "	";
    if (Array.isArray(r)) {
        for(var k = "", S = 0; S < r.length; S++)b && S > 0 && (k += "\n"), k += m(r[S], n, a, c, _, v);
        return k;
    }
    if (void 0 !== r.constructor) return "";
    var w, C = r.type, O = r.props, j = !1;
    if ("function" == typeof C) {
        if (j = !0, !a.shallow || !c && !1 !== a.renderRootComponent) {
            if (C === preact__WEBPACK_IMPORTED_MODULE_0__.Fragment) {
                var A = [];
                return d(A, r.props.children), m(A, n, a, !1 !== a.shallowHighOrder, _, v);
            }
            var F, H = r.__c = h(r, n);
            preact__WEBPACK_IMPORTED_MODULE_0__.options.__b && preact__WEBPACK_IMPORTED_MODULE_0__.options.__b(r);
            var M = preact__WEBPACK_IMPORTED_MODULE_0__.options.__r;
            if (C.prototype && "function" == typeof C.prototype.render) {
                var L = g(C, n);
                (H = r.__c = new C(O, L)).__v = r, H._dirty = H.__d = !0, H.props = O, null == H.state && (H.state = {}), null == H._nextState && null == H.__s && (H._nextState = H.__s = H.state), H.context = L, C.getDerivedStateFromProps ? H.state = Object.assign({}, H.state, C.getDerivedStateFromProps(H.props, H.state)) : H.componentWillMount && (H.componentWillMount(), H.state = H._nextState !== H.state ? H._nextState : H.__s !== H.state ? H.__s : H.state), M && M(r), F = H.render(H.props, H.state, H.context);
            } else for(var T = g(C, n), E = 0; H.__d && E++ < 25;)H.__d = !1, M && M(r), F = C.call(r.__c, O, T);
            return H.getChildContext && (n = Object.assign({}, n, H.getChildContext())), preact__WEBPACK_IMPORTED_MODULE_0__.options.diffed && preact__WEBPACK_IMPORTED_MODULE_0__.options.diffed(r), m(F, n, a, !1 !== a.shallowHighOrder, _, v);
        }
        C = (w = C).displayName || w !== Function && w.name || function(e) {
            var t = (Function.prototype.toString.call(e).match(/^\s*function\s+([^( ]+)/) || "")[1];
            if (!t) {
                for(var r = -1, n = y.length; n--;)if (y[n] === e) {
                    r = n;
                    break;
                }
                r < 0 && (r = y.push(e) - 1), t = "UnnamedComponent" + r;
            }
            return t;
        }(w);
    }
    var $, D, N = "<" + C;
    if (O) {
        var P = Object.keys(O);
        a && !0 === a.sortAttributes && P.sort();
        for(var W = 0; W < P.length; W++){
            var I = P[W], R = O[I];
            if ("children" !== I) {
                if (!i.test(I) && (a && a.allAttributes || "key" !== I && "ref" !== I && "__self" !== I && "__source" !== I)) {
                    if ("defaultValue" === I) I = "value";
                    else if ("defaultChecked" === I) I = "checked";
                    else if ("defaultSelected" === I) I = "selected";
                    else if ("className" === I) {
                        if (void 0 !== O.class) continue;
                        I = "class";
                    } else _ && l.test(I) && (I = I.toLowerCase().replace(/^xlink:?/, "xlink:"));
                    if ("htmlFor" === I) {
                        if (O.for) continue;
                        I = "for";
                    }
                    "style" === I && R && "object" == typeof R && (R = p(R)), "a" === I[0] && "r" === I[1] && "boolean" == typeof R && (R = String(R));
                    var U = a.attributeHook && a.attributeHook(I, R, n, a, j);
                    if (U || "" === U) N += U;
                    else if ("dangerouslySetInnerHTML" === I) D = R && R.__html;
                    else if ("textarea" === C && "value" === I) $ = R;
                    else if ((R || 0 === R || "" === R) && "function" != typeof R) {
                        if (!(!0 !== R && "" !== R || (R = I, a && a.xml))) {
                            N = N + " " + I;
                            continue;
                        }
                        if ("value" === I) {
                            if ("select" === C) {
                                v = R;
                                continue;
                            }
                            "option" === C && v == R && void 0 === O.selected && (N += " selected");
                        }
                        N = N + " " + I + '="' + s(R) + '"';
                    }
                }
            } else $ = R;
        }
    }
    if (b) {
        var V = N.replace(/\n\s*/, " ");
        V === N || ~V.indexOf("\n") ? b && ~N.indexOf("\n") && (N += "\n") : N = V;
    }
    if (N += ">", i.test(C)) throw new Error(C + " is not a valid HTML tag name in " + N);
    var q, z = o.test(C) || a.voidElements && a.voidElements.test(C), Z = [];
    if (D) b && u(D) && (D = "\n" + x + f(D, x)), N += D;
    else if (null != $ && d(q = [], $).length) {
        for(var B = b && ~N.indexOf("\n"), G = !1, J = 0; J < q.length; J++){
            var K = q[J];
            if (null != K && !1 !== K) {
                var Q = m(K, n, a, !0, "svg" === C || "foreignObject" !== C && _, v);
                if (b && !B && u(Q) && (B = !0), Q) if (b) {
                    var X = Q.length > 0 && "<" != Q[0];
                    G && X ? Z[Z.length - 1] += Q : Z.push(Q), G = X;
                } else Z.push(Q);
            }
        }
        if (b && B) for(var Y = Z.length; Y--;)Z[Y] = "\n" + x + f(Z[Y], x);
    }
    if (Z.length || D) N += Z.join("");
    else if (a && a.xml) return N.substring(0, N.length - 1) + " />";
    return !z || q || D ? (b && ~N.indexOf("\n") && (N += "\n"), N = N + "</" + C + ">") : N = N.replace(/>$/, " />"), N;
}
var b = {
    shallow: !0
};
S.render = S;
var x = function(e, t) {
    return S(e, t, b);
}, k = [];
function S(n, o, i) {
    o = o || {};
    var l = preact__WEBPACK_IMPORTED_MODULE_0__.options.__s;
    preact__WEBPACK_IMPORTED_MODULE_0__.options.__s = !0;
    var a, s = (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment, null);
    return s.__k = [
        n
    ], a = i && (i.pretty || i.voidElements || i.sortAttributes || i.shallow || i.allAttributes || i.xml || i.attributeHook) ? m(n, o, i) : F(n, o, !1, void 0, s), preact__WEBPACK_IMPORTED_MODULE_0__.options.__c && preact__WEBPACK_IMPORTED_MODULE_0__.options.__c(n, k), preact__WEBPACK_IMPORTED_MODULE_0__.options.__s = l, k.length = 0, a;
}
function w(e) {
    return null == e || "boolean" == typeof e ? null : "string" == typeof e || "number" == typeof e || "bigint" == typeof e ? (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(null, null, e) : e;
}
function C(e, t) {
    return "className" === e ? "class" : "htmlFor" === e ? "for" : "defaultValue" === e ? "value" : "defaultChecked" === e ? "checked" : "defaultSelected" === e ? "selected" : t && l.test(e) ? e.toLowerCase().replace(/^xlink:?/, "xlink:") : e;
}
function O(e, t) {
    return "style" === e && null != t && "object" == typeof t ? p(t) : "a" === e[0] && "r" === e[1] && "boolean" == typeof t ? String(t) : t;
}
var j = Array.isArray, A = Object.assign;
function F(r, n, l, a, f) {
    if (null == r || !0 === r || !1 === r || "" === r) return "";
    if ("object" != typeof r) return "function" == typeof r ? "" : s(r);
    if (j(r)) {
        var u = "";
        f.__k = r;
        for(var c = 0; c < r.length; c++)u += F(r[c], n, l, a, f), r[c] = w(r[c]);
        return u;
    }
    if (void 0 !== r.constructor) return "";
    r.__ = f, preact__WEBPACK_IMPORTED_MODULE_0__.options.__b && preact__WEBPACK_IMPORTED_MODULE_0__.options.__b(r);
    var _ = r.type, p = r.props;
    if ("function" == typeof _) {
        var d;
        if (_ === preact__WEBPACK_IMPORTED_MODULE_0__.Fragment) d = p.children;
        else {
            d = _.prototype && "function" == typeof _.prototype.render ? function(e, r) {
                var n = e.type, o = g(n, r), i = new n(e.props, o);
                e.__c = i, i.__v = e, i.__d = !0, i.props = e.props, null == i.state && (i.state = {}), null == i.__s && (i.__s = i.state), i.context = o, n.getDerivedStateFromProps ? i.state = A({}, i.state, n.getDerivedStateFromProps(i.props, i.state)) : i.componentWillMount && (i.componentWillMount(), i.state = i.__s !== i.state ? i.__s : i.state);
                var l = preact__WEBPACK_IMPORTED_MODULE_0__.options.__r;
                return l && l(e), i.render(i.props, i.state, i.context);
            }(r, n) : function(e, r) {
                var n, o = h(e, r), i = g(e.type, r);
                e.__c = o;
                for(var l = preact__WEBPACK_IMPORTED_MODULE_0__.options.__r, a = 0; o.__d && a++ < 25;)o.__d = !1, l && l(e), n = e.type.call(o, e.props, i);
                return n;
            }(r, n);
            var v = r.__c;
            v.getChildContext && (n = A({}, n, v.getChildContext()));
        }
        var y = F(d = null != d && d.type === preact__WEBPACK_IMPORTED_MODULE_0__.Fragment && null == d.key ? d.props.children : d, n, l, a, r);
        return preact__WEBPACK_IMPORTED_MODULE_0__.options.diffed && preact__WEBPACK_IMPORTED_MODULE_0__.options.diffed(r), r.__ = void 0, preact__WEBPACK_IMPORTED_MODULE_0__.options.unmount && preact__WEBPACK_IMPORTED_MODULE_0__.options.unmount(r), y;
    }
    var m, b, x = "<";
    if (x += _, p) for(var k in m = p.children, p){
        var S = p[k];
        if (!("key" === k || "ref" === k || "__self" === k || "__source" === k || "children" === k || "className" === k && "class" in p || "htmlFor" === k && "for" in p || i.test(k))) {
            if (S = O(k = C(k, l), S), "dangerouslySetInnerHTML" === k) b = S && S.__html;
            else if ("textarea" === _ && "value" === k) m = S;
            else if ((S || 0 === S || "" === S) && "function" != typeof S) {
                if (!0 === S || "" === S) {
                    S = k, x = x + " " + k;
                    continue;
                }
                if ("value" === k) {
                    if ("select" === _) {
                        a = S;
                        continue;
                    }
                    "option" !== _ || a != S || "selected" in p || (x += " selected");
                }
                x = x + " " + k + '="' + s(S) + '"';
            }
        }
    }
    var H = x;
    if (x += ">", i.test(_)) throw new Error(_ + " is not a valid HTML tag name in " + x);
    var M = "", L = !1;
    if (b) M += b, L = !0;
    else if ("string" == typeof m) M += s(m), L = !0;
    else if (j(m)) {
        r.__k = m;
        for(var T = 0; T < m.length; T++){
            var E = m[T];
            if (m[T] = w(E), null != E && !1 !== E) {
                var $ = F(E, n, "svg" === _ || "foreignObject" !== _ && l, a, r);
                $ && (M += $, L = !0);
            }
        }
    } else if (null != m && !1 !== m && !0 !== m) {
        r.__k = [
            w(m)
        ];
        var D = F(m, n, "svg" === _ || "foreignObject" !== _ && l, a, r);
        D && (M += D, L = !0);
    }
    if (preact__WEBPACK_IMPORTED_MODULE_0__.options.diffed && preact__WEBPACK_IMPORTED_MODULE_0__.options.diffed(r), r.__ = void 0, preact__WEBPACK_IMPORTED_MODULE_0__.options.unmount && preact__WEBPACK_IMPORTED_MODULE_0__.options.unmount(r), L) x += M;
    else if (o.test(_)) return H + " />";
    return x + "</" + _ + ">";
}
S.shallowRender = x;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (S);
 //# sourceMappingURL=index.module.js.map


/***/ }),

/***/ 30066:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Component": () => (/* binding */ d),
/* harmony export */   "Fragment": () => (/* binding */ p),
/* harmony export */   "cloneElement": () => (/* binding */ q),
/* harmony export */   "createContext": () => (/* binding */ B),
/* harmony export */   "createElement": () => (/* binding */ h),
/* harmony export */   "createRef": () => (/* binding */ y),
/* harmony export */   "h": () => (/* binding */ h),
/* harmony export */   "hydrate": () => (/* binding */ S),
/* harmony export */   "isValidElement": () => (/* binding */ i),
/* harmony export */   "options": () => (/* binding */ l),
/* harmony export */   "render": () => (/* binding */ P),
/* harmony export */   "toChildArray": () => (/* binding */ x)
/* harmony export */ });
var n, l, u, i, t, o, r, f = {}, e = [], c = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
function s(n, l) {
    for(var u in l)n[u] = l[u];
    return n;
}
function a(n) {
    var l = n.parentNode;
    l && l.removeChild(n);
}
function h(l, u, i) {
    var t, o, r, f = {};
    for(r in u)"key" == r ? t = u[r] : "ref" == r ? o = u[r] : f[r] = u[r];
    if (arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), "function" == typeof l && null != l.defaultProps) for(r in l.defaultProps)void 0 === f[r] && (f[r] = l.defaultProps[r]);
    return v(l, f, t, o, null);
}
function v(n, i, t, o, r) {
    var f = {
        type: n,
        props: i,
        key: t,
        ref: o,
        __k: null,
        __: null,
        __b: 0,
        __e: null,
        __d: void 0,
        __c: null,
        __h: null,
        constructor: void 0,
        __v: null == r ? ++u : r
    };
    return null == r && null != l.vnode && l.vnode(f), f;
}
function y() {
    return {
        current: null
    };
}
function p(n) {
    return n.children;
}
function d(n, l) {
    this.props = n, this.context = l;
}
function _(n, l) {
    if (null == l) return n.__ ? _(n.__, n.__.__k.indexOf(n) + 1) : null;
    for(var u; l < n.__k.length; l++)if (null != (u = n.__k[l]) && null != u.__e) return u.__e;
    return "function" == typeof n.type ? _(n) : null;
}
function k(n) {
    var l, u;
    if (null != (n = n.__) && null != n.__c) {
        for(n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++)if (null != (u = n.__k[l]) && null != u.__e) {
            n.__e = n.__c.base = u.__e;
            break;
        }
        return k(n);
    }
}
function b(n) {
    (!n.__d && (n.__d = !0) && t.push(n) && !g.__r++ || o !== l.debounceRendering) && ((o = l.debounceRendering) || setTimeout)(g);
}
function g() {
    for(var n; g.__r = t.length;)n = t.sort(function(n, l) {
        return n.__v.__b - l.__v.__b;
    }), t = [], n.some(function(n) {
        var l, u, i, t, o, r;
        n.__d && (o = (t = (l = n).__v).__e, (r = l.__P) && (u = [], (i = s({}, t)).__v = t.__v + 1, j(r, t, i, l.__n, void 0 !== r.ownerSVGElement, null != t.__h ? [
            o
        ] : null, u, null == o ? _(t) : o, t.__h), z(u, t), t.__e != o && k(t)));
    });
}
function w(n, l, u, i, t, o, r, c, s, a) {
    var h, y, d, k, b, g, w, x = i && i.__k || e, C = x.length;
    for(u.__k = [], h = 0; h < l.length; h++)if (null != (k = u.__k[h] = null == (k = l[h]) || "boolean" == typeof k ? null : "string" == typeof k || "number" == typeof k || "bigint" == typeof k ? v(null, k, null, null, k) : Array.isArray(k) ? v(p, {
        children: k
    }, null, null, null) : k.__b > 0 ? v(k.type, k.props, k.key, k.ref ? k.ref : null, k.__v) : k)) {
        if (k.__ = u, k.__b = u.__b + 1, null === (d = x[h]) || d && k.key == d.key && k.type === d.type) x[h] = void 0;
        else for(y = 0; y < C; y++){
            if ((d = x[y]) && k.key == d.key && k.type === d.type) {
                x[y] = void 0;
                break;
            }
            d = null;
        }
        j(n, k, d = d || f, t, o, r, c, s, a), b = k.__e, (y = k.ref) && d.ref != y && (w || (w = []), d.ref && w.push(d.ref, null, k), w.push(y, k.__c || b, k)), null != b ? (null == g && (g = b), "function" == typeof k.type && k.__k === d.__k ? k.__d = s = m(k, s, n) : s = A(n, k, d, x, b, s), "function" == typeof u.type && (u.__d = s)) : s && d.__e == s && s.parentNode != n && (s = _(d));
    }
    for(u.__e = g, h = C; h--;)null != x[h] && N(x[h], x[h]);
    if (w) for(h = 0; h < w.length; h++)M(w[h], w[++h], w[++h]);
}
function m(n, l, u) {
    for(var i, t = n.__k, o = 0; t && o < t.length; o++)(i = t[o]) && (i.__ = n, l = "function" == typeof i.type ? m(i, l, u) : A(u, i, i, t, i.__e, l));
    return l;
}
function x(n, l) {
    return l = l || [], null == n || "boolean" == typeof n || (Array.isArray(n) ? n.some(function(n) {
        x(n, l);
    }) : l.push(n)), l;
}
function A(n, l, u, i, t, o) {
    var r, f, e;
    if (void 0 !== l.__d) r = l.__d, l.__d = void 0;
    else if (null == u || t != o || null == t.parentNode) n: if (null == o || o.parentNode !== n) n.appendChild(t), r = null;
    else {
        for(f = o, e = 0; (f = f.nextSibling) && e < i.length; e += 1)if (f == t) break n;
        n.insertBefore(t, o), r = o;
    }
    return void 0 !== r ? r : t.nextSibling;
}
function C(n, l, u, i, t) {
    var o;
    for(o in u)"children" === o || "key" === o || o in l || H(n, o, null, u[o], i);
    for(o in l)t && "function" != typeof l[o] || "children" === o || "key" === o || "value" === o || "checked" === o || u[o] === l[o] || H(n, o, l[o], u[o], i);
}
function $(n, l, u) {
    "-" === l[0] ? n.setProperty(l, u) : n[l] = null == u ? "" : "number" != typeof u || c.test(l) ? u : u + "px";
}
function H(n, l, u, i, t) {
    var o;
    n: if ("style" === l) if ("string" == typeof u) n.style.cssText = u;
    else {
        if ("string" == typeof i && (n.style.cssText = i = ""), i) for(l in i)u && l in u || $(n.style, l, "");
        if (u) for(l in u)i && u[l] === i[l] || $(n.style, l, u[l]);
    }
    else if ("o" === l[0] && "n" === l[1]) o = l !== (l = l.replace(/Capture$/, "")), l = l.toLowerCase() in n ? l.toLowerCase().slice(2) : l.slice(2), n.l || (n.l = {}), n.l[l + o] = u, u ? i || n.addEventListener(l, o ? T : I, o) : n.removeEventListener(l, o ? T : I, o);
    else if ("dangerouslySetInnerHTML" !== l) {
        if (t) l = l.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
        else if ("href" !== l && "list" !== l && "form" !== l && "tabIndex" !== l && "download" !== l && l in n) try {
            n[l] = null == u ? "" : u;
            break n;
        } catch (n1) {}
        "function" == typeof u || (null == u || !1 === u && -1 == l.indexOf("-") ? n.removeAttribute(l) : n.setAttribute(l, u));
    }
}
function I(n) {
    this.l[n.type + !1](l.event ? l.event(n) : n);
}
function T(n) {
    this.l[n.type + !0](l.event ? l.event(n) : n);
}
function j(n, u, i, t, o, r, f, e, c) {
    var a, h, v, y, _, k, b, g, m, x, A, C, $, H, I, T = u.type;
    if (void 0 !== u.constructor) return null;
    null != i.__h && (c = i.__h, e = u.__e = i.__e, u.__h = null, r = [
        e
    ]), (a = l.__b) && a(u);
    try {
        n: if ("function" == typeof T) {
            if (g = u.props, m = (a = T.contextType) && t[a.__c], x = a ? m ? m.props.value : a.__ : t, i.__c ? b = (h = u.__c = i.__c).__ = h.__E : ("prototype" in T && T.prototype.render ? u.__c = h = new T(g, x) : (u.__c = h = new d(g, x), h.constructor = T, h.render = O), m && m.sub(h), h.props = g, h.state || (h.state = {}), h.context = x, h.__n = t, v = h.__d = !0, h.__h = [], h._sb = []), null == h.__s && (h.__s = h.state), null != T.getDerivedStateFromProps && (h.__s == h.state && (h.__s = s({}, h.__s)), s(h.__s, T.getDerivedStateFromProps(g, h.__s))), y = h.props, _ = h.state, v) null == T.getDerivedStateFromProps && null != h.componentWillMount && h.componentWillMount(), null != h.componentDidMount && h.__h.push(h.componentDidMount);
            else {
                if (null == T.getDerivedStateFromProps && g !== y && null != h.componentWillReceiveProps && h.componentWillReceiveProps(g, x), !h.__e && null != h.shouldComponentUpdate && !1 === h.shouldComponentUpdate(g, h.__s, x) || u.__v === i.__v) {
                    for(h.props = g, h.state = h.__s, u.__v !== i.__v && (h.__d = !1), h.__v = u, u.__e = i.__e, u.__k = i.__k, u.__k.forEach(function(n) {
                        n && (n.__ = u);
                    }), A = 0; A < h._sb.length; A++)h.__h.push(h._sb[A]);
                    h._sb = [], h.__h.length && f.push(h);
                    break n;
                }
                null != h.componentWillUpdate && h.componentWillUpdate(g, h.__s, x), null != h.componentDidUpdate && h.__h.push(function() {
                    h.componentDidUpdate(y, _, k);
                });
            }
            if (h.context = x, h.props = g, h.__v = u, h.__P = n, C = l.__r, $ = 0, "prototype" in T && T.prototype.render) {
                for(h.state = h.__s, h.__d = !1, C && C(u), a = h.render(h.props, h.state, h.context), H = 0; H < h._sb.length; H++)h.__h.push(h._sb[H]);
                h._sb = [];
            } else do {
                h.__d = !1, C && C(u), a = h.render(h.props, h.state, h.context), h.state = h.__s;
            }while (h.__d && ++$ < 25);
            h.state = h.__s, null != h.getChildContext && (t = s(s({}, t), h.getChildContext())), v || null == h.getSnapshotBeforeUpdate || (k = h.getSnapshotBeforeUpdate(y, _)), I = null != a && a.type === p && null == a.key ? a.props.children : a, w(n, Array.isArray(I) ? I : [
                I
            ], u, i, t, o, r, f, e, c), h.base = u.__e, u.__h = null, h.__h.length && f.push(h), b && (h.__E = h.__ = null), h.__e = !1;
        } else null == r && u.__v === i.__v ? (u.__k = i.__k, u.__e = i.__e) : u.__e = L(i.__e, u, i, t, o, r, f, c);
        (a = l.diffed) && a(u);
    } catch (n1) {
        u.__v = null, (c || null != r) && (u.__e = e, u.__h = !!c, r[r.indexOf(e)] = null), l.__e(n1, u, i);
    }
}
function z(n, u) {
    l.__c && l.__c(u, n), n.some(function(u) {
        try {
            n = u.__h, u.__h = [], n.some(function(n) {
                n.call(u);
            });
        } catch (n1) {
            l.__e(n1, u.__v);
        }
    });
}
function L(l, u, i, t, o, r, e, c) {
    var s, h, v, y = i.props, p = u.props, d = u.type, k = 0;
    if ("svg" === d && (o = !0), null != r) {
        for(; k < r.length; k++)if ((s = r[k]) && "setAttribute" in s == !!d && (d ? s.localName === d : 3 === s.nodeType)) {
            l = s, r[k] = null;
            break;
        }
    }
    if (null == l) {
        if (null === d) return document.createTextNode(p);
        l = o ? document.createElementNS("http://www.w3.org/2000/svg", d) : document.createElement(d, p.is && p), r = null, c = !1;
    }
    if (null === d) y === p || c && l.data === p || (l.data = p);
    else {
        if (r = r && n.call(l.childNodes), h = (y = i.props || f).dangerouslySetInnerHTML, v = p.dangerouslySetInnerHTML, !c) {
            if (null != r) for(y = {}, k = 0; k < l.attributes.length; k++)y[l.attributes[k].name] = l.attributes[k].value;
            (v || h) && (v && (h && v.__html == h.__html || v.__html === l.innerHTML) || (l.innerHTML = v && v.__html || ""));
        }
        if (C(l, p, y, o, c), v) u.__k = [];
        else if (k = u.props.children, w(l, Array.isArray(k) ? k : [
            k
        ], u, i, t, o && "foreignObject" !== d, r, e, r ? r[0] : i.__k && _(i, 0), c), null != r) for(k = r.length; k--;)null != r[k] && a(r[k]);
        c || ("value" in p && void 0 !== (k = p.value) && (k !== l.value || "progress" === d && !k || "option" === d && k !== y.value) && H(l, "value", k, y.value, !1), "checked" in p && void 0 !== (k = p.checked) && k !== l.checked && H(l, "checked", k, y.checked, !1));
    }
    return l;
}
function M(n, u, i) {
    try {
        "function" == typeof n ? n(u) : n.current = u;
    } catch (n1) {
        l.__e(n1, i);
    }
}
function N(n, u, i) {
    var t, o;
    if (l.unmount && l.unmount(n), (t = n.ref) && (t.current && t.current !== n.__e || M(t, null, u)), null != (t = n.__c)) {
        if (t.componentWillUnmount) try {
            t.componentWillUnmount();
        } catch (n1) {
            l.__e(n1, u);
        }
        t.base = t.__P = null, n.__c = void 0;
    }
    if (t = n.__k) for(o = 0; o < t.length; o++)t[o] && N(t[o], u, i || "function" != typeof n.type);
    i || null == n.__e || a(n.__e), n.__ = n.__e = n.__d = void 0;
}
function O(n, l, u) {
    return this.constructor(n, u);
}
function P(u, i, t) {
    var o, r, e;
    l.__ && l.__(u, i), r = (o = "function" == typeof t) ? null : t && t.__k || i.__k, e = [], j(i, u = (!o && t || i).__k = h(p, null, [
        u
    ]), r || f, f, void 0 !== i.ownerSVGElement, !o && t ? [
        t
    ] : r ? null : i.firstChild ? n.call(i.childNodes) : null, e, !o && t ? t : r ? r.__e : i.firstChild, o), z(e, u);
}
function S(n, l) {
    P(n, l, S);
}
function q(l, u, i) {
    var t, o, r, f = s({}, l.props);
    for(r in u)"key" == r ? t = u[r] : "ref" == r ? o = u[r] : f[r] = u[r];
    return arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), v(l.type, f, t || l.key, o || l.ref, null);
}
function B(n, l) {
    var u = {
        __c: l = "__cC" + r++,
        __: n,
        Consumer: function(n, l) {
            return n.children(l);
        },
        Provider: function(n) {
            var u, i;
            return this.getChildContext || (u = [], (i = {})[l] = this, this.getChildContext = function() {
                return i;
            }, this.shouldComponentUpdate = function(n) {
                this.props.value !== n.value && u.some(b);
            }, this.sub = function(n) {
                u.push(n);
                var l = n.componentWillUnmount;
                n.componentWillUnmount = function() {
                    u.splice(u.indexOf(n), 1), l && l.call(n);
                };
            }), n.children;
        }
    };
    return u.Provider.__ = u.Consumer.contextType = u;
}
n = e.slice, l = {
    __e: function(n, l, u, i) {
        for(var t, o, r; l = l.__;)if ((t = l.__c) && !t.__) try {
            if ((o = t.constructor) && null != o.getDerivedStateFromError && (t.setState(o.getDerivedStateFromError(n)), r = t.__d), null != t.componentDidCatch && (t.componentDidCatch(n, i || {}), r = t.__d), r) return t.__E = t;
        } catch (l1) {
            n = l1;
        }
        throw n;
    }
}, u = 0, i = function(n) {
    return null != n && void 0 === n.constructor;
}, d.prototype.setState = function(n, l) {
    var u;
    u = null != this.__s && this.__s !== this.state ? this.__s : this.__s = s({}, this.state), "function" == typeof n && (n = n(s({}, u), this.props)), n && s(u, n), null != n && this.__v && (l && this._sb.push(l), b(this));
}, d.prototype.forceUpdate = function(n) {
    this.__v && (this.__e = !0, n && this.__h.push(n), b(this));
}, d.prototype.render = p, t = [], g.__r = 0, r = 0;
 //# sourceMappingURL=preact.module.js.map


/***/ }),

/***/ 46470:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const os = __webpack_require__(22037);
const tty = __webpack_require__(76224);
const hasFlag = __webpack_require__(1379);
const { env  } = process;
let forceColor;
if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
    forceColor = 0;
} else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = 1;
}
if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
        forceColor = 1;
    } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
    } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
}
function translateLevel(level) {
    if (level === 0) {
        return false;
    }
    return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
    };
}
function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
        return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
    }
    if (hasFlag("color=256")) {
        return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
        return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === "dumb") {
        return min;
    }
    if (process.platform === "win32") {
        // Windows 10 build 10586 is the first Windows release that supports 256 colors.
        // Windows 10 build 14931 is the first release that supports 16m/TrueColor.
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
            return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
    }
    if ("CI" in env) {
        if ([
            "TRAVIS",
            "CIRCLECI",
            "APPVEYOR",
            "GITLAB_CI",
            "GITHUB_ACTIONS",
            "BUILDKITE"
        ].some((sign)=>sign in env) || env.CI_NAME === "codeship") {
            return 1;
        }
        return min;
    }
    if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
        return 3;
    }
    if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch(env.TERM_PROGRAM){
            case "iTerm.app":
                return version >= 3 ? 3 : 2;
            case "Apple_Terminal":
                return 2;
        }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
    }
    if ("COLORTERM" in env) {
        return 1;
    }
    return min;
}
function getSupportLevel(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
}
module.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};


/***/ }),

/***/ 31932:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "v1", ({
    enumerable: true,
    get: function() {
        return _v.default;
    }
}));
Object.defineProperty(exports, "v3", ({
    enumerable: true,
    get: function() {
        return _v2.default;
    }
}));
Object.defineProperty(exports, "v4", ({
    enumerable: true,
    get: function() {
        return _v3.default;
    }
}));
Object.defineProperty(exports, "v5", ({
    enumerable: true,
    get: function() {
        return _v4.default;
    }
}));
Object.defineProperty(exports, "NIL", ({
    enumerable: true,
    get: function() {
        return _nil.default;
    }
}));
Object.defineProperty(exports, "version", ({
    enumerable: true,
    get: function() {
        return _version.default;
    }
}));
Object.defineProperty(exports, "validate", ({
    enumerable: true,
    get: function() {
        return _validate.default;
    }
}));
Object.defineProperty(exports, "stringify", ({
    enumerable: true,
    get: function() {
        return _stringify.default;
    }
}));
Object.defineProperty(exports, "parse", ({
    enumerable: true,
    get: function() {
        return _parse.default;
    }
}));
var _v = _interopRequireDefault(__webpack_require__(33895));
var _v2 = _interopRequireDefault(__webpack_require__(72306));
var _v3 = _interopRequireDefault(__webpack_require__(14752));
var _v4 = _interopRequireDefault(__webpack_require__(61298));
var _nil = _interopRequireDefault(__webpack_require__(75951));
var _version = _interopRequireDefault(__webpack_require__(33865));
var _validate = _interopRequireDefault(__webpack_require__(26709));
var _stringify = _interopRequireDefault(__webpack_require__(77378));
var _parse = _interopRequireDefault(__webpack_require__(64264));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}


/***/ }),

/***/ 61575:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _crypto = _interopRequireDefault(__webpack_require__(6113));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function md5(bytes) {
    if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
        bytes = Buffer.from(bytes, "utf8");
    }
    return _crypto.default.createHash("md5").update(bytes).digest();
}
var _default = md5;
exports["default"] = _default;


/***/ }),

/***/ 75951:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _default = "00000000-0000-0000-0000-000000000000";
exports["default"] = _default;


/***/ }),

/***/ 64264:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _validate = _interopRequireDefault(__webpack_require__(26709));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function parse(uuid) {
    if (!(0, _validate.default)(uuid)) {
        throw TypeError("Invalid UUID");
    }
    let v;
    const arr = new Uint8Array(16); // Parse ########-....-....-....-............
    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v >>> 16 & 0xff;
    arr[2] = v >>> 8 & 0xff;
    arr[3] = v & 0xff; // Parse ........-####-....-....-............
    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 0xff; // Parse ........-....-####-....-............
    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 0xff; // Parse ........-....-....-####-............
    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 0xff; // Parse ........-....-....-....-############
    // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)
    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
    arr[11] = v / 0x100000000 & 0xff;
    arr[12] = v >>> 24 & 0xff;
    arr[13] = v >>> 16 & 0xff;
    arr[14] = v >>> 8 & 0xff;
    arr[15] = v & 0xff;
    return arr;
}
var _default = parse;
exports["default"] = _default;


/***/ }),

/***/ 85154:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
exports["default"] = _default;


/***/ }),

/***/ 92377:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = rng;
var _crypto = _interopRequireDefault(__webpack_require__(6113));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate
let poolPtr = rnds8Pool.length;
function rng() {
    if (poolPtr > rnds8Pool.length - 16) {
        _crypto.default.randomFillSync(rnds8Pool);
        poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
}


/***/ }),

/***/ 38533:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _crypto = _interopRequireDefault(__webpack_require__(6113));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function sha1(bytes) {
    if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
        bytes = Buffer.from(bytes, "utf8");
    }
    return _crypto.default.createHash("sha1").update(bytes).digest();
}
var _default = sha1;
exports["default"] = _default;


/***/ }),

/***/ 77378:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _validate = _interopRequireDefault(__webpack_require__(26709));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */ const byteToHex = [];
for(let i = 0; i < 256; ++i){
    byteToHex.push((i + 0x100).toString(16).substr(1));
}
function stringify(arr, offset = 0) {
    // Note: Be careful editing this code!  It's been tuned for performance
    // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
    const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
    // of the following:
    // - One or more input array values don't map to a hex octet (leading to
    // "undefined" in the uuid)
    // - Invalid input values for the RFC `version` or `variant` fields
    if (!(0, _validate.default)(uuid)) {
        throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
}
var _default = stringify;
exports["default"] = _default;


/***/ }),

/***/ 33895:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _rng = _interopRequireDefault(__webpack_require__(92377));
var _stringify = _interopRequireDefault(__webpack_require__(77378));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;
let _clockseq; // Previous uuid creation time
let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details
function v1(options, buf, offset) {
    let i = buf && offset || 0;
    const b = buf || new Array(16);
    options = options || {};
    let node = options.node || _nodeId;
    let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
    // specified.  We do this lazily to minimize issues related to insufficient
    // system entropy.  See #189
    if (node == null || clockseq == null) {
        const seedBytes = options.random || (options.rng || _rng.default)();
        if (node == null) {
            // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
            node = _nodeId = [
                seedBytes[0] | 0x01,
                seedBytes[1],
                seedBytes[2],
                seedBytes[3],
                seedBytes[4],
                seedBytes[5]
            ];
        }
        if (clockseq == null) {
            // Per 4.2.2, randomize (14 bit) clockseq
            clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
        }
    } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
    let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock
    let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)
    const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression
    if (dt < 0 && options.clockseq === undefined) {
        clockseq = clockseq + 1 & 0x3fff;
    } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
        nsecs = 0;
    } // Per 4.2.1.2 Throw error if too many uuids are requested
    if (nsecs >= 10000) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
    msecs += 12219292800000; // `time_low`
    const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff; // `time_mid`
    const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff; // `time_high_and_version`
    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
    b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
    b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`
    b[i++] = clockseq & 0xff; // `node`
    for(let n = 0; n < 6; ++n){
        b[i + n] = node[n];
    }
    return buf || (0, _stringify.default)(b);
}
var _default = v1;
exports["default"] = _default;


/***/ }),

/***/ 72306:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _v = _interopRequireDefault(__webpack_require__(52393));
var _md = _interopRequireDefault(__webpack_require__(61575));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const v3 = (0, _v.default)("v3", 0x30, _md.default);
var _default = v3;
exports["default"] = _default;


/***/ }),

/***/ 52393:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = _default;
exports.URL = exports.DNS = void 0;
var _stringify = _interopRequireDefault(__webpack_require__(77378));
var _parse = _interopRequireDefault(__webpack_require__(64264));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function stringToBytes(str) {
    str = unescape(encodeURIComponent(str)); // UTF8 escape
    const bytes = [];
    for(let i = 0; i < str.length; ++i){
        bytes.push(str.charCodeAt(i));
    }
    return bytes;
}
const DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
exports.DNS = DNS;
const URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
exports.URL = URL;
function _default(name, version, hashfunc) {
    function generateUUID(value, namespace, buf, offset) {
        if (typeof value === "string") {
            value = stringToBytes(value);
        }
        if (typeof namespace === "string") {
            namespace = (0, _parse.default)(namespace);
        }
        if (namespace.length !== 16) {
            throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
        } // Compute hash of namespace and value, Per 4.3
        // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
        // hashfunc([...namespace, ... value])`
        let bytes = new Uint8Array(16 + value.length);
        bytes.set(namespace);
        bytes.set(value, namespace.length);
        bytes = hashfunc(bytes);
        bytes[6] = bytes[6] & 0x0f | version;
        bytes[8] = bytes[8] & 0x3f | 0x80;
        if (buf) {
            offset = offset || 0;
            for(let i = 0; i < 16; ++i){
                buf[offset + i] = bytes[i];
            }
            return buf;
        }
        return (0, _stringify.default)(bytes);
    } // Function#name is not settable on some platforms (#270)
    try {
        generateUUID.name = name; // eslint-disable-next-line no-empty
    } catch (err) {} // For CommonJS default export support
    generateUUID.DNS = DNS;
    generateUUID.URL = URL;
    return generateUUID;
}


/***/ }),

/***/ 14752:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _rng = _interopRequireDefault(__webpack_require__(92377));
var _stringify = _interopRequireDefault(__webpack_require__(77378));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function v4(options, buf, offset) {
    options = options || {};
    const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided
    if (buf) {
        offset = offset || 0;
        for(let i = 0; i < 16; ++i){
            buf[offset + i] = rnds[i];
        }
        return buf;
    }
    return (0, _stringify.default)(rnds);
}
var _default = v4;
exports["default"] = _default;


/***/ }),

/***/ 61298:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _v = _interopRequireDefault(__webpack_require__(52393));
var _sha = _interopRequireDefault(__webpack_require__(38533));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const v5 = (0, _v.default)("v5", 0x50, _sha.default);
var _default = v5;
exports["default"] = _default;


/***/ }),

/***/ 26709:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _regex = _interopRequireDefault(__webpack_require__(85154));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function validate(uuid) {
    return typeof uuid === "string" && _regex.default.test(uuid);
}
var _default = validate;
exports["default"] = _default;


/***/ }),

/***/ 33865:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _validate = _interopRequireDefault(__webpack_require__(26709));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function version(uuid) {
    if (!(0, _validate.default)(uuid)) {
        throw TypeError("Invalid UUID");
    }
    return parseInt(uuid.substr(14, 1), 16);
}
var _default = version;
exports["default"] = _default;


/***/ }),

/***/ 65670:
/***/ ((module) => {

"use strict";

module.exports = function(Yallist) {
    Yallist.prototype[Symbol.iterator] = function*() {
        for(let walker = this.head; walker; walker = walker.next){
            yield walker.value;
        }
    };
};


/***/ }),

/***/ 63694:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = Yallist;
Yallist.Node = Node;
Yallist.create = Yallist;
function Yallist(list) {
    var self = this;
    if (!(self instanceof Yallist)) {
        self = new Yallist();
    }
    self.tail = null;
    self.head = null;
    self.length = 0;
    if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
            self.push(item);
        });
    } else if (arguments.length > 0) {
        for(var i = 0, l = arguments.length; i < l; i++){
            self.push(arguments[i]);
        }
    }
    return self;
}
Yallist.prototype.removeNode = function(node) {
    if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
    }
    var next = node.next;
    var prev = node.prev;
    if (next) {
        next.prev = prev;
    }
    if (prev) {
        prev.next = next;
    }
    if (node === this.head) {
        this.head = next;
    }
    if (node === this.tail) {
        this.tail = prev;
    }
    node.list.length--;
    node.next = null;
    node.prev = null;
    node.list = null;
    return next;
};
Yallist.prototype.unshiftNode = function(node) {
    if (node === this.head) {
        return;
    }
    if (node.list) {
        node.list.removeNode(node);
    }
    var head = this.head;
    node.list = this;
    node.next = head;
    if (head) {
        head.prev = node;
    }
    this.head = node;
    if (!this.tail) {
        this.tail = node;
    }
    this.length++;
};
Yallist.prototype.pushNode = function(node) {
    if (node === this.tail) {
        return;
    }
    if (node.list) {
        node.list.removeNode(node);
    }
    var tail = this.tail;
    node.list = this;
    node.prev = tail;
    if (tail) {
        tail.next = node;
    }
    this.tail = node;
    if (!this.head) {
        this.head = node;
    }
    this.length++;
};
Yallist.prototype.push = function() {
    for(var i = 0, l = arguments.length; i < l; i++){
        push(this, arguments[i]);
    }
    return this.length;
};
Yallist.prototype.unshift = function() {
    for(var i = 0, l = arguments.length; i < l; i++){
        unshift(this, arguments[i]);
    }
    return this.length;
};
Yallist.prototype.pop = function() {
    if (!this.tail) {
        return undefined;
    }
    var res = this.tail.value;
    this.tail = this.tail.prev;
    if (this.tail) {
        this.tail.next = null;
    } else {
        this.head = null;
    }
    this.length--;
    return res;
};
Yallist.prototype.shift = function() {
    if (!this.head) {
        return undefined;
    }
    var res = this.head.value;
    this.head = this.head.next;
    if (this.head) {
        this.head.prev = null;
    } else {
        this.tail = null;
    }
    this.length--;
    return res;
};
Yallist.prototype.forEach = function(fn, thisp) {
    thisp = thisp || this;
    for(var walker = this.head, i = 0; walker !== null; i++){
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
    }
};
Yallist.prototype.forEachReverse = function(fn, thisp) {
    thisp = thisp || this;
    for(var walker = this.tail, i = this.length - 1; walker !== null; i--){
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
    }
};
Yallist.prototype.get = function(n) {
    for(var i = 0, walker = this.head; walker !== null && i < n; i++){
        // abort out of the list early if we hit a cycle
        walker = walker.next;
    }
    if (i === n && walker !== null) {
        return walker.value;
    }
};
Yallist.prototype.getReverse = function(n) {
    for(var i = 0, walker = this.tail; walker !== null && i < n; i++){
        // abort out of the list early if we hit a cycle
        walker = walker.prev;
    }
    if (i === n && walker !== null) {
        return walker.value;
    }
};
Yallist.prototype.map = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();
    for(var walker = this.head; walker !== null;){
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
    }
    return res;
};
Yallist.prototype.mapReverse = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();
    for(var walker = this.tail; walker !== null;){
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
    }
    return res;
};
Yallist.prototype.reduce = function(fn, initial) {
    var acc;
    var walker = this.head;
    if (arguments.length > 1) {
        acc = initial;
    } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
    } else {
        throw new TypeError("Reduce of empty list with no initial value");
    }
    for(var i = 0; walker !== null; i++){
        acc = fn(acc, walker.value, i);
        walker = walker.next;
    }
    return acc;
};
Yallist.prototype.reduceReverse = function(fn, initial) {
    var acc;
    var walker = this.tail;
    if (arguments.length > 1) {
        acc = initial;
    } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
    } else {
        throw new TypeError("Reduce of empty list with no initial value");
    }
    for(var i = this.length - 1; walker !== null; i--){
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
    }
    return acc;
};
Yallist.prototype.toArray = function() {
    var arr = new Array(this.length);
    for(var i = 0, walker = this.head; walker !== null; i++){
        arr[i] = walker.value;
        walker = walker.next;
    }
    return arr;
};
Yallist.prototype.toArrayReverse = function() {
    var arr = new Array(this.length);
    for(var i = 0, walker = this.tail; walker !== null; i++){
        arr[i] = walker.value;
        walker = walker.prev;
    }
    return arr;
};
Yallist.prototype.slice = function(from, to) {
    to = to || this.length;
    if (to < 0) {
        to += this.length;
    }
    from = from || 0;
    if (from < 0) {
        from += this.length;
    }
    var ret = new Yallist();
    if (to < from || to < 0) {
        return ret;
    }
    if (from < 0) {
        from = 0;
    }
    if (to > this.length) {
        to = this.length;
    }
    for(var i = 0, walker = this.head; walker !== null && i < from; i++){
        walker = walker.next;
    }
    for(; walker !== null && i < to; i++, walker = walker.next){
        ret.push(walker.value);
    }
    return ret;
};
Yallist.prototype.sliceReverse = function(from, to) {
    to = to || this.length;
    if (to < 0) {
        to += this.length;
    }
    from = from || 0;
    if (from < 0) {
        from += this.length;
    }
    var ret = new Yallist();
    if (to < from || to < 0) {
        return ret;
    }
    if (from < 0) {
        from = 0;
    }
    if (to > this.length) {
        to = this.length;
    }
    for(var i = this.length, walker = this.tail; walker !== null && i > to; i--){
        walker = walker.prev;
    }
    for(; walker !== null && i > from; i--, walker = walker.prev){
        ret.push(walker.value);
    }
    return ret;
};
Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
    if (start > this.length) {
        start = this.length - 1;
    }
    if (start < 0) {
        start = this.length + start;
    }
    for(var i = 0, walker = this.head; walker !== null && i < start; i++){
        walker = walker.next;
    }
    var ret = [];
    for(var i = 0; walker && i < deleteCount; i++){
        ret.push(walker.value);
        walker = this.removeNode(walker);
    }
    if (walker === null) {
        walker = this.tail;
    }
    if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
    }
    for(var i = 0; i < nodes.length; i++){
        walker = insert(this, walker, nodes[i]);
    }
    return ret;
};
Yallist.prototype.reverse = function() {
    var head = this.head;
    var tail = this.tail;
    for(var walker = head; walker !== null; walker = walker.prev){
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
    }
    this.head = tail;
    this.tail = head;
    return this;
};
function insert(self, node, value) {
    var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);
    if (inserted.next === null) {
        self.tail = inserted;
    }
    if (inserted.prev === null) {
        self.head = inserted;
    }
    self.length++;
    return inserted;
}
function push(self, item) {
    self.tail = new Node(item, self.tail, null, self);
    if (!self.head) {
        self.head = self.tail;
    }
    self.length++;
}
function unshift(self, item) {
    self.head = new Node(item, null, self.head, self);
    if (!self.tail) {
        self.tail = self.head;
    }
    self.length++;
}
function Node(value, prev, next, list) {
    if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
    }
    this.list = list;
    this.value = value;
    if (prev) {
        prev.next = this;
        this.prev = prev;
    } else {
        this.prev = null;
    }
    if (next) {
        next.prev = this;
        this.next = next;
    } else {
        this.next = null;
    }
}
try {
    // add if support for Symbol.iterator is present
    __webpack_require__(65670)(Yallist);
} catch (er) {}


/***/ }),

/***/ 49766:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"126":{"host":"smtp.126.com","port":465,"secure":true},"163":{"host":"smtp.163.com","port":465,"secure":true},"1und1":{"host":"smtp.1und1.de","port":465,"secure":true,"authMethod":"LOGIN"},"AOL":{"domains":["aol.com"],"host":"smtp.aol.com","port":587},"Bluewin":{"host":"smtpauths.bluewin.ch","domains":["bluewin.ch"],"port":465},"DebugMail":{"host":"debugmail.io","port":25},"DynectEmail":{"aliases":["Dynect"],"host":"smtp.dynect.net","port":25},"Ethereal":{"aliases":["ethereal.email"],"host":"smtp.ethereal.email","port":587},"FastMail":{"domains":["fastmail.fm"],"host":"smtp.fastmail.com","port":465,"secure":true},"GandiMail":{"aliases":["Gandi","Gandi Mail"],"host":"mail.gandi.net","port":587},"Gmail":{"aliases":["Google Mail"],"domains":["gmail.com","googlemail.com"],"host":"smtp.gmail.com","port":465,"secure":true},"Godaddy":{"host":"smtpout.secureserver.net","port":25},"GodaddyAsia":{"host":"smtp.asia.secureserver.net","port":25},"GodaddyEurope":{"host":"smtp.europe.secureserver.net","port":25},"hot.ee":{"host":"mail.hot.ee"},"Hotmail":{"aliases":["Outlook","Outlook.com","Hotmail.com"],"domains":["hotmail.com","outlook.com"],"host":"smtp-mail.outlook.com","port":587},"iCloud":{"aliases":["Me","Mac"],"domains":["me.com","mac.com"],"host":"smtp.mail.me.com","port":587},"Infomaniak":{"host":"mail.infomaniak.com","domains":["ik.me","ikmail.com","etik.com"],"port":587},"mail.ee":{"host":"smtp.mail.ee"},"Mail.ru":{"host":"smtp.mail.ru","port":465,"secure":true},"Maildev":{"port":1025,"ignoreTLS":true},"Mailgun":{"host":"smtp.mailgun.org","port":465,"secure":true},"Mailjet":{"host":"in.mailjet.com","port":587},"Mailosaur":{"host":"mailosaur.io","port":25},"Mailtrap":{"host":"smtp.mailtrap.io","port":2525},"Mandrill":{"host":"smtp.mandrillapp.com","port":587},"Naver":{"host":"smtp.naver.com","port":587},"One":{"host":"send.one.com","port":465,"secure":true},"OpenMailBox":{"aliases":["OMB","openmailbox.org"],"host":"smtp.openmailbox.org","port":465,"secure":true},"Outlook365":{"host":"smtp.office365.com","port":587,"secure":false},"OhMySMTP":{"host":"smtp.ohmysmtp.com","port":587,"secure":false},"Postmark":{"aliases":["PostmarkApp"],"host":"smtp.postmarkapp.com","port":2525},"qiye.aliyun":{"host":"smtp.mxhichina.com","port":"465","secure":true},"QQ":{"domains":["qq.com"],"host":"smtp.qq.com","port":465,"secure":true},"QQex":{"aliases":["QQ Enterprise"],"domains":["exmail.qq.com"],"host":"smtp.exmail.qq.com","port":465,"secure":true},"SendCloud":{"host":"smtp.sendcloud.net","port":2525},"SendGrid":{"host":"smtp.sendgrid.net","port":587},"SendinBlue":{"host":"smtp-relay.sendinblue.com","port":587},"SendPulse":{"host":"smtp-pulse.com","port":465,"secure":true},"SES":{"host":"email-smtp.us-east-1.amazonaws.com","port":465,"secure":true},"SES-US-EAST-1":{"host":"email-smtp.us-east-1.amazonaws.com","port":465,"secure":true},"SES-US-WEST-2":{"host":"email-smtp.us-west-2.amazonaws.com","port":465,"secure":true},"SES-EU-WEST-1":{"host":"email-smtp.eu-west-1.amazonaws.com","port":465,"secure":true},"Sparkpost":{"aliases":["SparkPost","SparkPost Mail"],"domains":["sparkpost.com"],"host":"smtp.sparkpostmail.com","port":587,"secure":false},"Tipimail":{"host":"smtp.tipimail.com","port":587},"Yahoo":{"domains":["yahoo.com"],"host":"smtp.mail.yahoo.com","port":465,"secure":true},"Yandex":{"domains":["yandex.ru"],"host":"smtp.yandex.ru","port":465,"secure":true},"Zoho":{"host":"smtp.zoho.com","port":465,"secure":true,"authMethod":"LOGIN"}}');

/***/ }),

/***/ 98350:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"nodemailer","version":"6.8.0","description":"Easy as cake e-mail sending from your Node.js applications","main":"lib/nodemailer.js","scripts":{"test":"grunt --trace-warnings"},"repository":{"type":"git","url":"https://github.com/nodemailer/nodemailer.git"},"keywords":["Nodemailer"],"author":"Andris Reinman","license":"MIT","bugs":{"url":"https://github.com/nodemailer/nodemailer/issues"},"homepage":"https://nodemailer.com/","devDependencies":{"@aws-sdk/client-ses":"3.180.0","aws-sdk":"2.1225.0","bunyan":"1.8.15","chai":"4.3.6","eslint-config-nodemailer":"1.2.0","eslint-config-prettier":"8.5.0","grunt":"1.5.3","grunt-cli":"1.4.3","grunt-eslint":"24.0.0","grunt-mocha-test":"0.13.3","libbase64":"1.2.1","libmime":"5.1.0","libqp":"1.1.0","mocha":"10.0.0","nodemailer-ntlm-auth":"1.0.3","proxy":"1.0.2","proxy-test-server":"1.0.0","sinon":"14.0.0","smtp-server":"3.11.0"},"engines":{"node":">=6.0.0"}}');

/***/ }),

/***/ 56412:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"openid-client","version":"5.3.0","description":"OpenID Connect Relying Party (RP, Client) implementation for Node.js runtime, supports passportjs","keywords":["auth","authentication","basic","certified","client","connect","dynamic","electron","hybrid","identity","implicit","oauth","oauth2","oidc","openid","passport","relying party","strategy"],"homepage":"https://github.com/panva/node-openid-client","repository":"panva/node-openid-client","funding":{"url":"https://github.com/sponsors/panva"},"license":"MIT","author":"Filip Skokan <panva.ip@gmail.com>","exports":{"types":"./types/index.d.ts","import":"./lib/index.mjs","require":"./lib/index.js"},"main":"./lib/index.js","types":"./types/index.d.ts","files":["lib","types/index.d.ts"],"scripts":{"format":"npx prettier --loglevel silent --write ./lib ./test ./certification ./types","test":"mocha test/**/*.test.js"},"dependencies":{"jose":"^4.10.0","lru-cache":"^6.0.0","object-hash":"^2.0.1","oidc-token-hash":"^5.0.1"},"devDependencies":{"@types/node":"^16.11.5","@types/passport":"^1.0.7","base64url":"^3.0.1","chai":"^4.2.0","jose2":"npm:jose@^2.0.5","mocha":"^10.1.0","nock":"^13.0.2","prettier":"^2.4.1","readable-mock-req":"^0.2.2","sinon":"^9.2.0","timekeeper":"^2.2.0"},"standard-version":{"scripts":{"postchangelog":"sed -i \'\' -e \'s/### \\\\[/## [/g\' CHANGELOG.md"},"types":[{"type":"feat","section":"Features"},{"type":"fix","section":"Fixes"},{"type":"chore","hidden":true},{"type":"docs","hidden":true},{"type":"style","hidden":true},{"type":"refactor","section":"Refactor","hidden":false},{"type":"perf","section":"Performance","hidden":false},{"type":"test","hidden":true}]}}');

/***/ }),

/***/ 43727:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"postmark","description":"Official Node.js client library for the Postmark HTTP API - https://www.postmarkapp.com","license":"MIT","tags":["email","utility","postmark","sending","transactional"],"version":"3.0.14","author":"Igor Balos","contributors":["Igor Balos","Andrew Theken","Aaron Blum","Aleksey Aleksandrov","Alex Shepard","Antony Jones","Ben Burwell","Ben Williamson","Chris Williams","Jakub Borys","Mark Nguyen","Matt","Matthew Blackshaw","Matthew Conlen","Ryan Kirkman","Scott Anderson","Sebastien Chopin","Theophane RUPIN","codesplicer","francescoRubini"],"main":"./dist/index.js","types":"./dist/index.d.ts","directories":{"lib":"./dist/index.js"},"scripts":{"compile":"rm -r -f ./dist && node_modules/.bin/tsc","test":"node_modules/mocha/bin/mocha --timeout 30000 --retries 1 -r ts-node/register test/**/*test.ts","unittest":"node_modules/mocha/bin/mocha --timeout 30000 --retries 1 -r ts-node/register test/unit/**/*test.ts","watchtests":"node_modules/.bin/mocha --timeout 30000 --retries 1 -r ts-node/register -R list -w --recursive -G test/**/*test.ts","lint":"tslint -c tslint.json \'src/**/*.ts\'","lintfix":"tslint -c tslint.json \'src/**/*.ts\' --fix","compile-docs":"echo \'Generating docs...\' && mkdir -p ./docs && rm -r ./docs && node_modules/.bin/typedoc --options typedoc.json && git add -A ./docs && echo \'Generated docs!\'"},"homepage":"http://ActiveCampaign.github.io/postmark.js","repository":{"type":"git","url":"https://github.com/ActiveCampaign/postmark.js.git"},"bugs":{"url":"https://github.com/ActiveCampaign/postmark.js/issues"},"precommit":["compile","lint","test","compile-docs"],"devDependencies":{"@types/chai":"4.3.1","@types/mocha":"^5.2.5","@types/nconf":"0.0.37","@types/node":"^4.0.29","@types/sinon":"^7.5.0","chai":"4.3.1","mocha":"5.2.0","nconf":"^0.10.0","pre-commit":"1.2.2","sinon":"^7.5.0","ts-node":"^7.0.1","tslint":"^6.1.3","typedoc":"^0.22.11","typescript":"4.5.5"},"dependencies":{"axios":"^0.25.0"}}');

/***/ })

};
;